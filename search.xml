<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElementUI Upload组件上传图片</title>
    <url>/2019/08/07/ElementUI-Upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>ElementUI组件使用真的很方便，不过因为是封装好的组件所以在项目中使用的局限性也比较大，官方提供的<a href="https://element.eleme.io/#/zh-CN/component/upload" target="_blank" rel="noopener">api</a>用起来就有些不足。</p>
<h4 id="开发背景"><a href="#开发背景" class="headerlink" title="开发背景"></a>开发背景</h4><p>需要把图片上传至文件系统服务器，再将返回的储存路径，通过axios请求发给后端。在以前的项目中是直接对input[type=”file”]做处理，使用的是<strong>formData</strong>作为参数传值。官方api上并没有提供非表单上传文件的方法，结合别人的思路和自己的思考，本篇文章对此做个总结。</p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ol>
<li>action: 为必填项，如果使用axios发送请求，可以为空</li>
<li>ref: 获取上传文件的内容，实际项目中没用到。取值: this.$refs.uploadImage.fileList，该值与函数返回的file内的值相同</li>
<li>multiple: 同时选择多个文件</li>
<li>list-type: 文件列表的类型(text/picture/picture-card)</li>
<li>accept: 限制上传文件类型</li>
<li>limit: 限制上传文件数量</li>
<li>auto-upload: 自动上传(默认为true)，如果使用axios发送请求，设置为false</li>
<li>file-list: 上传的文件列表</li>
<li>on-exceed: 图片数量超出限定大小时调用</li>
<li>on-change: 添加、上传成功或失败时调用</li>
<li>on-remove: 移除图片时调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-upload</span><br><span class="line">    action=<span class="string">""</span></span><br><span class="line">    ref=<span class="string">"uploadImage"</span></span><br><span class="line">    multiple</span><br><span class="line">    list-type=<span class="string">"picture-card"</span></span><br><span class="line">    accept=<span class="string">".jpg,.jpeg,.png,.pdf,.JPG,.JPEG,.PDF"</span></span><br><span class="line">    :limit=<span class="string">"20"</span></span><br><span class="line">    :auto-upload=<span class="string">"false"</span></span><br><span class="line">    :file-list=<span class="string">"imagesList"</span></span><br><span class="line">    :on-exceed=<span class="string">"handleExceed"</span></span><br><span class="line">    :on-change=<span class="string">"handleChange"</span></span><br><span class="line">    :on-remove=<span class="string">"handleRemove"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &lt;i slot=<span class="string">"default"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-icon-plus"</span>&gt;&lt;/i&gt;</span><br><span class="line">    &lt;div slot=<span class="string">"file"</span> slot-scope=<span class="string">"&#123;file&#125;"</span>&gt;</span><br><span class="line">      &lt;img</span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-upload-list__item-thumbnail"</span></span><br><span class="line">        :src=<span class="string">"file.url"</span> alt=<span class="string">""</span></span><br><span class="line">      &gt;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-upload-list__item-actions"</span>&gt;</span><br><span class="line">        &lt;span</span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-upload-list__item-delete"</span></span><br><span class="line">        &gt;</span><br><span class="line">          &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-icon-delete"</span>&gt;&lt;/i&gt;</span><br><span class="line">        &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div slot="tip" class="el-upload__tip"&gt;支持JPG/</span>JPEG/PNG/PDF格式，大小在<span class="number">10</span>MB内，最大上传数<span class="number">20</span>个&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>el-upload&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    data() &#123;</span></span><br><span class="line"><span class="regexp">      imagesList: [],</span></span><br><span class="line"><span class="regexp">      imagesSelectList: [],</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 上传图片超出限定值</span></span><br><span class="line"><span class="regexp">      handleExceed(file, fileList) &#123;</span></span><br><span class="line"><span class="regexp">        this.$message.warning('所选图片数量超出最大值');</span></span><br><span class="line"><span class="regexp">      &#125;,</span></span><br><span class="line"><span class="regexp">      handleChange(file, fileList) &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 文件后缀做判断</span></span><br><span class="line"><span class="regexp">        let nameArr = file.name.split('.');</span></span><br><span class="line"><span class="regexp">        let fileType = nameArr[nameArr.length - 1];</span></span><br><span class="line"><span class="regexp">        if (fileType == 'pdf') &#123;</span></span><br><span class="line"><span class="regexp">          fileType = 'text';</span></span><br><span class="line"><span class="regexp">        &#125;else &#123;</span></span><br><span class="line"><span class="regexp">          fileType = 'img';</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 上传图片至文件服务器，再获取返回的储存路径</span></span><br><span class="line"><span class="regexp">        let formData = new FormData();</span></span><br><span class="line"><span class="regexp">        formData.append('type', fileType);</span></span><br><span class="line"><span class="regexp">        formData.append('file', file.raw)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        this.$axios.post(</span></span><br><span class="line"><span class="regexp">          '/</span>fileUpload<span class="string">',</span></span><br><span class="line"><span class="string">          formData,</span></span><br><span class="line"><span class="string">          res =&gt; &#123;</span></span><br><span class="line"><span class="string">            if (res.code == 0) &#123;</span></span><br><span class="line"><span class="string">              this.imagesSelectList.push(&#123;</span></span><br><span class="line"><span class="string">                name: file.name,</span></span><br><span class="line"><span class="string">                url: res.data.file_url</span></span><br><span class="line"><span class="string">              &#125;);</span></span><br><span class="line"><span class="string">            &#125;else &#123;</span></span><br><span class="line"><span class="string">              this.$message.warning(res.message);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      // 移除文件</span></span><br><span class="line"><span class="string">      handleRemove(file, fileList) &#123;</span></span><br><span class="line"><span class="string">        let index = this.imagesSelectList.findIndex((item) =&gt; &#123;</span></span><br><span class="line"><span class="string">          return item.name == file.name;</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">        if (index !== -1) &#123;</span></span><br><span class="line"><span class="string">          this.imagesSelectList.splice(index, 1);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>el-upload</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title>input限制输入字符的方法</title>
    <url>/2019/07/30/v-model%E9%99%90%E5%88%B6%E8%BE%93%E5%85%A5%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="限制只能输入数字"><a href="#限制只能输入数字" class="headerlink" title="限制只能输入数字"></a>限制只能输入数字</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onkeyup</span>=<span class="string">'this.value=this.value.replace(/\D/gi,"")'</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="input限制保留两位小数，且只能输入数字及一个小数点符号"><a href="#input限制保留两位小数，且只能输入数字及一个小数点符号" class="headerlink" title="input限制保留两位小数，且只能输入数字及一个小数点符号"></a>input限制保留两位小数，且只能输入数字及一个小数点符号</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearNoNum</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = e.target;</span><br><span class="line">  obj.value = obj.value.replace(<span class="regexp">/[^\d.]/g</span>,<span class="string">""</span>); <span class="comment">//清除"数字"和"."以外的字符</span></span><br><span class="line">  obj.value = obj.value.replace(<span class="regexp">/^\./g</span>,<span class="string">""</span>); <span class="comment">//验证第一个字符是数字</span></span><br><span class="line">  obj.value = obj.value.replace(<span class="regexp">/\.&#123;2,&#125;/g</span>,<span class="string">"."</span>); <span class="comment">//只保留第一个, 清除多余的</span></span><br><span class="line">  obj.value = obj.value.replace(<span class="string">"."</span>,<span class="string">"$#$"</span>).replace(<span class="regexp">/\./g</span>,<span class="string">""</span>).replace(<span class="string">"$#$"</span>,<span class="string">"."</span>);</span><br><span class="line">  obj.value = obj.value.replace(<span class="regexp">/^(\-)*(\d+)\.(\d\d).*$/</span>,<span class="string">'$1$2.$3'</span>); <span class="comment">//只能输入两个小数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//以上已经过滤，此处控制的是如果没有小数点，首位不能为类似于 01、02的金额</span></span><br><span class="line">  <span class="keyword">if</span>(obj.value.indexOf(<span class="string">"."</span>) &lt; <span class="number">0</span> &amp;&amp; obj.value !=<span class="string">""</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.value.substr(<span class="number">0</span>,<span class="number">1</span>) == <span class="string">'0'</span> &amp;&amp; obj.value.length == <span class="number">2</span>)&#123;</span><br><span class="line">        obj.value= <span class="built_in">parseFloat</span>(obj.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Input中调用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"je"</span> <span class="attr">onkeyup</span>=<span class="string">"clearNoNum(this)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="input限制输入正整数"><a href="#input限制输入正整数" class="headerlink" title="input限制输入正整数"></a>input限制输入正整数</h2><p>原型需求：项目中的Input要求只能输入正整数</p>
<h4 id="给input绑定keyup事件"><a href="#给input绑定keyup事件" class="headerlink" title="给input绑定keyup事件"></a>给input绑定keyup事件</h4><p>该方式直接在标签内绑定事件，仅适用于input数量较少时使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span> @<span class="attr">keyup</span>=<span class="string">"value = value.length === 1 ? value.replace(/[^1-9]/g, '') : value.replace(/\D/g, '')"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用vue自定义指令"><a href="#使用vue自定义指令" class="headerlink" title="使用vue自定义指令"></a>使用vue自定义指令</h4><ol>
<li><p>新建js文件 parseInt.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 针对 el-input做的限制，只能输入正整数</span></span><br><span class="line">  Vue.directive(<span class="string">'Int'</span>, &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> input = el</span><br><span class="line">      input.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.value.length === <span class="number">1</span>) &#123;</span><br><span class="line">          input.value = input.value.replace(<span class="regexp">/[^1-9]/g</span>, <span class="string">''</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          input.value = input.value.replace(<span class="regexp">/[^\d]/g</span>, <span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(input, <span class="string">'input'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      input.onblur = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.value.length === <span class="number">1</span>) &#123;</span><br><span class="line">          input.value = input.value.replace(<span class="regexp">/[^1-9]/g</span>, <span class="string">''</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          input.value = input.value.replace(<span class="regexp">/[^\d]/g</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 去掉所有从第一位开始的数字0</span></span><br><span class="line">          input.value = input.value.replace(<span class="regexp">/\b(0+)/gi</span>, <span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        trigger(input, <span class="string">'input'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************</span></span><br><span class="line"><span class="comment">  ** Fn: trigger</span></span><br><span class="line"><span class="comment">  ** Intro: 参考 https://github.com/vuejs/Discussion/issues/157#issuecomment-273301588</span></span><br><span class="line"><span class="comment">  ** Author: zyx</span></span><br><span class="line"><span class="comment">*********************************/</span></span><br><span class="line"><span class="keyword">const</span> trigger = <span class="function">(<span class="params">el, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>)</span><br><span class="line">  e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">  el.dispatchEvent(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js中注册自定义指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Directives <span class="keyword">from</span> <span class="string">'./assets/js/parseInt.js'</span></span><br><span class="line">Vue.use(Directives)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">3. 在vue文件内应用</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>html</span><br><span class="line">&lt;input v-<span class="keyword">else</span> v-model.trim=<span class="string">"item.num"</span> type=<span class="string">"number"</span> max=<span class="string">"40"</span> v-Int/&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>该问题解决方案参考<a href="https://juejin.im/post/5bc5c48f6fb9a05d09658093" target="_blank" rel="noopener">该文章</a>，并在作者的方法上做了相应需求的修改。</p>
<p>原方法判断只有一位数字时会限制输入数字0，但是无法限制长按0键时的一串数字(该Bug来源于我们公司优秀的测试)。</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器本地储存方法</title>
    <url>/2019/07/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%82%A8%E5%AD%98%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>在vue中获取本地cookie值的封装方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定名称(name)的cookie值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^| )"</span>+name+<span class="string">"=([^;]*)(;|$)"</span>));</span><br><span class="line">  <span class="keyword">if</span>(arr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：(^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cookieData = getCookie(<span class="string">'token'</span>);</span><br></pre></td></tr></table></figure>

<p>cookieData为获取名为’token’的cookie值</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>js</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>表单校验正则的方法</title>
    <url>/2019/08/07/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E6%AD%A3%E5%88%99%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>做项目时，肯定会有表单验证这样的需求，但是每次多少都不太一样，本篇文章用于记录开发中我所用过的且可用的验证方法。本项目中使用ElementUI框架，ElementUI是基于Vue.js开发的UI框架，有封装好的各种组件可直接使用，并且可以自己配置主题颜色，适用于需要高效快捷完成开发工作的同学。</p>
<h2 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h2><ol>
<li><p>用户名/姓名<br>不限制输入字符，长度为10位<br>可使用input的属性：maxlength</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"1-10个字符，允许中英文、数字或符号"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">maxlength</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">clearable</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"params.name"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"validateForm('name')"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123; nameError &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手机号<br>限制输入字符仅为数字且长度为11位<br>绑定input事件，最好使用oninput，@input方法不生效。在输入时判断当前输入字符是否为数字，除数字外的字符都被替换为空，并且对超出长度的字符截取。</p>
</li>
</ol>
<p><strong>注：绑定事件后，maxlength不生效。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"number"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">oninput</span>=<span class="string">"value=value.replace(/[^\d]/g,'').slice(0,11)"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"请输入手机号"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"params.phone"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">clearable</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">"validateForm('phone')"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123; phoneError &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="逻辑代码"><a href="#逻辑代码" class="headerlink" title="逻辑代码"></a>逻辑代码</h2><p><strong>validateForm</strong>方法在input失去焦点时调用，即可进行数值的校验。为防止失焦校验不准确，在最后提交时，再校验一遍，也可以校验其他不需要失焦校验的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        name: <span class="string">''</span>,</span><br><span class="line">        phone: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">      verified: <span class="literal">true</span>,</span><br><span class="line">      nameError: <span class="string">''</span>,</span><br><span class="line">      phoneError: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="comment">// 表单校验</span></span><br><span class="line">      validateForm(field) &#123;</span><br><span class="line">        <span class="comment">// 校验规则</span></span><br><span class="line">        <span class="keyword">let</span> reg = &#123;</span><br><span class="line">          phoneReg: <span class="regexp">/^([1][3-9]&#123;1&#125;)\d&#123;9&#125;$/</span>,</span><br><span class="line">          idNumberReg: <span class="regexp">/^\d&#123;18&#125;|\d&#123;17&#125;[X]$/g</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非空字段，用于显示提示语</span></span><br><span class="line">        <span class="keyword">let</span> msgList = [</span><br><span class="line">          &#123;</span><br><span class="line">            prop: <span class="string">'name'</span>,</span><br><span class="line">            label:<span class="string">'姓名'</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            prop: <span class="string">'phone'</span>,</span><br><span class="line">            label:<span class="string">'手机号'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (field !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// field不为undefined时，当前为失焦判断</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; msgList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> item = msgList[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环匹配与当前field相等的字段</span></span><br><span class="line">            <span class="keyword">if</span> (item.prop == field) &#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">this</span>.params[field] == <span class="string">''</span>) &#123;</span><br><span class="line">                <span class="comment">// 校验不能为空，并提示</span></span><br><span class="line">                <span class="keyword">this</span>[field + <span class="string">'Error'</span>] = item.label + <span class="string">'不能为空'</span>;</span><br><span class="line">                <span class="keyword">this</span>.verified = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span> (field !== <span class="string">'name'</span> &amp;&amp; <span class="keyword">this</span>.params[field].match(reg[field+<span class="string">'Reg'</span>]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 输入字符后进行校验，并提示</span></span><br><span class="line">                <span class="keyword">this</span>[field + <span class="string">'Error'</span>] = item.label + <span class="string">'格式错误'</span>;</span><br><span class="line">                <span class="keyword">this</span>.verified = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不为空且校验正确，清空提示语</span></span><br><span class="line">                <span class="keyword">this</span>[field + <span class="string">'Error'</span>] = <span class="string">''</span>;</span><br><span class="line">                <span class="keyword">this</span>.verified = <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 未传参field时，为最后提交时的校验</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; msgList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> item = msgList[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环匹配所有字段</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.params[item.prop] == <span class="string">''</span>) &#123;</span><br><span class="line">              <span class="comment">// 校验不能为空，并提示</span></span><br><span class="line">              <span class="keyword">this</span>[item.prop + <span class="string">'Error'</span>] = item.label + <span class="string">'不能为空'</span>;</span><br><span class="line">              <span class="keyword">this</span>.verified = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.prop !== <span class="string">'name'</span> &amp;&amp; <span class="keyword">this</span>.params[item.prop].match(reg[item.prop+<span class="string">'Reg'</span>]) == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 输入字符后进行校验，并提示</span></span><br><span class="line">              <span class="keyword">this</span>[item.prop + <span class="string">'Error'</span>] = item.label + <span class="string">'格式错误'</span>;</span><br><span class="line">              <span class="keyword">this</span>.verified = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>[item.prop + <span class="string">'Error'</span>] = <span class="string">''</span>;</span><br><span class="line">              <span class="keyword">this</span>.verified = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 提交表单</span></span><br><span class="line">      submit() &#123;</span><br><span class="line">        <span class="comment">// 调用validateForm方法且不传参，进行校验</span></span><br><span class="line">        <span class="keyword">this</span>.validateForm();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.verified) &#123;</span><br><span class="line">          <span class="comment">// 表单校验正确，提交</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>methods</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ElementUI</tag>
        <tag>input</tag>
        <tag>el-input</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub + Hexo搭建博客</title>
    <url>/2018/07/30/GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做前端开发有几年了，之前一直都是在印象笔记上做记录，可以搜索觉得也挺方便的。</p>
<p>最近突然觉得这样记录下来的内容太碎片化，都是一些常用的方法和解决Bug的方法，并没有对一个问题进行过深入分析和探讨，所以觉得对很多地方的理解比较片面化而且记忆也不牢固。</p>
<p>由此，打算做一个简单的个人博客，用于对平时工作中遇到的问题做总结记录、发表个人己见的日志。</p>
<h2 id="了解GitHub-Pages"><a href="#了解GitHub-Pages" class="headerlink" title="了解GitHub Pages"></a>了解GitHub Pages</h2><p>博客的内容属于展示性的静态页面，不需要与后端进行数据交互。之前使用过GitHub Pages功能，GitHub可以托管项目代码，想要查看页面只需要把代码打包好上传并在相应的域名访问即可</p>
<h2 id="搭建过程-windows环境"><a href="#搭建过程-windows环境" class="headerlink" title="搭建过程(windows环境)"></a>搭建过程(windows环境)</h2><p>搭建过程主要是参考了jeyzhang的<a href="http://www.jeyzhang.com/hexo-github-blog-building.html" target="_blank" rel="noopener">文章</a>，作者大大写的非常详细，只要一步一步的跟着做都会成功的。当然还有专业的文档也可以参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p>
<p><strong>如果换电脑了，或者环境丢失时，可同样按照下面的搭建步骤操作</strong></p>
<ol>
<li><p>安装依赖<br>-<a href="http://nodejs.org/" target="_blank" rel="noopener">node.js</a><br>-<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a></p>
</li>
<li><p>依赖安装完成后，安装<strong>Hexo</strong>，打开Git Bash(或cmd)执行命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Hexo/1.jpg" alt></p>
</li>
<li><p>安装成功后，选择一个放项目的文件夹，初始化项目<br>我的项目存在F盘，当前路径是F:/github-blog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Hexo/2.jpg" alt></p>
</li>
<li><p>启动本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p> 启动成功后，展示如下：<br> <img src="/images/Hexo/3.jpg" alt></p>
<p> 现在就可以在<a href="http://localhost:4000" target="_blank" rel="noopener">本地 http://localhost:4000</a>查看Hexo默认主题效果啦。</p>
</li>
</ol>
<h2 id="线上访问"><a href="#线上访问" class="headerlink" title="线上访问"></a>线上访问</h2><p>本地服务启动成功后，就可以在本地进行博客的新建、编辑了。不过在这之前，先将本地博客与Github进行关联，来托管项目并查看线上效果。</p>
<ol>
<li><p>在<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册账号，并创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">点击页面右上角的+图标，选择New repository。</span><br><span class="line"></span><br><span class="line">在Repository name中填写你的Github账号名.github.io，如：zoe-zc.github.io。</span><br><span class="line"></span><br><span class="line">Description中填写对此repository的描述信息(可选，但建议填写，如Personal website)。</span><br><span class="line"></span><br><span class="line">点击Create repository，完成创建。</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Hexo/4.jpg" alt></p>
</li>
<li><p>创建好项目后，需要绑定Github的SSH Keys</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p> 先进入.ssh目录，或者直接在文件管理器中打开，一般路径是：C:\Users\89513<br> <img src="/images/Hexo/11.jpg" alt></p>
<p> 若没有.ssh目录，则生成新的SSH Keys：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your e-mail(注册Github的邮箱)"</span></span><br></pre></td></tr></table></figure>

<p> <em>注意：这里的邮箱是注册Github的邮箱，不清楚邮箱的可以在下图位置查询</em><br> <img src="/images/Hexo/12.jpg" alt></p>
</li>
<li><p>SSH Key生成成功后，复制<code>~/.ssh/id_rsa.pub</code>文件的内容(包括最后的邮箱)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p> cat+文件名：打印文件的内容</p>
</li>
<li><p>在Github添加SSH Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开Github官网，登陆后进入到个人设置(点击头像-&gt;setting)，点击右侧的SSH Keys，点击Add SSH key；填写title之后，将之前复制的内容粘贴到Key框中，最后点击Add key即可。</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Hexo/5.jpg" alt></p>
</li>
<li><p>检测SSH是否配置成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p> 若配置成功，则显示：<br> <img src="/images/Hexo/7.png" alt></p>
<p> 如果之前设置过SSH keys，但在本地执行检测语句失败时，可以重新复制<code>~/.ssh/id_rsa.pub</code>文件的内容，并在Github上删除原来的SSH keys，添加新的SSH keys。<br> <img src="/images/Hexo/6.jpg" alt></p>
</li>
<li><p>绑定GitHub，将博客发布到Github的同名repository中</p>
<p> 打开<strong>F:/github-blog/blog</strong>文件夹下的_config.yml文件，拖动滚动条至文件最末端，找到图中的位置并修改：<br> <img src="/images/Hexo/8.jpg" alt></p>
<p> 改为：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:zoe-zc/zoe-zc.github.io</span><br></pre></td></tr></table></figure>

<p> <strong>注</strong>： (1) zoe-zc替换成你的Github账户名; (2) 注意在yml文件中，符号“:”后面都是要带空格的。</p>
</li>
</ol>
<p>现在可以通过访问线上域名<a href="https://zoe-zc.github.io/" target="_blank" rel="noopener">https://zoe-zc.github.io/</a>来查看自己的博客了。</p>
<p>至此，本地博客搭建并与GitHub绑定都完成了，默认的主题不太喜欢，决定换成Next主题。</p>
<h2 id="设置Hexo的主题"><a href="#设置Hexo的主题" class="headerlink" title="设置Hexo的主题"></a>设置Hexo的主题</h2><ol>
<li><p>下载Next主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> F:/github-blog/blog</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改主题设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打开D:\Hexo下的_config.yml文件，找到theme字段，将其修改为next</span><br><span class="line"></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地验证是否可用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure>

<p> 访问本地网址，查看主题是否变为Next。</p>
</li>
<li><p>更新Github的主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>本文仅列出常用命令，详细内容请查阅<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">官网</a></p>
<ol>
<li><p>新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n <span class="string">'文章名称'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p> 简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p> 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d, --deploy  文件生成后立即部署网站</span><br><span class="line">-w, --watch   监视文件变动</span><br></pre></td></tr></table></figure>
</li>
<li><p>发表草稿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动本地服务器<br> 默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p> 简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p> 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p, --port    重设端口</span><br><span class="line">-s, --static  只使用静态文件</span><br><span class="line">-l, --log     启动日记记录，使用覆盖记录格式</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p> 简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p> 参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g, --generate  部署之前预先生成静态文件</span><br></pre></td></tr></table></figure>

<p> 该方法最常用，在完成文章后，可将代码同步至GitHub上，就可以在线上查看博客了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>

<p> 部署成功：<br> <img src="/images/Hexo/10.jpg" alt></p>
<p> 这一步最容易失败，具体的解决方法移步至<a href="#报错原因">报错原因</a></p>
</li>
<li><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)<br> 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>为文章设置标签和分类，请参考<a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">文章</a>，感谢~</p>
</li>
<li><p>隐藏特定文章，只有有该文章的链接才可访问的方法，感谢博主大大的解惑<a href="https://blessing.studio/hexo-plugin-to-make-posts-sage-unlisted" target="_blank" rel="noopener">博文</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sage: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件夹下的文章，按照年月日排序，参考<a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394" target="_blank" rel="noopener">文章</a></p>
</li>
<li><p>引用图片的<a href="https://merrier.wang/20190111/image-skills-in-hexo.html" target="_blank" rel="noopener">方法</a>，通过本地引用绝对路径的方式，将图片放在source/images文件夹中，并在.md文件中按照“路径/Hexo/文件名”的方式引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](/images/Hexo/文件名.jpg)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/Hexo/9.jpg" alt></p>
<p>本文最后有介绍如何注册及绑定自己的域名，因为对服务器不熟悉，所以暂时还没有做，感兴趣的朋友可以参考一下呦！友情链接：<a href="http://www.jeyzhang.com/hexo-github-blog-building.html" target="_blank" rel="noopener">戳这里跳转</a></p>
<h3 id="Hexo不重新生成也可预览"><a href="#Hexo不重新生成也可预览" class="headerlink" title="Hexo不重新生成也可预览"></a>Hexo不重新生成也可预览</h3><p>方法一：用hexo-browsersync插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure>

<p>安装好后，不需任何设置，直接打开<code>hexo s</code>即可。</p>
<p>修改文章后，当按下<code>Ctrl+S</code>保存时，页面自动刷新产生改变，同时右上角显示<code>Connected to BrowserSync</code>字样。</p>
<p>方法二：用hexo-livereload插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-livereload --save</span><br></pre></td></tr></table></figure>

<p>然后在站点的<code>_config.yml</code>中配置 livereload 的端口为<code>35729</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livereload:</span><br><span class="line">  port: 35729</span><br></pre></td></tr></table></figure>

<p>即可。<br><strong>经过测试，不设置端口也可以。</strong></p>
<p>然后我们随便打开一篇博文，修改后保存，然后直接使用hexo s命令启动服务预览，在保持服务启动的状态下，再次修改该文章，记住要保存，然后刷新<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到变化。</p>
<p>优缺点<br>如果使用hexo-browsersync，在连接网络的情况下，启动服务hexo s能很快地打开；而在没有网络的情况下，输入hexo s后至少要过5分钟才能启动服务进行预览。但保存后不用刷新即可看到变化。<br>而hexo-livereload在无论离线还是有网时都能很快打开，但是保存后需要手动刷新才能看到变化。</p>
<p>另外，编辑主题的_config.yml可以实时预览。而编辑D:\hexo_config.yml文件不能实时预览，需要重新生成后再预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s -g</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">https://github.com/hexojs/hexo-browsersync</a><br><a href="http://hahack.com/codes/livereload-for-hexo/" target="_blank" rel="noopener">http://hahack.com/codes/livereload-for-hexo/</a><br><a href="https://github.com/hexojs/hexo-livereload" target="_blank" rel="noopener">https://github.com/hexojs/hexo-livereload</a></p>
<h3 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h3><ol>
<li><p>执行hexo d，最开始的报错内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>

<p> 执行命令行解决：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次执行hexo d，又报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: Permission to zoe-zc/zoe-zc.github.io.git denied to 294401374.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (F:\github-blog\blog\node_modules\hexo-util\lib\spawn.js:52:19)</span><br><span class="line">    at ChildProcess.emit (events.js:198:13)</span><br><span class="line">    at ChildProcess.cp.emit (F:\github-blog\blog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)</span><br></pre></td></tr></table></figure>

<p> 各种google下来也没解决，有的说删除.deploy_git文件夹，重新执行hexo d，在我这也不生效。还有说Git环境变量的问题，重新添加了也没用。后来删了项目重新安装也是不行，最后发现id_rsa.pub文件最后的邮箱不是Github的(邮箱是以前同事的名)，在本地重新生成id_rsa.pub文件。然后把GitHub上的SSH Keys删掉，添加新的SSH Keys后就好了。</p>
</li>
<li><p>如果上面的方法都尝试了，但还是报错的话，可以查看本地是否给git设置email和name，当email的值与Githab上SSH Keys的值不一致时，也会报权限问题的错误。<br> 特别是当Github有公司和自己两个账号时，注意检查一下email的值。如果值不对的话，可以按照下面的方法设置：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot;</span><br><span class="line">$ git config --global user.email  &quot;Github邮箱名&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改了Hexo的配置后，本地生效，在执行hexo d -g后线上的代码却不生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决办法：</span><br><span class="line">删除public/css/main.css后，重新执行hexo g，hexo d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>大成功~<br>&nbsp;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>历时一天，终于配置好了属于自己的博客，下午开开心心的写了第一篇文章(也就是你看到的这篇！)。这个过程中遇到了许多问题，最主要原因是因为参考的文档太多太杂，没有从一开始就按照同一篇文章的步骤操作，导致出现了一些奇怪的问题。好在最后都顺利解决，撒花✿✿ヽ(°▽°)ノ✿</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>前端攻城狮的必备项--微信小程序</title>
    <url>/2019/04/18/%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9F%8E%E7%8B%AE%E7%9A%84%E5%BF%85%E5%A4%87%E9%A1%B9--%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在无论是微信还是其他软件都相继推出小程序应用，小程序具有，可见小程序现在的火爆程度，而作为始祖级别的微信小程序更成为了前端开发工程师们的必备的技术了</p>
<p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。即用即开，不用即可快速退出的方式使其相对传统的H5页面有更好的使用体验</p>
<p>小程序就是依托于微信运行的app，有封装好的框架可以直接使用，用于快速开发小程序应用。并且中文的官方文档对开发者更加友好</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>依赖node.js</li>
<li>微信开发者工具</li>
</ul>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>微信号需是微信开发者：微信公众平台 =&gt; 登录(邮箱，需要先注册)</p>
<h2 id="目录结构：数据驱动"><a href="#目录结构：数据驱动" class="headerlink" title="目录结构：数据驱动"></a>目录结构：数据驱动</h2><pre><code>app.js：监听、生命周期、定义全局方法及全局变量(处理全局逻辑)
    生命周期：
        **onLaunch**：当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
        **onError**：当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息
        **onShow**：当小程序启动，或从后台进入前台显示，会触发 onShow
        **onHide**：当小程序从前台进入后台，会触发 onHide
app.json：配置窗口样式、配置路由(全局公共配置)
    &quot;pages&quot;：配置的第一个路径默认就是首页
app.wxss：全局公共样式表

pages/文件目录
    index.js：每个目录下的js文件都需要注册Page方法。
    index.wxml：近似于HTML文件，语法类似。但本质是XML格式的文件。所以无法使用HTML标签(不生效)
    index.wxss：同css语法
    index.json：可以覆盖全局的配置(app.json)</code></pre><h2 id="获取全局方法、变量"><a href="#获取全局方法、变量" class="headerlink" title="获取全局方法、变量"></a>获取全局方法、变量</h2><ol>
<li>获取app实例：var app = getApp();</li>
<li>获取数据：app.globalData.password</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>bindtap</strong> 绑定点击事件</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>wx.navigateTo 页面跳转
无法跳转： https://blog.csdn.net/wqzbxh/article/details/78238073
原因：
    1. 是tabBar中的页面
    2. 未在pages中注册</code></pre><p>小程序框架核心：响应数据绑定的系统，分为视图层和逻辑层。通过框架使数据和逻辑同步。</p>
<p>使用Taro框架原因：1.不能支持直接引入node_module，可以将包拖至项目内使用或npm???</p>
<h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><h3 id="循环-wx-for"><a href="#循环-wx-for" class="headerlink" title="循环 wx:for"></a>循环 wx:for</h3><p>在WXML文件内使用wx:for时，主要循环变量需要有双大括号加持，并且大括号内没有空格，参考官方文档demo</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;imagesList&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"bottom-images"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h4><p>使用swiper组件，出现<strong>组件内的内容存在但无法展示</strong><br>解决办法：<br>① 查看wxml文件内是否有class类名为<code>container</code>的元素，若有则更改/删除class名即可。避免起这样的类名。<br>② 在<code>class=&quot;container&quot;</code>的元素，其直接子元素加上样式<code>width:100%</code>，或者删除app.wxss里的样式<code>.container{display:flex;}</code></p>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>小程序的image组件默认宽320px，高240px。如果设置了宽度，高度不会跟随宽度自适应，需要主动调整。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .li image &#123;</span><br><span class="line">        width: 200rpx;</span><br><span class="line">        height: 267rpx;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">"aspectFit"</span> <span class="attr">src</span>=<span class="string">"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2205564060.webp"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"text-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>电影名字：xxx \n 导演：xxx \n 演员：xxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>将项目中的公共代码模块提取出来，作为模板作用<br>新建模板：<br><strong>通过template标签，name定义模板的名字</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    自定义代码块</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用方法：<br><strong>import单标签引入模板文件，通过template标签的is属性绑定相应模板的name</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"../template/list"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"list"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;movieList&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>模板的共用css，通过在wxss文件内通过<code>@import</code>方法引入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'../template/list.wxss'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><h3 id="文字超出省略"><a href="#文字超出省略" class="headerlink" title="文字超出省略"></a>文字超出省略</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.li</span> <span class="selector-class">.text-right</span> &#123;</span></span><br><span class="line">  width: 400rpx;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-left: 40rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.li</span> <span class="selector-class">.text-right</span> <span class="selector-tag">text</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 超出省略：此处是多行text，所以是单行的text超出省略，且父级有固定宽度 */</span></span></span><br><span class="line">  display: block;</span><br><span class="line"><span class="css">  <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">white-space</span><span class="selector-pseudo">:nowrap</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"li"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">"aspectFit"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.images.small&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"text-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>电影名字：&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>导演：<span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;item.directors&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"index"</span> <span class="attr">wx:for-item</span>=<span class="string">"child"</span>&gt;</span> &#123;&#123;child.name&#125;&#125; <span class="tag">&lt;/<span class="name">block</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>演员：<span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;item.casts&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"index"</span> <span class="attr">wx:for-item</span>=<span class="string">"child"</span>&gt;</span> &#123;&#123;child.name&#125;&#125; <span class="tag">&lt;/<span class="name">block</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/20041801/2.png" alt></p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="setData"><a href="#setData" class="headerlink" title="setData"></a>setData</h3><p>在data内定义的变量，可以直接赋值，但视图层不会发生改变。想要改变视图层，要通过setData赋值才可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变页面的图片，需要setData</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    userImage: <span class="string">'/pages/img/default.png'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变数组下标值，可以直接赋值</span></span><br><span class="line"><span class="keyword">this</span>.data.userSelected = id;</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>在使用<code>wx.request</code>方法发送请求时，如果出现<code>https://xxx.xxx.com 不在以下 request 合法域名列表中，请参考文档</code>这样的报错<br>① 如果是线上项目，可以在微信公众平台添加访问的域名<br>② 如果是测试号写的项目，可以做一个临时的设置，在<code>微信开发者工具</code>中，找到<code>工具</code>–&gt;<code>项目详情</code>–&gt;<code>本地设置</code>–&gt;选中下图选项<br><img src="/images/20041801/1.png" alt></p>
<pre><code>这种方式阻止报错，可以正常发送数据请求

如果有无法请求的情况，特别是在页面可以直接打开接口请求数据，但是发送请求时报错，可以考虑是不是开了vpn的问题，关闭重试。</code></pre>]]></content>
  </entry>
  <entry>
    <title>如何用电脑使用手机蓝牙共享的网络</title>
    <url>/2020/04/24/%E5%A6%82%E4%BD%95%E7%94%A8%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E8%93%9D%E7%89%99%E5%85%B1%E4%BA%AB%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>连接手机无线网的几种方法，亲测可用</p>
<h3 id="USB网络共享"><a href="#USB网络共享" class="headerlink" title="USB网络共享"></a>USB网络共享</h3><p>这个方法其实是下载了PC端的万能钥匙后，在评论里有人提供连接的方法，是通过数据线来连接的。这样根本不需要使用软件，直接用数据线来实现网络共享就可以了！</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li>需要一根数据线连接电脑和手机</li>
<li>打开手机的设置(举例：一加7pro) -&gt; 热点 -&gt; 打开USB网络共享</li>
<li>有可能会弹出一个弹窗，确认即可</li>
<li>电脑网络连接的图标变为宽带连接时，就说明成功了</li>
</ol>
<p>这个方法的好处是方便快捷，操作简单。</p>
<h3 id="蓝牙网络共享"><a href="#蓝牙网络共享" class="headerlink" title="蓝牙网络共享"></a>蓝牙网络共享</h3><p>数据线连接是挺简单方便的，但是有时候需要把手机拿到别的地方使用。就需要频繁的拔线插线，用久了就觉得好麻烦。后来，在网上查到可以蓝牙共享，而且手机正好支持这个功能，赶快实验了起来。</p>
<p>最开始是不成功的，试了好多次，每次都是按照网上的说明来做的，但就是不成功。当时都要气疯了，一度以为是自己电脑的问题，以为是电脑太老了不支持(ThinkPad E531)。现在才知道，只是自己没操作对，Windows10版本怎么会不兼容呢… 0.0</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>打开电脑右下角的通知面板，找到<code>蓝牙</code>，点击打开蓝牙<br><img src="/images/20042401/1.jpg" alt></p>
</li>
<li><p>在任务栏的隐藏栏里找到蓝牙，右键选择<code>加入个人区域网</code><br><img src="/images/20042401/2.jpg" alt></p>
</li>
<li><p>此时，会打开<code>设备和打印机</code>的页面，第一次连接时，这里是没有设备的<br><img src="/images/20042401/4.jpg" alt></p>
</li>
<li><p>打开手机的蓝牙，连接蓝牙，需要是<code>可被发现</code>的状态<br><img src="/images/20042401/12.jpg" alt><br>然后在电脑的<code>设备和打印机</code>页面，点击菜单栏上的<code>添加设备</code><br><img src="/images/20042401/5.jpg" alt></p>
</li>
<li><p>出现添加设备的弹窗，就会开始搜索手机蓝牙，搜到手机设备后，选择出现的手机图标，点击<code>下一步</code><br><img src="/images/20042401/6.jpg" alt></p>
</li>
<li><p>连接时，手机会提示配对请求<br><img src="/images/20042401/13.jpg" alt><br> 点击后，会提示配对密码，点击<code>配对</code><br><img src="/images/20042401/14.jpg" alt><br> 点击电脑上的<code>是</code>，手机与电脑的蓝牙就进行连接了<br><img src="/images/20042401/7.jpg" alt><br> 连接成功，点击<code>关闭</code>即可<br><img src="/images/20042401/8.jpg" alt></p>
</li>
<li><p>现在就已经连接成功了，并且出现配对手机设备的名称和图标<br><img src="/images/20042401/3.jpg" alt></p>
</li>
<li><p>右键选中设备，选择<code>连接时使用</code> -&gt; <code>接入点</code><br><img src="/images/20042401/9.jpg" alt></p>
</li>
</ol>
<p><strong>重点来了</strong>，如果选项显示的是<code>直接连接</code>，而不是<code>接入点</code>的话，那有的设备可能无法连接。即使电脑提示连接成功，但可能也没有网络。这时候先将配对的设备删除，重新执行上面的步骤，等到出现’正在手机安装’的提示就是可以的了。</p>
<p>我的电脑之前连接时就是一直显示<code>直接连接</code>，点击<code>直接连接</code>后虽然提示’连接成功’，但实际上没有反应。试了了好多天，也没有找到解决办法，一度都以为是电脑问题要放弃了。后来自己又瞎试了一下，竟然成功了<del>嘻嘻</del></p>
<p>果然，失败乃成功之母，无论过程怎么样，最后终会成功的</p>
<ol start="9">
<li><p>点击后，会出现<code>连接中</code>的弹窗，稍后提示<code>连接成功</code><br><img src="/images/20042401/10.jpg" alt></p>
</li>
<li><p>查看网络连接的图标，已经变成宽带连接了<br><img src="/images/20042401/11.jpg" alt><br>手机就是已连接的状态<br><img src="/images/20042401/15.jpg" alt></p>
</li>
</ol>
<p><strong>断开后，再次连接时，先将手机的蓝牙和热点内的蓝牙网络共享都打开，电脑再进行连接，避免失败</strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>windows</tag>
        <tag>蓝牙共享</tag>
      </tags>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript①</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A0/</url>
    <content><![CDATA[<h2 id="浏览器发展史"><a href="#浏览器发展史" class="headerlink" title="浏览器发展史"></a>浏览器发展史</h2><ol>
<li>web发展史</li>
</ol>
<ul>
<li>www浏览器：最早发源的浏览器，但是刚出现就消失了</li>
<li>Mosaic(马赛克)是互联网上第一个投入生产并且获得普遍使用的显示图片的浏览器，1993年问世。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;马克·安德森和伊利诺伊大学共同研发了Mosaic浏览器，又来由于版权在伊利诺伊大学手里，不能再被使用，后来又重新组建团队做了一个一模一样的浏览器，名为”Netscape<br>Navigator”轰动一时。这个公司就是”网景”公司。后来，03年的时候改名为Mozilla<br>Firefox。<br>&emsp;&emsp;伊利诺伊大学将浏览器转让给Spy Glass公司，后来微软(比尔盖茨)买下了Spy Glass公司的技术后，开发出了Interner Explorer浏览器(IE1.0，互联网探索者)，在1996年推出。<br>&emsp;&emsp;网景公司开放了浏览器的源码，后来才有了Mozilla Firefox(Mosaic<br>killler)</p>
</blockquote>
<ol start="2">
<li>js发展史</li>
</ol>
<ul>
<li>作者：Brendan Eich</li>
<li>该作者用了23天左右的时间设计了一门语言叫做JavaScript，1996年诞生。C语言</li>
<li>最初是用来改善网页的用户体验，以前的网页都是静态的，发明JavaScript后就可以动态的改变页面的逻辑。</li>
<li>java和JavaScript在技术上没有关系，JavaScript最早叫做”LiveScript”，网景公司最开始和Sun公司进行合作，因为Sun公司发明了”Java”，后来改名为”JavaScript”。后来Sun公司被Oracle公司收购后，JavaScript版权就归Oracle所有。</li>
</ul>
<h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><ol>
<li>shell部分：用户可以看得到的浏览器的部分，例如界面、菜单、设置等</li>
<li>内核部分：用于处理代码并且将代码展示出来的看不到的部分<br>&emsp;大致分为两大部分：<br>&emsp;&emsp;- 渲染引擎(语法规则和渲染)：html、css基础语法的识别，使浏览器怎么绘制页面更高效<br>&emsp;&emsp;- js引擎：js<br>&emsp;&emsp;- 其他模块：异步</li>
</ol>
<p>&emsp;js引擎的历史：<br>&emsp;&emsp;2001，发布了IE6和window xp，实现对js引擎的优化和分离。<br>&emsp;&emsp;2008，Google联合Apple公司联合发开并发布Chrome，当时是webkit内核，引擎代号V8(来源于非常大的火箭的引擎，用C++所写)。以前的引擎是将js代码翻译成C再翻译成机器码，然后机器才能运行。Chrome对js引擎做了优化， 可以直接将JavaScript代码直接转为机器码(0、1)，所以理论上Chrome渲染页面是最快的。<br>&emsp;&emsp;后来，Firefox也推出了功能强大的js引擎，3.5版本 对频繁执行的代码做了路径优化</p>
<h2 id="js的特点"><a href="#js的特点" class="headerlink" title="js的特点"></a>js的特点</h2><h3 id="解释性语言"><a href="#解释性语言" class="headerlink" title="解释性语言"></a>解释性语言</h3><p>由于机器只能识别010101这样的机器码，所以需要将js代码转换为可识别的机器码，这个过程就叫做翻译。一共分为两种：编译性语言和解释性语言，它们的编译方式不同</p>
<p>编译性语言：通篇翻译， 将所有代码翻译完后生成翻译完的文件，程序会执行翻译完的文件。例如，C、C++<br>&emsp;&emsp;优点：快(可以开发游戏引擎、操作系统)<br>&emsp;&emsp;不足：移植性不好(例如C、C++生成的文件不跨平台)</p>
<p>解释性语言：翻译一行执行一行，不生成特定文件。凡是带有”&lt;&gt;”符号的都是解释性语言，例如：php、python<br>&emsp;&emsp;优点：可跨平台<br>&emsp;&emsp;不足：稍微慢</p>
<p>Java不是编译性语言也不是解释性语言，是oak语言。Java是先将.java文件通过指令 javac 编译成 .class文件，再通过Java虚拟机 jvm 解释执行。</p>
<h3 id="单线程-主要指引擎"><a href="#单线程-主要指引擎" class="headerlink" title="单线程(主要指引擎)"></a>单线程(主要指引擎)</h3><p>单线程：同一时间，只能做一件事<br>多线程：同一时间，可以干很多事<br>异步：在计算机里，同时一起做几件事<br>同步：在计算机里，做完一件事再做另一件事\</p>
<h3 id="ECMA标准"><a href="#ECMA标准" class="headerlink" title="ECMA标准"></a>ECMA标准</h3><p>用于统一JavaScript的语法标准，所以也叫作ECMAScript，简称ES。</p>
<h2 id="js执行队列"><a href="#js执行队列" class="headerlink" title="js执行队列"></a>js执行队列</h2><h3 id="轮转时间片"><a href="#轮转时间片" class="headerlink" title="轮转时间片"></a>轮转时间片</h3><p><img src="/images/20062601/js1/Image.png" alt><br>单线程(js引擎)出现两个任务同时执行的效果的原理：轮转时间片</p>
<p>例如，js引擎需要同时执行任务一和任务二，会先将任务一和任务二切成无数个片端，所有片段的顺序完全随机排列(这叫做争抢时间片)，一个片段一个片段的送到js引擎内，js引擎以一个时间片为单位来执行时间片，这样一点一点将任务一和任务二按照片段执行完。</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript④</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A3/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>js的特点：单线程、解释性语言</p>
<p>解释性语言的特点就是翻译一句执行一句，但其实没有这么直观，这是最后一步才执行的。这是js运行三部曲的最后一步</p>
<h4 id="js三部曲"><a href="#js三部曲" class="headerlink" title="js三部曲"></a>js三部曲</h4><ol>
<li>语法分析(语义分析)：通篇执行的过程，判断是否有低级的语法错误，这个过程叫语法分析过程</li>
<li>预编译：在通篇扫描后，没有问题了就开始执行预编译</li>
<li>解释执行：在预编译完成后，在进行解释一行执行一行的操作</li>
</ol>
<h5 id="预编译的两个现象"><a href="#预编译的两个现象" class="headerlink" title="预编译的两个现象"></a>预编译的两个现象</h5><p><img src="/images/20062601/js4/Image.png" alt></p>
<ol>
<li><p>预编译前奏<br> ① imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象(window)所有<br> 例如：a未赋值，直接给a赋值 a = 10;相当于 window.a = 10;<br> <img src="/images/20062601/js4/Image%5B1%5D.png" alt></p>
<p> <em>变量d虽然在函数内，但是因为没有声明就直接赋值，所以是window的属性，可以获取</em></p>
<p> ② 一切声明的全局变量，全是window的属性<br> <strong>window就是全局的域</strong>，window是个对象，相当于仓库一样，变量在声明之后，就放在window中<br> 例如：var a = 10; 相当于 window.a = 10;<br> <img src="/images/20062601/js4/Image%5B2%5D.png" alt></p>
</li>
<li><p>预编译<br> 预编译发生在函数执行的前一刻</p>
<p> 函数预编译四部曲：<br> &emsp;1.<strong>创建AO对象</strong>：AO，即 Activation Object 执行期上下文，执行期上下文是由于函数执行而产生的存储空间库。作用：<br> &emsp;2.在函数内<strong>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined</strong>(这一步实际是变量声明的过程)，形参和变量声明的名字重复时只写一个<br> &emsp;3.<strong>将实参值和形参统一</strong>：将实参的值赋值给形参<br> &emsp;4.<strong>在函数体里面找函数声明</strong>，将函数声明的名作为AO对象的属性名挂起，<strong>值赋予函数体</strong></p>
<blockquote>
<p>OA对象内重复的变量名只写一个，并且后执行获得的值可以覆盖之前的值<br> 在执行函数时，提升后的变量和函数就不再执行了，这个也叫作变量/函数提升</p>
</blockquote>
<p> 实例：<br> <img src="/images/20062601/js4/Image%5B3%5D.png" alt><br> 在函数执行之前，先执行预编译的过程：<br> 第一步：创建AO对象</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO &#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 第二步：找到形参和变量声明，并将他们的名字作为AO对象的属性，值为undefined</p>
<pre><code>在函数中找到形参a和变量声明a、b，虽然有两个a，但只需要写一个即可。
b虽然是函数，但是是用变量来接收的，所以也算在内。</code></pre> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO &#123;</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第三步：形参和实参值统一</p>
<pre><code>实参值为1，赋值给形参，也就是AO对象中的a，此时a为1</code></pre> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第四步：找出函数声明，值为函数体</p>
<pre><code>找到函数声明a和d，且值为函数体，所以AO对象中的a的值变为了函数a的函数体。
且接收了一个属性d，值是函数d的函数体</code></pre> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在预编译完成后，会开始执行函数，方式是解释一行执行一行。<br> 执行第一行的<code>console.log(a);</code>，变量<code>a</code>是保存在<code>AO</code>对象中的值，所以<code>a</code>的值是函数<code>a</code>。<br> 执行第二行时，由于在预编译时已经将变量提升，所以只执行<code>a = 123</code>;<br> 执行第三行的<code>console.log(a);</code>，变量<code>a</code>刚被赋值<code>123</code>，所以打印结果是123<br> 执行第四行时，由于在预编译时已经将函数提升，所以这行忽略不看<br> 执行第五行的<code>console.log(a);</code>，变量<code>a</code>没有改变，所以打印结果依然是123<br> 执行第六行时，由于在预编译时已经将变量提升，所以只执行<code>b = function() {}</code>。并向<code>AO</code>对象的<code>b</code>赋值为函数<code>b</code>.<br> 执行第七行的<code>console.log(b);</code>，变量<code>b</code>是保存在<code>AO</code>对象中的值，所以打印<code>b</code>的值是函数<code>b</code>。<br> AO最后的结果：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO &#123;</span><br><span class="line">    a: <span class="number">123</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 预编译不止发生在函数里，还发生在全局的环境中，产生的对象叫做<strong>全局执行期上下文</strong>。<br> 在全局里没有传参需求，所以预编译步骤只有三步：<br> &emsp;1.生成GO对象，Global Object全局对象<br> &emsp;2.获取变量声明作为GO对象的属性，值为undefined<br> &emsp;3.找到函数声明，值为函数体</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">GO &#123;</span><br><span class="line">    a: <span class="literal">undefined</span> --&gt; 函数a --&gt; <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 事实上，在打印a时要在GO对象中获取值，跟从window中获取值是一样的，所以，<strong>GO就是window对象(GO===window)</strong><br> 任何全局变量都是window上的属性，或者说全局变量都是GO对象的属性。<br> 未经声明就赋值的变量是全局变量归window所有，同理，这种变量是放在GO对象里进行编译的。<br> <img src="/images/20062601/js4/Image%5B4%5D.png" alt></p>
<blockquote>
<p>问：先生成GO还是AO?<br> 答：GO，先看全局变量，带全局函数执行的前一刻，生成AO</p>
</blockquote>
<p> 函数内部有需要用的变量时，用函数内部的，没有的再向外部查找<br> <strong>AO和GO有一个链式关系，访问顺序：就近原则</strong><br> <img src="/images/20062601/js4/Image%5B5%5D.png" alt></p>
<p> <strong>在预编译时，无论GO还是AO都不受其他条件(if判断)的影响</strong></p>
</li>
</ol>
<blockquote>
<p>学习jQuery的好处：公司的老项目会用到(老版本)，学习jQuery的变成思维</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>印象笔记.enex文件转为markdown</title>
    <url>/2018/10/06/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0.enex%E6%96%87%E4%BB%B6%E8%BD%AC%E4%B8%BAmarkdown/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从16年开始，就习惯使用印象笔记来记录一些学习文档和工作日志了。最开始记录的东西比较少，在查找文档时觉得特别好用，渐渐记录的内容多了以后软件使用变得慢了，查找东西也不方便了，所以有了想做自己博客的想法</p>
<p>但是印象笔记导出的文件格式是.enex，想要转为md就需要借助一些工具了</p>
<h3 id="网站转换"><a href="#网站转换" class="headerlink" title="网站转换"></a>网站转换</h3><p>由于之前因为需要，已经将文档导出为html格式了，所以最简单的办法是将html转为md形式。百度了一番后，找到了一个比较不错的<a href="https://cloudconvert.com/html-to-md" target="_blank" rel="noopener">网站</a>，而且<strong>免费</strong>嘻嘻</p>
<p>转换后的文档很完整，只需要将文档的缩进、符号等加以整理就可以发表到博客上了，但是在整理的时候发现这个活儿简直累的让人吐血…</p>
<h3 id="evernote2md"><a href="#evernote2md" class="headerlink" title="evernote2md"></a>evernote2md</h3><p>整理格式实在是个大工程，就想看看有没有不需要整理就能直接转为完美格式md格式的方法，搜索一番无果，但是找到一个软件可以直接将.enex转为md格式，这个就很实用了，毕竟不是谁都会先转成html格式的… 哈哈</p>
<p>在<a href="https://github.com/wormi4ok/evernote2md" target="_blank" rel="noopener">github</a>上，下载软件，然后按照命令行执行转换操作</p>
<blockquote>
<p>注意：执行命令行使用<code>cmd</code>，不要使用<code>git bash</code>，否则报错</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">evernote2md [input] [outputDir]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evernote2md ./notes.enex</span><br></pre></td></tr></table></figure>

<p>执行成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Chrome\Download&gt;evernote2md ./notes.enex</span><br><span class="line">Notes: 1 / 1 [=============================================================================================] 100.00% 0s</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>前端面试指南 -- 小结</title>
    <url>/2019/07/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%20--%20%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为面试做好准备，为未来找好方向</p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>数据类型：基本类型和引用类型(对象)<br>    基本类型：Number、String、Boolean、Undefined、Null、Symbol<br>    引用类型：对象</p>
<p>数字类型是浮点数，基于IEEE754标准<br>NaN也是数字类型，且NaN≠Na，不等于自身</p>
<h3 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h3><p>判断类型：可以准确判断除了<code>null</code>以外的其他基本类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>) <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// "symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> c <span class="comment">// "undefined" 变量c未定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p>其中<code>null</code>是基本类型，但是返回<code>object</code>的原因：</p>
<pre><code>这是一个历史遗留的bug，由于最开始js是地位存储了变量的类型信息，`000`开头表示对象，`null`表示的是全零，所以错误的将`null`判断为`object`了</code></pre><p>正确判断变量类型的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br></pre></td></tr></table></figure>

<p>除了<code>null</code>之外的其他类型可以通过<code>构造器</code>来判断，但是null是原型链的终点，其没有构造器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><em><code>undefined</code>不是保留字，可以在低版本浏览器内被赋值</em></p>
<blockquote>
<p>可以使用<code>void 0</code>或<code>void(0)</code>来代替<code>undefined</code></p>
</blockquote>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li><p>转Boolean<br>除了<code>undefined</code>、<code>null</code>、<code>false</code>、<code>NaN</code>、<code>&#39;&#39;</code>(空字符串，并非空格)、<code>0</code>、<code>-0</code>外，布尔值都转换为true，对象(<code>[]</code>、<code>{}</code>)也是一样</p>
</li>
<li><p>对象转基本类型<br><a href="https://www.jianshu.com/p/c1872ec363cb" target="_blank" rel="noopener">看这</a></p>
</li>
<li><p>四则运算符</p>
</li>
<li><p>==操作符</p>
</li>
<li><p>比较运算符</p>
</li>
</ol>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener">深度解析原型中的难点</a></p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>关键字<code>new</code>在创建新对象时都做了哪些事情：</p>
<ol>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量的方式就没这个问题啦<br><a href="https://juejin.im/post/5d578bacf265da03ee6a548a" target="_blank" rel="noopener">Object.create()、new Object()和字面量{}的区别</a></p>
<p><strong><a href="https://juejin.im/post/5c248fa1e51d450d5a01be39" target="_blank" rel="noopener">js运算符优先级</a></strong></p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><strong><code>instanceof</code></strong> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<ol>
<li><p><a href="http://jartto.wang/2019/01/17/js-typeof/" target="_blank" rel="noopener">分析一下 []、Array、Object 三者之间的关系</a><br> 从 <code>instanceof</code> 能够判断出 <code>[].proto</code> 指向 <code>Array.prototype</code>，而 <code>Array.prototype.proto</code> 又指向了 <code>Object.prototype</code> ，最终 <code>Object.prototype.proto</code> 指向了 <code>null</code> ，标志着原型链的结束。</p>
<p> 因此，[]、Array、Object 就在内部形成了一条原型链：<br> 依次类推，类似的 new Date()、new Parent() 也会形成一条对应的原型链</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>    <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>instanceof</code> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p>
</blockquote>
</li>
<li><p><a href="https://juejin.im/entry/5c11bed6e51d4511624d1b1e" target="_blank" rel="noopener">判断对象是 Array 还是 Object</a></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(arr) <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>

<p> <code>typeof</code> 方法无法判断是否为数组，但可以用来判断除了 <code>array</code>、<code>null</code>以外的值</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.constructor == <span class="built_in">Array</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 上述几种方式好用，但是在有多个iframe时，由于原型链无法共享，所以可能会产生错误</p>
<p> 更好的解决办法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注意右侧字符串大小写及书写正确性 --&gt;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">"[object Array]"</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this优先级：<br>    new(最高) &gt; call、apply、bind &gt; 对象调用 &gt; 全局调用</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-CSS</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-CSS/</url>
    <content><![CDATA[<h2 id="主流浏览器及其内核"><a href="#主流浏览器及其内核" class="headerlink" title="主流浏览器及其内核"></a>主流浏览器及其内核</h2><h3 id="主流浏览器的特点"><a href="#主流浏览器的特点" class="headerlink" title="主流浏览器的特点"></a>主流浏览器的特点</h3><ol>
<li>在市场上占有一定份额</li>
<li>必须有独立研发的内核</li>
</ol>
<p>浏览器由shell(浏览器的操作类的展示部分，也就是外壳：菜单及展示页面的部分)和内核(浏览器的快慢、识别代码路径、优化问题)组成</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ol>
<li>IE：内核 trident（1996年发布IE1.0）</li>
<li>FireFox：内核 Gecko</li>
<li>Google Chrome：内核 Webkit 与苹果工程师共同研发/内核 blink 08年自主研发 2014年投入市场（全球市场份额第一，在2016年年终超越了IE）</li>
<li>Safari：内核  Webkit</li>
<li>Opera（份额5%~3%）：内核 presto</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li>给代码做备注</li>
<li>调试：将代码按照区块注释来找到错误位置<br>HTML：<img src="/images/20060601/CSS_files/Image.png" alt></li>
</ol>
<h2 id="CSS-cascading-style-sheet-层叠样式表"><a href="#CSS-cascading-style-sheet-层叠样式表" class="headerlink" title="CSS(cascading style sheet) 层叠样式表"></a>CSS(cascading style sheet) 层叠样式表</h2><p>CSS的作用：修改HTML的样式</p>
<h3 id="引入CSS"><a href="#引入CSS" class="headerlink" title="引入CSS"></a>引入CSS</h3><ol>
<li>行间样式：在标签内通过style属性设置元素样式 </li>
<li>页面级css：在head标签内写样式</li>
<li>外部css文件：新建一个.css文件并在head标签内通过link标签引入<br><img src="/images/20060601/CSS_files/Image%5B1%5D.png" alt></li>
</ol>
<blockquote>
<p>html文件是怎样引入到页面的？<br>将网页(HTML、css、js)的文件打包后放在服务器(也是电脑)上，用户通过访问网站，拿到服务器的地址后，获取网页文件下载到自己的电脑的浏览器上执行。例如访问百度，是将百度的网页下载到自己的手机上，而不是所有人访问同一个文件，访问的是服务器文件的副本。</p>
</blockquote>
<blockquote>
<p>浏览器是怎么执行下载的文件的？<br>从上至下，下载一行就执行一行代码。<br>在下载的时候，head标签内引入一个css文件，此时浏览器如何执行？<br>异步加载，此时浏览器会开启一个新的线程来下载css文件，原线程会继续下载HTML，所以是同时进行的。</p>
</blockquote>
<blockquote>
<p>补充知识点：<br>异步与同步：异步是指同时执行多个事件；同步是指完成当前事件后才可执行下一个事件；</p>
</blockquote>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>用来选择一个html元素，从而来改变其样式</p>
<ol>
<li><p>id选择器：identity(身份) 一对一的关系，一个元素只能有一个id值</p>
</li>
<li><p>class选择器：多对多的关系，一个元素可以有多个class，一个class也可以作用于多个元素</p>
</li>
<li><p>标签选择器：会选中当前文件内所有的标签元素</p>
</li>
<li><p>通配符选择器：所有标签，整个文档的标签</p>
</li>
<li><p>父子选择器/派生选择器：父子结构即可</p>
</li>
<li><p>直接子元素选择器：用符号’&gt;’连接父子级选择器即可</p>
<p> 一个多层级的父子结构样式的元素，浏览器是如何找到的呢？<br> <img src="/images/20060601/CSS_files/Image%5B2%5D.png" alt><br> dom是树状结构，按照上图从右向左的顺序查找元素，先在整个DOM结构中找到em元素，确定em元素后再向上找到相应的元素，这样以最快的速度找到元素。如果从左向右查找，需要先在整个dom树中的所有元素中查找第一个元素section，然后在找到的每个元素section下再查找其余所有元素来找到第二个元素div，这种方式更加繁琐。</p>
</li>
<li><p>并列选择器：两个选择器选择的同一个元素</p>
</li>
<li><p>分组选择器：<br><img src="/images/20060601/CSS_files/Image%5B3%5D.png" alt></p>
</li>
</ol>
<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p><img src="/images/20060601/CSS_files/Image%5B4%5D.png" alt></p>
<h2 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h2><p>256进制(IE7.0版本测试出来的数据)<br>当两个元素的权重相同时，后渲染的元素css生效</p>
<h3 id="权重的应用：复杂选择器的计算"><a href="#权重的应用：复杂选择器的计算" class="headerlink" title="权重的应用：复杂选择器的计算"></a>权重的应用：复杂选择器的计算</h3><p><img src="/images/20060601/CSS_files/Image%5B5%5D.png" alt></p>
<p>在计算机中，正无穷计算时，可以相加减来比较大小。</p>
<h2 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h2><p>css代码都是由属性组成的，结构为：”属性名: 属性值;”，属性和属性之间通过”;”分号来分隔</p>
<ol>
<li><p>font-size：字体大小，浏览器由默认的字体大小16px，字体大小设置的是字体的高（仿宋字体宽高相等）</p>
</li>
<li><p>font-weight：字体加粗，可选值： lighter、normal、bold、bolder、数值(100 ~ 900 从细到粗)</p>
<blockquote>
<p>浏览器有相应的字体包才能展示相应的样式</p>
</blockquote>
</li>
<li><p>font-style：斜体，值：italic</p>
</li>
<li><p>font-family：字体，值： arial(通用字体，乔布斯在苹果发明第一个就是字体)</p>
</li>
<li><p>color：字体颜色，值：英文单词(red)、颜色代码(#ff0000)、颜色函数(rgb(255,0,0))</p>
<blockquote>
<p>人类可以识别三种颜色(三原色: 红绿蓝)<br>颜色代码从00-ff代表颜色的饱和度，若颜色代码的每两位都是重复的就可以简写为三位</p>
</blockquote>
</li>
<li><p>border：元素的边框<br>复合属性：border-width粗细、border-style虚实样式、border-color颜色<br>border-style：solid 实线、dotted 点状虚线、dashed 条状虚线</p>
<p>将宽高设置为0，为border设置宽度和颜色，利用斜线即可画出三角形</p>
<p>border-radius：圆角度，当值为50%时， 正方形会变成一个圆形</p>
</li>
<li><p>text-align：文字对齐方式，属性值：left(默认值)、center、right</p>
</li>
<li><p>line-height：单行文本所占高度</p>
<blockquote>
<p>行高：文字所占高度（在word中叫做行间距）<br>单行文字水平垂直居中：文本所占高度等于容器高度时，文本在容器内垂直居中</p>
</blockquote>
</li>
<li><p>text-indent：文本缩进</p>
<blockquote>
<p>单位分为绝对单位和相对单位，例如像素px、em是相对单位</p>
</blockquote>
<blockquote>
<p>px：一个像素只能展示一个颜色；电子屏幕由无数个很小很小的像素格组成的，一个屏幕的清晰与否关键在于像素的多少。屏幕分辨率在国际上的标准定义是每英寸所能容纳的垂直像素点数，也就是像素的个数决定了屏幕分辨率。一个像素的大小是可以改变的，同等大小的屏幕，像素越多，成像约清晰，分辨率也越高。</p>
</blockquote>
<blockquote>
<p>em：相对于font-size的大小<br>   公式：1em = 1 * 该标签的font-size（1em等于1font-size，在设置文字(中文)缩进时，1em就相当于一个字的大小）<br>   文字的行高是1.2倍行高(1.2倍文字大小)，也就是 line-height：1.2em;</p>
</blockquote>
</li>
<li><p>text-decoration：文字修饰线<br>属性值：<br>line-through 中划线(删除线)，功能等同于标签del<br>none 没有线，去掉标签自带的线<br>underline 下划线，类似a标签自带样式<br>overline 上划线，不常用</p>
</li>
<li><p>cursor：光标，鼠标在标签上的样式<br>属性值：pointer：小手<br>鼠标上的光标的定位值，好的鼠标不需要在黑色位置也可以使用</p>
</li>
</ol>
<p>查看其他更多属性：<a href="https://www.html.cn/doc/css3/quicksearch/" target="_blank" rel="noopener">https://www.html.cn/doc/css3/quicksearch/</a></p>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><blockquote>
<p>当在行间样式设置后，无法在伪类选择器中改变样式(原因是权重是10，小于行间样式1000)</p>
</blockquote>
<ol>
<li>:hover 鼠标移动到标签上后展示所设置的样式</li>
</ol>
<h2 id="企业级开发思路"><a href="#企业级开发思路" class="headerlink" title="企业级开发思路"></a>企业级开发思路</h2><ol>
<li><p>点定义功能，后选定功能：先写出需要的CSS样式，就相当于写了一个工具库，需要的样式拿出来用<br>优点：先定义好功能样式，也可以封装好一个css文件，其他人就可以直接引用<br><img src="/images/20060601/CSS_files/Image%5B6%5D.png" alt></p>
</li>
<li><p>自定义标签(初始化样式)：通过改变标签的默认样式，也就是标签初始化<br>下图列举了改变标签默认样式的实例：<br><img src="/images/20060601/CSS_files/Image%5B7%5D.png" alt></p>
<p> 通配符选择器* 可以用来初始化所有标签的margin和padding的值，并且其权重值为0，所以在初始化后，也可以通过其他选择器来随意改变初始化的值，不需要考虑权重问题。</p>
</li>
</ol>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子的宽度/高度 = 边框 +内边距 + 宽度/高度</p>
<p>内边距padding是不可以放内容的(例如文字)，也就是说内容不会占padding的位置，但是背景色或背景图片可以<br><img src="/images/20060601/CSS_files/Image%5B8%5D.png" alt></p>
<p>在浏览器中展示的盒子模型，如下图：<br><img src="/images/20060601/CSS_files/Image%5B9%5D.png" alt></p>
<p>padding、margin、border的值：<br>一个值：上下左右相同<br>四个值：值的方向为上 右 下 左，为顺时针方向<br>三个值：值为上 左右 下，其中左右相等为中间的值<br>两个值：值为上下 左右，第一个是上下的值，第二个是左右的值</p>
<h2 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h2><p>定位positon：让特定的元素在特定的位置出现，也叫作层模型<br>定位需要参照物，relative作为参照物，absolute来进行定位，从而减少对后边元素的影响。</p>
<ol>
<li><p>absolute 绝对定位，脱离原来位置进行定位，</p>
<p> 相对于最近的有定位的父级进行定位，如果没有，则相对于文档进行定位</p>
<p> 当一个元素变成绝对定位的元素时，它就脱离了原来的层级，跑到上面的层级上了，原来的位置被释放。这样，这个元素后面的元素就可以来到它之前的位置，这样就会形成同一位置的层级关系，也就是层模型。</p>
</li>
<li><p>relative 相对定位 ，保留原来位置进行定位</p>
<p> 相对于自己原来的位置进行定位</p>
<blockquote>
<p>浏览器中默认的body的margin值是多少？<br> 答：8px</p>
</blockquote>
<p> opacity：不透明度，取值为0~1 值越小越透明</p>
</li>
<li><p>fixed 固定定位</p>
<p> z-index：设置定位元素的层级，默认为0。z也就是z轴，指向与屏幕方向相垂直。</p>
</li>
</ol>
<h2 id="居中布局问题"><a href="#居中布局问题" class="headerlink" title="居中布局问题"></a>居中布局问题</h2><p>一个元素已知宽高，在视窗口中水平垂直居中<br><img src="/images/20060601/CSS_files/Image%5B10%5D.png" alt></p>
<h3 id="两栏布局：一个固定宽度，另一个自适应宽度"><a href="#两栏布局：一个固定宽度，另一个自适应宽度" class="headerlink" title="两栏布局：一个固定宽度，另一个自适应宽度"></a>两栏布局：一个固定宽度，另一个自适应宽度</h3><p><img src="/images/20060601/CSS_files/Image%5B11%5D.png" alt></p>
<h3 id="margin两个经典bug"><a href="#margin两个经典bug" class="headerlink" title="margin两个经典bug"></a>margin两个经典bug</h3><p>① margin-top塌陷问题：父子层级的两个元素的垂直方向margin会重叠再取最大的值，给子元素设置margin-top后，父级会随同子元素移动，这个问题就是margin塌陷问题，可以看做父级没有顶造成的。</p>
<p>解决办法：</p>
<ol>
<li>给父级设置border-top 可以解决问题，但是在语法和编程手法上不可取，并且不符合设计图</li>
<li>BFC (block format context 块级格式化上下文)  并非真正解决问题，只是一个弥补问题的手段<br> 如何触发一个盒子的bfc：<pre><code>a. 给元素设置定位 position: absolute
b. display: inline-block
c. float: left/right
d. overflow: hidden(自身意义：溢出盒子部分不展示) 给父级添加该属性，实际是改变了父级的渲染规则，父级变为bfc后，即可解决塌陷问题</code></pre>上述问题，需要给父级添加css样式即可解决问题  </li>
</ol>
<p>② 左右相邻的兄弟元素的margin是相累加的，这叫做区域不能共用，这是正常的语法规则</p>
<p>上下两个相邻的兄弟元素的margin值是相叠加的，且取最大值</p>
<p>上述问题，解决的办法是给元素外层加一层父级，但是不建议这种解决办法。最好的解决办法是只给一个元素设置margin-top或margin-bottom的值</p>
<h3 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h3><p>无论元素是什么样的陈列方式(inline、block、inline-block)，都可以使元素站队，并且站队的边界是父级的边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   float: left/right;</span><br></pre></td></tr></table></figure>

<p>   原理：浮动元素产生了浮动流，所有产生了浮动流的元素，块级元素都看不到(也就是会分层)，但是产生了bfc的元素和文本类元素(带有Inline属性的元素)以及文本都可以看到(也就是紧挨着元素而不分层)。  </p>
<p>   <strong>清除浮动的方法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear: left/right/both 注意：清除浮动的元素必须是块级元素</span><br></pre></td></tr></table></figure>

<blockquote>
<p>伪元素：存在于每个元素中，一般有::before、::after可以同时使用，可以当做正常元素来使用<br>伪元素是行级元素，设置宽高需要设置display: inline-block</p>
</blockquote>
<p>   <strong>通过给父级添加伪元素清除浮动</strong>：<br><img src="/images/20060601/CSS_files/Image%5B12%5D.png" alt>  </p>
<blockquote>
<p>position: absolute、float: left/right 将元素内部转化为inline-block属性，内容撑开宽高<br>   例如：span元素设置了上述属性后，就可以设置宽高了  </p>
</blockquote>
<h2 id="文字溢出处理"><a href="#文字溢出处理" class="headerlink" title="文字溢出处理"></a>文字溢出处理</h2><p>文字超出容器后，用省略号…展示</p>
<ol>
<li>单行文本  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">white-space: nowrap; 强制文字不换行  </span><br><span class="line">text-overflow: ellipsis; 文字超出后用...展示</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/20060601/CSS_files/Image%5B13%5D.png" alt></p>
<ol start="2">
<li>多行文本：不做文字省略，只做文本截断(只展示固定行数，剩下字数隐藏不展示)<br><img src="/images/20060601/CSS_files/Image%5B14%5D.png" alt>  </li>
</ol>
<h2 id="背景图片处理"><a href="#背景图片处理" class="headerlink" title="背景图片处理"></a>背景图片处理</h2><p>background:<br><img src="/images/20060601/CSS_files/Image%5B15%5D.png" alt></p>
<h3 id="企业级开发问题"><a href="#企业级开发问题" class="headerlink" title="企业级开发问题"></a>企业级开发问题</h3><p>图片如何代替文字：  </p>
<p>一旦浏览器采取了默认加载策略(当前网络不好时，css和js会自动屏蔽掉)，还得让网站可用。<br><img src="/images/20060601/CSS_files/Image%5B16%5D.png" alt><br><img src="/images/20060601/CSS_files/Image%5B17%5D.png" alt>  </p>
<p><strong>行级元素可以嵌套行级元素 span只能嵌套行级元素，a标签内不可以嵌套a标签</strong><br><strong>块级元素可以嵌套任何元素，div可以嵌套任何元素，但是p标签不可以嵌套块级元素</strong>  </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>margin: 0 auto; 可以使设置了宽度的元素居中展示，并且浏览器宽度变化时随之改变</p>
<p>带有inline的元素属于文本类元素，span、img标签等 删除标签间的空格，可以去掉空白间隙</p>
<p>vertical-align: 数值/middle等值; 调节文本对齐的属性。文本默认与文本类元素内的文字底部对齐</p>
]]></content>
  </entry>
  <entry>
    <title>手把手教你安装安卓打包工具</title>
    <url>/2019/10/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚到新公司，需要把项目打包成安卓apk的包。因为以前从来没接触过这方面(虽然以前公司有 android 开发，但仅限联调接口)，在搭建环境的过程中踩了很多的坑，所以对此做一下记录，也希望有需要的小伙伴看了这篇文档可以无障碍安装环境。</p>
<h2 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h2><p>想要搭建好 android 的开发环境，首先需要配置它的依赖 java 。也可以参考其他资料：</p>
<p><a href="https://docs.oracle.com/en/java/javase/13/install/installation-jdk-microsoft-windows-platforms.html#GUID-A7E27B90-A28D-4237-9383-A58B416071CA" target="_blank" rel="noopener">Java官方文档</a></p>
<p><a href="https://cordova.apache.org/docs/en/latest/guide/platforms/android/index.html" target="_blank" rel="noopener">Cordova官方文档</a></p>
<p><a href="https://www.cnblogs.com/ssrs-wanghao/articles/8994856.html" target="_blank" rel="noopener">Windows配置java环境</a></p>
<p><a href="https://www.cnblogs.com/gufengchen/p/11038029.html" target="_blank" rel="noopener">如何搭建Android开发环境</a></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>因为本地 cordova 的版本为v6.5.0（考虑兼容问题），无法使用高版本JDK，所以下载v1.8版本的JDK</p>
<p>之前安装了最新版本，但是报错了，所以还是建议安装v1.8版本的。并且不建议下载zip解压版的，直接下载安装程序进行安装，避免不必要的错误产生。</p>
<h4 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h4><ol>
<li>JDK官网：<a href="https://www.cnblogs.com/ssrs-wanghao/articles/8994856.html" target="_blank" rel="noopener">Java SE Development Kit 8 Downloads</a><br> 官网会提示登录，建议使用百度云下载：  </li>
<li>链接：<a href="https://pan.baidu.com/s/1qlBjw7Tqqxq2WVIrWK8PCA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qlBjw7Tqqxq2WVIrWK8PCA</a><br> 密码：rxpv</li>
</ol>
<h4 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h4><ol>
<li>进入页面后，下滑至页面底部找到”Java SE Development Kit 8u221”</li>
<li>选中第一个选项”Accept License Agreement”<br><img src="/images/JDK/Image.png" alt></li>
<li>根据当前电脑的操作系统下载安装包<br>我的电脑是Windows x64，所以下载”jdk-8u221-windows-x64.exe”</li>
<li>下载成功后，一键安装即可，建议安装在C盘，如果C盘空间告急，也可以安装在其他盘下<br><strong>记住安装的路径，在配置环境变量时需要用到！</strong></li>
</ol>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ol>
<li><p>进入【系统属性】配置页面，具体方法：</p>
<p> 方法一：我的电脑 - 右键打开属性 - 选中侧边栏的【高级系统设置】 - 系统属性中选择tab项【高级】<br> <img src="/images/JDK/Image%5B1%5D.png" alt><br> 方法二：或者直接在Cortana中搜索【环境变量】，即可打开配置页面<br> <img src="/images/JDK/Image%5B2%5D.png" alt></p>
</li>
<li><p>最下面找到【环境变量】并打开，在”<strong>系统变量</strong>“内新建 <strong>JAVA_HOME</strong> 变量，变量值是JDK的安装目录</p>
<blockquote>
<p>C:\Program Files\Java\jdk1.8.0_162</p>
</blockquote>
<p> <img src="/images/JDK/Image%5B3%5D.png" alt></p>
</li>
<li><p>再找到变量名为【Path】的变量并编辑，将JDK下的【bin】目录的路径写在第一位 (防止打包时报错)</p>
<blockquote>
<p>C:\Program Files\Java\jdk1.8.0_162\bin</p>
</blockquote>
<p> <img src="/images/JDK/Image%5B4%5D.png" alt></p>
</li>
<li><p>点击确定关闭窗口后，可以在CMD中输入<code>java</code>、<code>java -version</code>（java -version代表安装的java版本）和<code>javac</code>，若都正常运行则代表 java 已经正确安装。</p>
</li>
</ol>
<h4 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h4><pre><code>Cordova : Requirements check failed for JDK 1.8 or greater</code></pre><p>问题原因：安装的版本过高，卸载之前的版本，安装1.8版本即可。<a href="https://stackoverflow.com/questions/40628240/cordova-requirements-check-failed-for-jdk-1-8-or-greater" target="_blank" rel="noopener">参考答案</a></p>
<h3 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h3><p>如果觉得这部分的文档不够详细，也可以去<a href="https://www.cnblogs.com/gufengchen/p/11038029.html" target="_blank" rel="noopener">这里</a>查看其他参考文档</p>
<h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><ol>
<li><p><a href="http://tools.android-studio.org/index.php/sdk" target="_blank" rel="noopener">Android Studio</a><br><img src="/images/JDK/Image%5B5%5D.png" alt><br>我的电脑是Windows x64，所以下载第一个，同样建议安装在<strong>C盘</strong></p>
</li>
<li><p>如果无法打开上面的地址，还可以选择以下两个下载：</p>
<p> <a href="http://pan.baidu.com/s/1nt8BcBB" target="_blank" rel="noopener">百度云盘</a><br> <img src="/images/JDK/Image%5B6%5D.png" alt></p>
<p> <a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">国内网站</a><br> <img src="/images/JDK/Image%5B7%5D.png" alt></p>
</li>
</ol>
<pre><code>如若不想安装，也可以直接下载zip包，解压到本地即可使用，参考[这里](https://forum.unity.com/threads/guide-android-sdk-tools-installation-cli.598717/)  
不过，本文选择安装程序，所以无法给出上述方法可能会遇到的问题</code></pre><h4 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ol>
<li><p>新建变量 <strong>ANDROID_HOME</strong>，变量值为SDK的安装目录</p>
<blockquote>
<p>C:\Users\89513\AppData\Local\Android\android-sdk</p>
</blockquote>
<p> <img src="/images/JDK/Image%5B8%5D.png" alt></p>
<p> 找到【Path】变量，添加如下两个目录：</p>
<blockquote>
<p>C:\Users\89513\AppData\Local\Android\android-sdk\tools<br>C:\Users\89513\AppData\Local\Android\android-sdk\platform-tools</p>
</blockquote>
</li>
</ol>
<p><img src="/images/JDK/Image%5B9%5D.png" alt></p>
<h4 id="安装工具包"><a href="#安装工具包" class="headerlink" title="安装工具包"></a>安装工具包</h4><ol>
<li><p>安装成功后，进入安装目录，找到 <strong>SDK Manager.exe</strong> 程序，并双击打开运行。<br><img src="/images/JDK/Image%5B10%5D.png" alt></p>
</li>
<li><p>点击后会闪过一个黑影，等几秒钟后就会打开 <strong>Android SDK Manager</strong> 的窗口<br><img src="/images/JDK/Image%5B11%5D.png" alt></p>
</li>
<li><p>需要安装项有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDK Build Tools</span><br><span class="line">SDK Platform Tools</span><br><span class="line">SDK Platform</span><br></pre></td></tr></table></figure>

<p> 选择下图选中的选项：<br><img src="/images/JDK/Image%5B12%5D.png" alt><br><img src="/images/JDK/Image%5B13%5D.png" alt><br><img src="/images/JDK/Image%5B14%5D.png" alt><br>选择完成后，点击右下角进行安装，此时弹出的弹窗选中第三项【Accept License】，最后点击【install】即可，安装的过程有点慢，耐心等待一下~<br><img src="/images/JDK/Image%5B15%5D.png" alt></p>
</li>
</ol>
<p>安装完成后，现在就可以将项目进行打包啦。</p>
<h4 id="删除SDK"><a href="#删除SDK" class="headerlink" title="删除SDK"></a>删除SDK</h4><p>在安装后无法进行打包操作且无法解决报错问题时，就需要重新安装SDK(痛苦0.0)。在重新安装前，应该将之前安装的版本删除干净。删除方法参考自<a href="https://blog.csdn.net/qq_40364358/article/details/85223081" target="_blank" rel="noopener">文档</a></p>
<p><strong>删除位置</strong>，理论上有两处：</p>
<ul>
<li>第一处：是SDK的安装目录，在安装时选择的目录下的sdk文件，不大。</li>
<li>第二处：是C盘 -&gt; user -&gt;《用户名目录》-&gt; AppData -&gt; Local-&gt; android -&gt; sdk文件，这个文件比较大，删除会慢一些。</li>
</ul>
<p><strong>如果再次安装后更改了安装目录的话，记得去修改环境变量的值！！！</strong></p>
<h3 id="遇到的报错问题"><a href="#遇到的报错问题" class="headerlink" title="遇到的报错问题"></a>遇到的报错问题</h3><blockquote>
<p>Could not resolve all files for configuration ‘:classpath’. Could not find com.android.tools.build:gradle:3.0.1. Searched in the following locations: <a href="https://jcenter.bintray.com/com/android/tools/build/gradle/3.0.1/gradle-3.0.1.pom" target="_blank" rel="noopener">https://jcenter.bintray.com/com/android/tools/build/gradle/3.0.1/gradle-3.0.1.pom</a> <a href="https://jcenter.bintray.com/com/android/tools/build/gradle/3.0.1/gradle-3.0.1.jar" target="_blank" rel="noopener">https://jcenter.bintray.com/com/android/tools/build/gradle/3.0.1/gradle-3.0.1.jar</a> Required by: project :</p>
</blockquote>
<p>解决办法：</p>
<ol>
<li><p>找到【platforms】下的build.gradle文件，路径一般为：<strong>本地项目路径\platforms\android\build.gradle</strong>  </p>
</li>
<li><p>修改【buildscript】下的【repositories】为：<br> <img src="/images/JDK/Image%5B16%5D.png" alt></p>
<p> <a href="https://www.jianshu.com/p/02df243dfaa2" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<blockquote>
<p>You have not accepted the license agreements of the following SDK components  </p>
</blockquote>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行命令：./sdkmanager --licenses</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/39760172/you-have-not-accepted-the-license-agreements-of-the-following-sdk-components" target="_blank" rel="noopener">参考</a></p>
<h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p>当前打包流程中，暂时不需要使用该软件，但是建议下载，之后有可能会有需要安装一些依赖</p>
<p>下载成功后，可参考<a href="https://www.jianshu.com/p/6b08119f2261" target="_blank" rel="noopener">该文档</a>进行安装</p>
<h3 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h3><ol>
<li><p>如果想要进行真机调试，所打的包应为debug包才能进行调试操作，执行命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cordova build android -d</span><br></pre></td></tr></table></figure>

<p> 打包成功后的截图：<br><img src="/images/JDK/Image%5B17%5D.png" alt><br>打好包的文件路径：本地目录\platforms\android\build\outputs\apk\debug\android-debug.apk</p>
</li>
<li><p>然后将手机和电脑通过数据线连接，CMD找到apk文件的路径，执行命令行：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p> 找到当前连接的设备<br> <img src="/images/JDK/Image%5B18%5D.png" alt></p>
<p> 若想将安装包直接安装到手机上，执行命令行：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb install .\android-debug.apk</span><br></pre></td></tr></table></figure>

<p> <img src="/images/JDK/Image%5B19%5D.png" alt></p>
<p> <strong>注意：需要卸载之前的安装包，才能重新安装</strong></p>
</li>
</ol>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在chrome上打开：chrome://inspect/#devices，找到要查看的应用后点击【inspect】<br><img src="/images/JDK/Image%5B20%5D.png" alt><br>弹出新的窗口后，即可进行bug调试<br><img src="/images/JDK/Image%5B21%5D.png" alt></p>
<h3 id="打包-正式环境"><a href="#打包-正式环境" class="headerlink" title="打包 - 正式环境"></a>打包 - 正式环境</h3><ol>
<li><p>执行命令行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cordova build android -r</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录<a href="https://portal.qiniu.com/bucket/zxy-app/resource" target="_blank" rel="noopener">七牛网</a>  </p>
</li>
<li><p>点击侧边栏【对象存储】– 【内容管理】，找到需要上传的文件名( 可在右上方进行搜索查询，需要输入全称 )<br><img src="/images/JDK/Image%5B22%5D.png" alt>  </p>
</li>
<li><p>最后，删除之前的版本，将打好包的apk文件上传<br><img src="/images/JDK/Image%5B23%5D.png" alt></p>
</li>
</ol>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ol>
<li><pre><code>Error: Current working directory is not a Cordova-based project. </code></pre><p>解决办法：<br> 检查本地的www文件目录是否存在，若不存在新建一个www文件夹，重新执行命令。<br> 一般这种情况可能是执行命令后www文件夹已经被删除，又中断了命令造成的。</p>
<pre><code>mkdir www</code></pre></li>
<li><p>缺少SDK的依赖包<br><img src="/images/JDK/Image%5B24%5D.png" alt></p>
</li>
<li><p>替换android文件夹下的内容(具体的可以问我)<br><img src="/images/JDK/Image%5B25%5D.png" alt></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接触新的东西总会觉得搭建环境非常的难，我也是在踩了N+1个坑之后才成功安装，期间也是卸载安装了好几次，不同的环境总会遇到不同的问题，包括我的同事在安装时参考了我的文档，也会遇到新的问题，这时候就变成了遇到问题解决问题的过程，最后大家也都成功搭建环境。</p>
<p>所以遇到事情一定有耐心并且认真仔细，无论是什么样的问题，都会被成功解决哒~</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>前端之路的基石-HTML</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-HTML/</url>
    <content><![CDATA[<p><strong>HTML(超文本标记语言 hyperText markup language)</strong></p>
<blockquote>
<p>如果想在外行人面前展示自己的专业性，由于外行人更关注专业素养，只有专业素养好了，别人才能更加认可你。</p>
</blockquote>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>html由一对对的标签组成，每对标签都有自己的含义和意义，用于修饰标签内的内容，这个叫做双标签；而本身就代表着功能，不需要包裹任何内容就能实现其功能的标签叫做单标签。html的标签大概二百五十个网上，每年都在持续增加。</p>
<h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><p>一个标签代表一个功能，标签内的内容具有标签的功能</p>
<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p>根标签，一个html文件只能有一个html标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en, zh"</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>lang属性：告诉搜索引擎爬虫，当前网站展示的语言内容，更方便抓取网站</p>
<pre><code>属性值：
    en：英文
    zh：中文
    de：德语
    其他语言都是汉语拼音前两位</code></pre><blockquote>
<p>知识拓展：<br>&emsp;&emsp;<strong>网站域名</strong>：每一个网站都有一个域名地址，通过域名找到服务器的地址，获取相关的网页内容和资源并在当前访问的电脑上展示，这是网页访问的过程。如：<a href="http://www.duyitec.com/" target="_blank" rel="noopener">www.duyiTec.com</a><br>&emsp;&emsp;<strong>物理地址</strong>：也叫IP地址，如 192.168.1.1<br>&emsp;&emsp;域名会通过<strong>DNS</strong>解析为物理地址<br><img src="/images/20061901/html/Image.png" alt><br>&emsp;&emsp;<strong>搜索引擎爬虫</strong>：例如百度搜索会根据关键字将相关信息抓取到，但是要先签订关键字协议：不允许有黄赌毒，否则封杀。通过”竞价排名”的方式，按顺序排列搜索结果，竞价排名价格：按照点击次数(转化率)收费。价格范围：1-999，一般高价格就是高转化率行业(医院)。但是会通过”IP段锁定”技术(同一个时间段内，一个ip地址访问同一个网站多次时只算一次)并且会检测生物行为(点开页面立刻关闭时不算次数)来避免恶意点击。<br>&emsp;&emsp;<strong>SEO</strong>：叫做搜索引擎优化技术</p>
</blockquote>
<h5 id="html标签包含两个结构化标签"><a href="#html标签包含两个结构化标签" class="headerlink" title="html标签包含两个结构化标签"></a>html标签包含两个结构化标签</h5><h6 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h6><p>为浏览器做配置，例如：历史记录、编码器字符集等</p>
<p>当浏览器出现乱码时，在head标签内新增标签并设置属性charset(编码字符集)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识拓展：<br>&emsp;&emsp;<strong>编码字符集</strong>：gb2312(中国国家标准第2312条，包括亚裔字符集，但缺少繁体字符集)<br>&emsp;&emsp;<strong>gbk</strong>(中国国家标准扩展版本，包含亚裔字符集和繁体字符集)<br>&emsp;&emsp;<strong>unicode</strong>(万国码，包括所有国家的语言)<br>&emsp;&emsp;<strong>utf-8</strong>(unicode transformation format 8 bit 目前通用版本，还有16bit版本) <strong>万国码</strong></p>
</blockquote>
<p>为浏览器设置页面标题（页脚标）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我是标签页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>搜索引擎爬虫的关键字及描述设置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"关键字"</span> <span class="attr">name</span>=<span class="string">"keywords"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"描述"</span> <span class="attr">name</span>=<span class="string">"description"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h6><p>展示给用户看的内容</p>
<p><strong>p标签</strong>：paragraph，段落标签，用处：使标签内的内容成段展示<br><strong>h1~h6标签</strong>：header，标题标签，从一级标题至六级标题的字体大小依次缩小<br>&emsp;&emsp;作用：独成一段、更改字体的大小、加粗字体<br>&emsp;&emsp;快捷生成方式(h${内容}*6)：<br><img src="/images/20061901/html/Image%5B1%5D.png" alt><br><strong>strong标签</strong>：内容加粗展示<br><strong>em标签</strong>：内容呈斜体展示<br>&emsp;&emsp;标签可以嵌套使用：字体加粗且斜体展示<br><img src="/images/20061901/html/Image%5B2%5D.png" alt><br><strong>del标签</strong>：delete，中划线，删除标签<br><strong>address标签</strong>（不常用）：地址标签，独占一行<br><img src="/images/20061901/html/Image%5B3%5D.png" alt><br><strong>div标签</strong>：充当容器，无功能和意义，独占一行<br><strong>span标签</strong>：充当容器，无功能和意义，相同标签在同一行展示<br>&emsp;&emsp;容器的作用：<br>&emsp;&emsp;&emsp;1. 结构化：分块明确，可以划分区间，使页面结构化<br>&emsp;&emsp;&emsp;2. 捆绑操作：只需要操作容器就可以改变容器内的内容</p>
<blockquote>
<p>知识点补充：<br>&emsp;&emsp;空格、回车：在浏览器内表示文本分割符，特别是针对英文单词换行展示<br>&emsp;&emsp;空格文本的展示形式：<br>&emsp;&emsp;&emsp;html编码：<strong>&amp;</strong> + 特殊字符”+”;<br>&emsp;&emsp;&emsp;例如：<strong>&amp;nbsp;</strong>  空格文本 = 空格<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>&amp;lt;</strong>  小于符<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>&amp;gt;</strong>  大于符<br>&emsp;&emsp;&emsp;注意：<br>&emsp;&emsp;&emsp;&emsp;&emsp;小于号&lt;：less than<br>&emsp;&emsp;&emsp;&emsp;&emsp;大于号&gt;：great than(great代表程度上的比较，more代表数量的比较)</p>
</blockquote>
<p><strong>br标签</strong>：回车，代表一个换行符，单标签。<br><strong>hr标签</strong>：代表水平线<br><strong>ol、li</strong>：order list<br>有序列表，成组出现且li的内容都是独占一行，按照1.2.3.的顺序展示。不常用<br>ol是架子，li是内容<br>ol的属性：<br>&emsp;&emsp;1. type：表示排序规则<br>&emsp;&emsp;&emsp;type的值为”1”时，按照数字的顺序排序；<br>&emsp;&emsp;&emsp;type的值为”a”时，按照英文字母顺序排列；<br>&emsp;&emsp;&emsp;type的值为”A”时，按照大写的英文祖母排序；当li数量超过26时，按照AA、AB…(27进制)排序<br>&emsp;&emsp;&emsp;type的值为”i”时，按照小写罗马数字排序(罗马数字诞生最早，阿拉伯数字是阿拉伯人从印度引入的)<br>&emsp;&emsp;&emsp;type的值为”Ⅰ”时，按照大写罗马数字排序</p>
<p>&emsp;&emsp;2. reversed：reversed 反向排序<br>&emsp;&emsp;3. start：开始排序的数值，例如<br><img src="/images/20061901/html/Image%5B4%5D.png" alt></p>
<blockquote>
<p>从孩子到长大的每个阶段喜欢的东西都是不同的，最喜欢的电影《了不起的盖茨比》、《返老还童》。不同年龄看都有不同的体会。</p>
</blockquote>
<p><strong>ul、li</strong>：unorder list 无序列表，展现形式与无序列表相同<br>仅有一个属性：type<br><img src="/images/20061901/html/Image%5B5%5D.png" alt><br>属性值：<br>&emsp;&emsp;disc，discircle 实心圆<br>&emsp;&emsp;square，方块<br>&emsp;&emsp;circle，圈、空心圆</p>
<blockquote>
<p>父子结构适用于：一个大的功能由很多功能子项组成，每个功能子项的功能和样式基本都是相同的，只是内容有些差别。现实生活中举例的话，就是柜子的抽屉，每个抽屉里的东西都不同。代码示例的话就是菜单栏。</p>
</blockquote>
<p><strong>img标签</strong>：image，用于展示图片，单标签<br>图片的相关属性：</p>
<ol>
<li>src：source，图片的资源地址<br>属性值：<br>&emsp;&emsp;1. 网上的url(超级链接，也就是图片的服务器地址)<br>&emsp;&emsp;2. 本地的绝对路径<br>&emsp;&emsp;3. 本地的相对路径</li>
</ol>
<blockquote>
<p>知识点补充：<br>&emsp;&emsp;绝对路径：当两个文件不在同一个文件夹内时，它们的路径呈绝对关系，在一个文件内引入另一个文件时，路径需要写出引入文件的绝对路径(也就是，在本地的完整路径：D:/a/b/c/123.jpg)<br><img src="/images/20061901/html/Image%5B6%5D.png" alt><br>&emsp;&emsp;相对路径：当两个文件在同一个文件夹内时，它们的路径呈相对关系，在一个文件内引入另一个文件时，路径只需写出其文件名即可.<br><img src="/images/20061901/html/Image%5B7%5D.png" alt></p>
</blockquote>
<ol start="2">
<li>alt：图片占位符，当图片展示出错时，会展示文字信息</li>
<li>title：图片提示符，鼠标移动至图片上时，会展示相关信息</li>
</ol>
<p><strong>a标签</strong><br>作用：</p>
<ol>
<li>anchor<br>锚：用于记录某个点的位置，是a标签最开始的作用<br><img src="/images/20061901/html/Image%5B8%5D.png" alt></li>
<li>超链接标签，双标签；a标签可以包裹任何内容，例如：图片、文字</li>
<li>拨打电话功能<img src="/images/20061901/html/Image%5B9%5D.png" alt></li>
<li>发邮件<img src="/images/20061901/html/Image%5B10%5D.png" alt></li>
<li>协议限定符：<img src="/images/20061901/html/Image%5B11%5D.png" alt></li>
</ol>
<p>属性：</p>
<ol>
<li><p>href：hyperText reference超文本参考、超文本引用，内容是指向的链接地址(必须是带有协议的完整链接：http://或https://)；作为锚点使用时，与元素的id配合使用</p>
</li>
<li><p>target(目标)：值为_blank时，表示打开一个新标签</p>
</li>
</ol>
<blockquote>
<p>“为天地立心，为生民立命，为往圣继绝学，为万世开太平” – 北宋大家张载，当代哲学家冯友兰将其称作“横渠四句”。</p>
</blockquote>
<p><strong>form标签</strong>：表单标签，可以发送数据给后端。必须与其他组件配合使用<br>数据发送必须包含两点：数据名name和数据值value(用户输入的内容)</p>
<p>相关属性：</p>
<ol>
<li>method：发送数据的方式，有两个值分别为get、post</li>
<li>action：数据发送的地址</li>
</ol>
<p>相关组件(元素)：</p>
<ol>
<li><p>input：带有属性type，type值不同是代表input的不同功能；也带有属性name，name的值就是发送数据时key的值</p>
<p> type值为：<br> &emsp;&emsp;text 输入框<br> &emsp;&emsp;password 密码框（在储存密码时，通过mds加密方式加密，是不可逆解的）<br> &emsp;&emsp;submit 提交（默认展示文本为”提交”，可以通过修改value属性进行修改</p>
<blockquote>
<p>知识点补充：<br> &emsp;&emsp;网站分几类：有一类受国家安全性协议监管的公司，会对用户提交的密码进行md5(美国二战发明，最厉害的是不可逆，也就是不可破解)加密后储存到数据库，在用户登录时，会对密码进行md5加密，得到的加密密码与数据库的进行比对，由于每次md5加密后得到相同的加密密码，所以当用户密码与数据库密码一致时，即可登录成功。<br> &emsp;&emsp;3G、4G网络相比2G网络来说不仅快了，而且安全性协议高了，会对用户所发送的信息加密，所有更加安全。比如在使用支付宝时，手机发送信号是通过无线信号发送给最近的基站，基站连着网线，通过几次路由，跳到杭州总部的支付宝大厦的服务器。数据正常都是通过有线来传输的，但是移动设备是无线信号发送的，发送无线信号时只要在同一个wifi或同一个基站下方圆五百米之内的无线信号就可以被<a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener"></a><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">Fiddler</a>抓包拦截数据。当通过抓包软件来抓包时，若当前为3G\4G网络，抓取的都是加密信息，获取不到有用数据，而2G网可以直接获取其中的信息。当信号不好时或者有人通过扩大器将信号从五百米扩大至2公里发送信号来抓取用户信息，(通过改变信号频次)网络会从4G变成2G。 </p>
</blockquote>
</li>
<li><p>radio 单选框（有排他性，当存在多个时，通过添加相同的name值来实现单选）<br><img src="/images/20061901/html/Image%5B12%5D.png" alt></p>
<blockquote>
<p>每一个人都会编程，真正的编程需要两部分：一是编程思想、二是编程工具。把编程思想和编程工具结合在一起，编程就是将脑中的思想量化出来的过程，用工具一步步写出来的过程</p>
</blockquote>
<p> 练习题：输入框内有”请输入用户名”的文字，点击输入框时，文字消失；点击页面空白处，文字又出现；在输入框内输入其他文字后，输入字体的颜色不同，且点击页面空白处，文字不消失<br> <img src="/images/20061901/html/Image%5B13%5D.png" alt></p>
</li>
<li><p>checkbox 多选框，其他属性同radio<br><img src="/images/20061901/html/Image%5B14%5D.png" alt><br>产品需要符合三个特点：刚需、用户体验、用户粘性</p>
<p> 默认选中的功能：checked<br> <img src="/images/20061901/html/Image%5B15%5D.png" alt><br> <img src="/images/20061901/html/Image%5B16%5D.png" alt></p>
</li>
<li><p>select、option 下拉框（成组出现）</p>
</li>
</ol>
<p><em>编程模式：结构、行为、样式，相分离</em></p>
<h2 id="归类："><a href="#归类：" class="headerlink" title="归类："></a>归类：</h2><p>标签：不同类别的标签，本质上是由css属性display的不同的值来控制的。例如：行级元素可以设置display=”block”来变成块级元素。</p>
<ol>
<li>行级元素(内联元素 inline)：span、a、em、strong、del<br>feature: 内容决定元素所占位置<br>&emsp;&emsp;&emsp;&emsp;不可以通过css改变宽高</li>
<li>块级元素(block)：div、p、ul、li、ol、form、address<br>feature: 独占一行<br>&emsp;&emsp;&emsp;&emsp;可以通过css改变宽高</li>
<li>行级块元素(内联块元素inline-block)：img（只需要设置宽或高，高度会按比例缩放）<br>feature: 内容决定大小<br>&emsp;&emsp;&emsp;&emsp;可以通过css改变宽高</li>
</ol>
<blockquote>
<p>知识点补充：<br>凡是带有inline特性(包括inline-block)的元素，都有文字特性，所以元素之间会被分割。这个就可以用来解释类似<br>span 或 image<br>这样的多个元素同行展示时会在彼此之间出现空白处(大小为4px，亲测可证)</p>
</blockquote>
<p>代码在上传之前需要压缩文件，具体就是将文件中的多字母单词用一个字母来代替、去空格回车等多余字符  </p>
<ol start="4">
<li>弹性盒子元素：flex box</li>
</ol>
<p>——————————— 以上为html 4.0.1版本 —————————————</p>
<p>html5：打倒android、ios， 哈哈哈哈</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript②</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A1/</url>
    <content><![CDATA[<p>JavaScript(ECMAScript)、DOM、BOM统称为JavaScript三大部分</p>
<h2 id="JavaScript引入"><a href="#JavaScript引入" class="headerlink" title="JavaScript引入"></a>JavaScript引入</h2><ol>
<li><p>页面级js<br><img src="/images/20062601/js2/Image.png" alt><br>script标签也有用做存储数据的作用，设置type=”text/tpl”后，script标签内就只能装代码但不能运行。但是可以将数据取出</p>
</li>
<li><p>引入外部js文件<br>在<code>.html</code>文件同级文件夹下，新建一个后缀名为<code>.js</code>的文件，在<code>.html</code>标签内通过<code>link</code>标签引入<code>.js</code>文件</p>
<blockquote>
<p>关于后缀名：JavaScript外部文件的后缀名实际上应该是javascript，但是由于当时使用的是奔腾四处理器系统windows98，奠定了程序的基础，windows98要求文件后缀名最多三位，由于历史遗留问题至今还在，所以html文件的后缀写成<code>.htm</code>也是可以运行的，所以javascript就被简写成<code>.js</code></p>
</blockquote>
</li>
</ol>
<p><img src="/images/20062601/js2/Image%5B1%5D.png" alt></p>
<p>为符合web标准，结构、样式、行为相分离， 通常会采用外部引入的方式</p>
<blockquote>
<p>问：是否可以引入js文件，还在script标签内写代码？<br>不可以，只有外部文件的内容生效</p>
</blockquote>
<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><p>编程语言的特点：有变量、有函数、有数据结构并且可以进行基本运算</p>
<p>JavaScript是编程语言</p>
<p>HTML、CSS不是编程语言，只是计算机语言的一个小门类</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>1.储存数据<br>2.以便于后续使用</p>
<blockquote>
<p>var：variable，用来声明变量</p>
</blockquote>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>

<p>这个过程可以比作：向系统申请了一个变量的空间，这个空间叫做<code>a</code>，这个过程就叫变量声明(variable declaration)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>声明完成后，再向<code>a</code>赋值100，注：这里的”=”不是等号，而是赋值符号</p>
<p>上述例子，可以简写：（这里包含两个过程）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<br>&emsp;① 声明多个变量时，需要使用单一var模式，即每个变量都换行展示且用逗号”,”分隔<br><img src="/images/20062601/js2/Image%5B2%5D.png" alt></p>
<p>&emsp;② 同一个变量名可以重复声明不会报错，但最新声明的变量会覆盖初始声明变量的值，所以不要重复声明<br>&emsp;&emsp;命名规则：<br><img src="/images/20062601/js2/Image%5B3%5D.png" alt><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;关键字：在系统中有特殊语法含义的字。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;保留字：在未来可能会有特殊含义的字。<br><img src="/images/20062601/js2/Image%5B4%5D.png" alt><br><img src="/images/20062601/js2/Image%5B5%5D.png" alt></p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>赋值和运算的关系：先将等号右边的式子运算完再赋值给等号左边的值，运算大于赋值的优先级</p>
<p>计算机的运算与数学运算相似，数学运算实质是仿生计算机运算的</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line">c = a + b; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>JavaScript是动态语言(分为动态语言和静态语言)，动态语言基本上都是解释性语言，解释性语言基本上都是脚本语言</p>
<p>解释性语言的特点：声明变量的关键字只有一个，不需要像其他语言一样需要int、float、char、string等关键字。原因是解释性语言在执行时是解释一行执行一行，到当前行时现解释现执行，不用通篇编译</p>
<p>在声明所有类型的变量时都可以用关键字var来声明，由值来决定数据类型，不需要关注数据类型，并且不同类型的变量可以相互转化，表明解释性语言更加灵活</p>
<ol>
<li>原始值(栈数据 stack栈)：Number、Boolean、String、Undefined、Null<br> <strong>数字类型</strong>：浮点型(非整型 intiger)<br> <strong>布尔类型</strong>：表示逻辑的词，true和false<br> <strong>字符串类型</strong>：双引号””或单引号’’包含字符<br> <strong>Undefined类型</strong>：未定义的，表示一个变量经过声明没赋值<code>var a;</code><br> <strong>Null类型</strong>：空值，表示占位。程序中的方法不能直接被删除，就可以用一个空值null来覆盖，以便于后续的利用</li>
</ol>
<blockquote>
<p>不可改变的原始值<br>&emsp;&emsp;电脑(计算机)是因为数字0而被发明的，数字是由阿拉伯人发明的，所以叫做阿拉伯数字。但其实最早是印度人发明的数字，在九世纪的时候，阿拉伯人把印度人给灭了(经历了好几轮灭族)，发现了印度人发明的数字，发现用法很简单，后来阿拉伯人给这个数字加上了加减乘除的运算，从欧洲到亚洲流传开来后就叫做阿拉伯数字<br>&emsp;&emsp;有了数字0后，计算机就诞生了，计算机的语言用01来表示，八位的01010101组成一个字<br>&emsp;&emsp;一个叫做布尔的人发明了逻辑，两个对立逻辑：对的ture和错的false，将逻辑进行了引申，将ture当成了1，把false当成了0，真和假变成了0和1，然后计算机形成了基础的语言</p>
</blockquote>
<ol start="2">
<li>引用值(堆数据 heap堆)：Array、Object、Function、Data、RegExp<br> <strong>数组类型</strong>：[1, 2, 3, false, “abc”]<br> <strong>对象类型</strong>：{name: ‘zc’, age: 18}<br> <strong>函数类型</strong>：function(){}<br> <strong>数据类型</strong>：Data<br> <strong>正则</strong>：/^\d+$/g</li>
</ol>
<blockquote>
<p>原始值和引用值的赋值方法(形式)不同，一个变量的类型由值决定<br>&emsp;&emsp;原始值：将一个值放到另一个值里去，改了第一个值，第二个值不变。<br>&emsp;&emsp;引用值：将一个值放到另一个值里去，改了第一个值，第二个值也跟着变了。</p>
</blockquote>
<p>储存位置不同：在计算机中，原始值储存在栈stack中，引用值储存在堆heap中</p>
<p><strong>原始值</strong>：在声明变量 <code>a</code> 时(var a;)，是向系统申请了一个叫 <code>a</code> 的空间(也可以理解为房间)，在栈stack的 <code>a</code> 空间内存入数值10(var a = 10)；再声明变量 <code>b</code> ( var b;)，又向系统申请一个叫做 <code>b</code> 的空间，将 <code>a</code> 赋值给 <code>b</code> (var b = a;)，这个赋值过程，实际上是将栈stack中 <code>a</code> 的值10先取出，复制(copy)出来再赋值给 <code>b</code> ，所以当给 <code>a</code> 重新赋值20时， <code>b</code> 的值不变依然是10<br><img src="/images/20062601/js2/Image%5B6%5D.png" alt><br>&emsp;&emsp;上述情况，关于 <code>a</code> 的重新赋值的问题，如下图解释：<br>&emsp;&emsp;并非是直接在num空间内直接修改数据，而是在栈内重新存入一个新的值，并将新空间叫做<br>num，而之前的数据依然存在，只是空间的名字被抹去，无法再直接使用，直到空间数据满了，被二次利用时，才会用更新的数据来替代<br><img src="/images/20062601/js2/Image%5B7%5D.png" alt></p>
<p><strong>引用值</strong>：在声明数组变量 <code>arr</code> 时(var arr;)，是向系统申请了一个叫做 <code>arr</code> 的空间，在堆(heap)中存入数组 <code>[1, 2]</code> (var arr = [1, 2];)，并将堆中存储数值的位置存入栈(stack) <code>arr</code><br>中；再声明数组变量 <code>arr1</code> (var arr1;)，又向系统申请了一个叫做 <code>arr1</code> 的空间，并将 <code>arr</code> 赋值给 <code>arr1</code> (var arr1 = arr;)，这个赋值过程，实际上是将 <code>arr</code> 储存在堆中的值的地址取出，复制(copy)出来再赋值给 <code>arr1</code> ，也就是 <code>arr</code> 和 <code>arr1</code> 共用同一个地址，都指向同一个堆的值。向 <code>arr</code> 添加一个新值3(arr.push(3);)，此时修改的是原数组，所以 <code>arr1</code> 的值也跟着变为[1, 2, 3]<br><img src="/images/20062601/js2/Image%5B8%5D.png" alt></p>
<p>&emsp;&emsp;关于引用值，还有另外一种情况：<br>&emsp;&emsp;当给 <code>arr</code> 重新赋值[1, 3]时，实际上是向系统申请了一个新的空间，并将[1, 3]存入新的空间内，再将 <code>arr</code> 的值变为新空间的地址 <code>heap1002</code> ，所以 <code>arr1</code> 的值不变。<br><img src="/images/20062601/js2/Image%5B9%5D.png" alt></p>
<blockquote>
<p>电子设备(相机、内存卡等)的内存数据被删除时，实际上只是删除了数据与名称间的关系，无法直接再获取数据，但是之前得数据还存在。即使删除了数据，但是内存格中依然存在数据，用专门的设备就能将原来的名字、标号、指针将数据还原回来。所以删除数据，实际上就是将名字删除了，但是内容还在。如果想彻底的删除掉内存中的数据，可以将所有内容删除后，重新再将内存填满，这叫做二次覆盖</p>
</blockquote>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ol>
<li><p>语句后面需要用分号”;”结束(分隔)<br> 不需要加分号的语句：函数、for循环、if判断</p>
</li>
<li><p>js语法错误会引发后续代码终止，但不会影响其他js代码块<br> 错误：<br>&emsp;&emsp;①低级错误(语法解析错误)：浏览器在渲染之前，会通篇查看页面是否有语法错误，若有错则页面报错，且不会执行渲染操作(一行都不执行)<br><img src="/images/20062601/js2/Image%5B10%5D.png" alt><br>&emsp;&emsp;②逻辑错误(标准错误，情有可原)：当浏览器渲染至错误行时，报错后的代码不会执行<br><img src="/images/20062601/js2/Image%5B11%5D.png" alt><br>&emsp;&emsp;要点：无论哪种错误，一个代码块的错误都不会影响到另一个代码块的执行<br>&emsp;&emsp;低级错误：<br><img src="/images/20062601/js2/Image%5B12%5D.png" alt><img src="/images/20062601/js2/Image%5B13%5D.png" alt><br>&emsp;&emsp;逻辑错误：<br><img src="/images/20062601/js2/Image%5B14%5D.png" alt><img src="/images/20062601/js2/Image%5B15%5D.png" alt></p>
</li>
<li><p>书写格式规范，”= + / -“等符号的两侧都需要加空格</p>
</li>
</ol>
<h4 id="js运算符-–-运算操作符"><a href="#js运算符-–-运算操作符" class="headerlink" title="js运算符 – 运算操作符"></a>js运算符 – 运算操作符</h4><ol>
<li><p>关于 “+”<br>① 数学运算、字符串连接<br>② 任何数据类型加字符串都等于字符串</p>
<p> <strong>赋值顺序：自右向左，可以连续赋值</strong><br> <strong>运算顺序：自左向右，先乘除后加减</strong><br> 先计算后赋值</p>
</li>
<li><p>“-“、”*”、”/“、”% 取余”、”=”、”()”<br>注意点：<br>&emsp;&emsp;0不能除以0，但是0/0也不会报错，会返回NaN(Not A Number 非数，是一种数据类型)<br>&emsp;&emsp;1/0 ==&gt; Infinity(正无穷)<br>&emsp;&emsp;-1/0 ==&gt; -Infinity(负无穷)</p>
</li>
<li><p>优先级”=”最弱，”()”最高</p>
</li>
<li><p>“++”、”–”、”+=”、”-=”、”/=”、”*=”、”%=”<br>&emsp;&emsp;”++ / –”：自身加 / 减1，再赋值给自身<br><img src="/images/20062601/js2/Image%5B16%5D.png" alt><br><img src="/images/20062601/js2/Image%5B17%5D.png" alt></p>
</li>
</ol>
<h4 id="js运算符-–-比较运算符"><a href="#js运算符-–-比较运算符" class="headerlink" title="js运算符 – 比较运算符"></a>js运算符 – 比较运算符</h4><p>“&gt;”、”&lt;”、”==”、”&gt;=”、”&lt;=”、”!=”</p>
<p>比较运算符的结果是Boolean<br>字符串，比较的是阿斯克码(asc)的顺序，每个字符对应着阿斯克码0-127，<br>Infinity == Infinity // true<br><strong>NaN不等于任何值，包括自己</strong></p>
<h4 id="逻辑运算符-–-“-amp-amp-”、”-”、”！”"><a href="#逻辑运算符-–-“-amp-amp-”、”-”、”！”" class="headerlink" title="逻辑运算符 – “&amp;&amp;”、”||”、”！”"></a>逻辑运算符 – “&amp;&amp;”、”||”、”！”</h4><p><em>undefined、null、NaN、””、0、false</em> ==&gt; false（转换为Boolean）</p>
<p>&emsp;&emsp;”&amp;&amp;”：先看运算符前第一个表达式转换为Boolean值是否为真，如果结果为真再看下一个表达式转化为Boolean值的结果，如果当前表达式为false，则直接返回当前表示；如果前面的表达式都为真，则返回最后一个表达式的值。遇到false就返回<br>&emsp;&emsp;&emsp;&emsp;&emsp;”全真才为真，有一个假就是假” ==&gt; 实际是将返回结果转化为布尔值<br>&emsp;&emsp;&emsp;&emsp;&emsp;总结：从第一个表达式开始，为真就依次向后找，直至遇到false的表达式后返回结果，或者直到最后一个表示时，直接返回表达式的结果</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;短路语句：有中断的作用， 如果前一个表达式是真，才能执行下一个。if的简写形式<br>&emsp;&emsp;&emsp;&emsp;&emsp;用法：在获取数据data后，需要判断data内的数据是否可用，通过”&amp;&amp;”运算符执行一个语句，判断data是否可用<br>例如：<img src="/images/20062601/js2/Image%5B18%5D.png" alt></p>
<p>&emsp;&emsp;单独”&amp;”，无意义。可作为”与运算”：二进制，相同为1，不同为0<br>&emsp;&emsp;1 &amp; 3; // 1</p>
<p>&emsp;&emsp;”||”：遇到true(真)就返回，遇到false就继续向后找，直到找到为true的结果。如果前边的表达式都为false，则直接返回最后一个的值<br>&emsp;&emsp;&emsp;&emsp;&emsp;”全假才为假，有一个真就是真” ==&gt; 指返回结果的Boolean</p>
<p>&emsp;&emsp;”&amp;&amp;”与”||”互为对立。<br>&emsp;&emsp;”!”：将表达式转化为Boolean后再取反<br>&emsp;&emsp;”!!”：取反再取反变Boolean值</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ol>
<li>if、eles if<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件成立(true)时，执行语句</span></span><br><span class="line"><span class="keyword">if</span>( 条件 ) &#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/20062601/js2/Image%5B19%5D.png" alt></p>
<p>&emsp;&emsp;当多个条件是互斥(条件之间没有重叠部分)时，可以使用else if</p>
<p>&emsp;&emsp;if 与 “&amp;&amp;”的转换<br><img src="/images/20062601/js2/Image%5B20%5D.png" alt></p>
<ol start="2">
<li>for循环<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明变量; 循环条件; 变量增量) &#123;</span><br><span class="line">    <span class="comment">// 执行循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>&emsp;&emsp;在循环时执行顺序：<br><img src="/images/20062601/js2/Image%5B21%5D.png" alt><br>&emsp;&emsp;重复执行(2)(3)步骤，直到条件(2)不成立时，结束循环<br>&emsp;&emsp;示例代码：<br><img src="/images/20062601/js2/Image%5B22%5D.png" alt><br>&emsp;&emsp;得到结果：打印十个a</p>
<p>&emsp;&emsp;<strong>for循环其他形式的写法</strong>：<br>&emsp;&emsp;&emsp;&emsp;① 在循环外声明变量，在循环体内进行变量增加<br><img src="/images/20062601/js2/Image%5B23%5D.png" alt><br>&emsp;&emsp;&emsp;&emsp;② for循环内什么条件都不写<br><img src="/images/20062601/js2/Image%5B24%5D.png" alt><br>&emsp;&emsp;&emsp;&emsp;③ for循环内只写一句<br><img src="/images/20062601/js2/Image%5B25%5D.png" alt></p>
<ol start="3">
<li>while循环<br>注意：当条件为1(true)时，就会never-ending loop（死循环）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 初始变量值;</span><br><span class="line"><span class="keyword">while</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/20062601/js2/Image%5B26%5D.png" alt></p>
<ol start="4">
<li>do…while循环<br>无论条件是否成立，都先执行循环体(几乎不用)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 声明变量;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">![](<span class="regexp">/images/</span><span class="number">20062601</span>/js2/Image[<span class="number">27</span>].png)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<ol>
<li>n可输入：var n<br>= parseInt(window.prompt(‘input’));(弹出式输入框)\</li>
<li>阶乘：<br> 5! = 5 * 4 * 3 * 2 * 1;\</li>
<li>斐波那契数列：当前位等于前两位的和，求第四位的值需要知道二三位的数值\</li>
<li>由于js的数字类型是浮点数，在1/3时，得到的是小数。所以也会有整除却无法得到整数的情况\</li>
<li>质数：又叫素数，只能被1和它本身整除的数(更准确的解释是：从1一直除到它本身，能被两个数整除。所以1不是素数，也不是合数。从2开始)</li>
</ol>
</blockquote>
<h4 id="条件语句补充"><a href="#条件语句补充" class="headerlink" title="条件语句补充"></a>条件语句补充</h4><ol>
<li><p><strong>switch case</strong> 条件判断语句</p>
<p> <em>条件可以是任何类型的数据</em></p>
<p> 从上之下，当遇到case值与条件值相等时，就执行当前case内的语句，并且会再向下继续执行，直到执行完最后一个，在每个case的执行语句后加上break就可以终止判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        <span class="comment">// 条件为 1 时，执行语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 条件为 2 时，执行语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//  以上条件都不满足时，执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>break</strong> 终止循环，并且必须写在循环内</p>
</li>
<li><p><strong>continue</strong> 中止本次循环，进行下一次循环</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript③</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A2/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="初始引用值"><a href="#初始引用值" class="headerlink" title="初始引用值"></a>初始引用值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>相当于一个仓库，可以用来存取数据<br>可以通过下标来取值和写入(修改)，和变量操作手法是一样的</p>
<ol>
<li><p>属性：length 可以通过length属性来获取数组长度<br><img src="/images/20062601/js3/Image.png" alt></p>
</li>
<li><p>遍历数组：将数组的每一位都取出<br><img src="/images/20062601/js3/Image%5B1%5D.png" alt></p>
</li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>和数组一样，也是用来存储数据的作用</p>
<p>数组存储的值没有名字，只能通过下标称呼，但是对象的数据有名字，key: value(属性名: 属性值)叫做键值对。属性名加不加双引号””都可以，属性值可以是任意数据类型的值。<br>属性名的作用：主要是为了方便找到属性值。</p>
<p>在一个对象内，可以写多个属性，并且属性和属性之间用逗号”,”来分隔，css也是”属性值: 属性值”的格式，但是是用分号”;”来分隔的。<br><img src="/images/20062601/js3/Image%5B2%5D.png" alt></p>
<p>修改对象的属性值：<br><img src="/images/20062601/js3/Image%5B3%5D.png" alt></p>
<h3 id="编程形式的区别"><a href="#编程形式的区别" class="headerlink" title="编程形式的区别"></a>编程形式的区别</h3><p>编程分类：</p>
<ol>
<li>解释性语言、 编译型语言</li>
<li>面向过程、面向对象</li>
<li>弱数类型、强数类型</li>
<li>脚本语言、非脚本语言</li>
</ol>
<blockquote>
<p>&emsp;面向过程：属于机械化思维，按照逻辑思维将一件事按照先后顺序分解后再执行，简单的说就是按照第一步做什么、第两步做什么的方式进行代码编写<br>&emsp;面向对象：相比面向过程，更加符合人的思维逻辑，简单的说就是一个功能里的每个对象只包含属于自己的属性，执行属于自己的功能。例如：java、c++、js<br>&emsp;编程的发展：最开始是面向过程的，后来偏向面向对象，目前处于既面向对象又面向过程的时期</p>
</blockquote>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>操作符：用于区分每个数据的类型</p>
<p>typeof()方法返回值的类型都是字符串string类型<br>返回值：number、string、boolean、undefined、object(数组 对象 null等引用值)、function</p>
<blockquote>
<p>null最开始是用来代替空对象的(占位作用)，系统就认为null是对象类型的数据，所以一直到现在都被当做对象类型来使用。</p>
</blockquote>
<p>两种用法：</p>
<ol>
<li>typeof + 括号 typeof( ‘a’ )</li>
<li>typeof + 空格 + 变量 typeof ‘a’</li>
</ol>
<p>typeof()括号内是未定义变量时，返回”undefined”</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换属于JavaScript的独有特性，分为显示类型转换和隐式类型转换</p>
<h4 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h4><ol>
<li><p><strong>Number</strong>( 变量 ) 转换为数字类型，并将转换后的值返回<br> 如果是带有字母的数字字符串，如”123abc”，也会返回NaN<br> 如果带有符号”-“时，会返回负数 例如：”-123” –&gt; -123<br> 如果变量全都是字符串，如undefined或英文字符(包括”true”和”false”)等，会返回NaN</p>
<blockquote>
<p>注意：null 会返回0，因为null 是空值；false 也返回 0，true 返回1<br> <img src="/images/20062601/js3/Image%5B4%5D.png" alt><br> NaN通过Number()转换后，结果依然是NaN，类型是”number”</p>
</blockquote>
</li>
<li><p><strong>parseInt</strong>( 变量，radix )<br> parse int，转换为整型的数。凡是带有小数点的数都能去掉(小数点)<br> radix，基底(进制) 设置这个参数，会将变量按照设置的进制值进行转换，也就是：<strong>以目标进制为基底，转换为十进制</strong> 取值范围：2-36，0忽略不报错</p>
<p> 只关注变量是否带有数字，如果并且带有小数时，直接取整(去掉小数点后的值)并返回<br> 所以像undefined、null、true、false等值，直接返回NaN</p>
<p> 和Number的侧重点不同，Number是想要将所有字符都转变成数字，parseInt是想将字符转化成整型，所有只有带有数字的字符才能转化，否则都是NaN</p>
<blockquote>
<p>进制：假如从0-9，再向上查应该是10，这个是十进制，满十进一；但是也有不是10而是a的情况，叫做十六进制，满十变成a(10)，b(11)，c，d，e，f，f + 1 ==&gt; 10(1是十六进制的1，也就是说一个1代表16；20就代表两个16)<br> &emsp;&emsp;二进制里只包括0、1两个数<br> &emsp;&emsp;没有一进制，一进制永远都没有尽头，因为0代表空，无法表示任何大于0的数，所以一进制是不存在的<br> <img src="/images/20062601/js3/Image%5B5%5D.png" alt></p>
</blockquote>
<p> parseInt是从数字位开始向后查看至非数字位(包括小数点)截止，并将数字返回<br> <img src="/images/20062601/js3/Image%5B6%5D.png" alt></p>
</li>
<li><p><strong>parseFloat</strong>( 变量 )：将字符转换为浮点类型的数(正常的数)，没有基底参数<br> parseFloat是从数字位开始向后查看除了小数点以外的至非数字位截止，并将数字返回。</p>
<p> 变量.toString( radix )：<br> &emsp;将所有的字符都变为字符串 括号内无参数<br> &emsp;radix：以十进制为基底转化为目标进制</p>
<p> 有两个值不能用这个方法：undefined、null（会报错）<br> <img src="/images/20062601/js3/Image%5B7%5D.png" alt><br> <img src="/images/20062601/js3/Image%5B8%5D.png" alt></p>
<blockquote>
<p>二进制转换为十六进制：先将二进制转换为十进制再转换为十六进制<br> <img src="/images/20062601/js3/Image%5B9%5D.png" alt></p>
</blockquote>
</li>
<li><p><strong>String</strong>( 变量 ):将所有的字符都变为字符串</p>
</li>
<li><p><strong>Boolean</strong>( 变量 )：将所有的字符都变为布尔类型</p>
</li>
</ol>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>与显示类型转换相比不明显，调用隐式类型方法时，是内部转换<br>特点：隐式类型转换时，内部调用的是显示的方法</p>
<ol>
<li><p><strong>isNaN</strong>()：判断括号内的值是不是NaN(不是一个数字)，再返回结果<br> 隐式调用了Number()<br> 先将括号内的值通过Number()方法转换，转换的结果和NaN比对，是NaN返回true，否则返回false<br> <img src="/images/20062601/js3/Image%5B10%5D.png" alt></p>
</li>
<li><p><strong>++/– 和 +/-(一元正负运算)</strong>：<br> ++ / – 是将运算符左侧或右侧的字符先通过Number()方法转化为数字类型，在进行运算。<br> 当字符是数字类型的字符串时，例如”123”直接转为数字进行 ++/– 运算<br> 当字符是NaN时，Number()返回的结果也是NaN，NaN进行 ++/ – 运算时，还是返回NaN<br> 当字符是英文字符时，返回NaN。因为Number()返回的就是NaN</p>
<p> NaN是”number”类型的数据，可以进行运算，得到的结果也是NaN<br> <img src="/images/20062601/js3/Image%5B11%5D.png" alt><br> <img src="/images/20062601/js3/Image%5B12%5D.png" alt></p>
<p> <strong>经过隐式转换之后，即使结果不是数字，但是字符的类型也变成了数字类型(通过typeof()方法来确定)</strong></p>
<ul>
<li><p><strong>+ / -(正/负)</strong>：将字符变为数字类型<br>  <img src="/images/20062601/js3/Image%5B13%5D.png" alt><br>  +：当加号两侧有一个数据类型是字符串string时，会调用<strong>Sring()</strong>方法，将两个都变为字符串类型的数据<br>  <img src="/images/20062601/js3/Image%5B14%5D.png" alt></p>
</li>
<li><p><strong>- / * / /(减/乘/除号)</strong>：都是先调用<strong>Number()</strong>方法，再进行计算<br>  <img src="/images/20062601/js3/Image%5B15%5D.png" alt></p>
</li>
</ul>
</li>
<li><p><strong>&amp;&amp; || !</strong>(与或非)：先看第一个表达式的结果转化为布尔值是true还是false，在看第二个，也就是通过调用<strong>Boolean()</strong>方法隐式转化为布尔值boolean</p>
</li>
<li><p><strong>&gt;、&lt;、&lt;=、&lt;=</strong><br> 比较符两侧有一个是数字时，都转化为数字进行比较。<br> 都是字符串时，按照阿斯克码来进行比较<br> <img src="/images/20062601/js3/Image%5B16%5D.png" alt></p>
</li>
<li><p><strong>==、!=</strong><br> 通过Boolean()方法隐式类型转化后再比较<br> <img src="/images/20062601/js3/Image%5B17%5D.png" alt></p>
<p> 在多个表达式比较时，顺序是从左到右，两两相比较。<br> <strong>Undefined、Null 既不大于0，也不小于0，更不等于0。所以undefined == null</strong><br> <strong>NaN(非数)不等于自己，所以也不等于任何值</strong></p>
</li>
</ol>
<h4 id="不发生类型转换"><a href="#不发生类型转换" class="headerlink" title="不发生类型转换"></a>不发生类型转换</h4><ol>
<li><strong>===、!==(绝对等于、绝对不等于)</strong>：符号两边的表达式不会发生类型转换，当两侧数据类型完全相同时，返回true；不同时，返回false<br><img src="/images/20062601/js3/Image%5B18%5D.png" alt><br><img src="/images/20062601/js3/Image%5B19%5D.png" alt></li>
</ol>
<p>练习：<br><img src="/images/20062601/js3/Image%5B20%5D.png" alt><br><img src="/images/20062601/js3/Image%5B21%5D.png" alt></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在数学中，函数叫做一系列功能的集合(公式)</p>
<blockquote>
<p>什么是函数：<br>&emsp;一段代码中有大量重复的代码，叫做偶合(重复)，这也是低效代码<br>&emsp;编程要讲究一个原则，叫做高内聚、弱偶合。也就是把相同功能的代码抽取出来，(在CSS里时)放到一个黑匣子里，每次在用的时候直接调用黑匣子就可以了，不需要再自己写了。在js里，也有这样的”黑匣子”，它叫做函数<br>&emsp;<strong>函数就是另一种类型的变量，函数也是引用值，它在栈内存(stack)内存的地址，堆内存(heap)内存内容</strong></p>
</blockquote>
<h4 id="定义函数的方法"><a href="#定义函数的方法" class="headerlink" title="定义函数的方法"></a>定义函数的方法</h4><ol>
<li><p>函数声明<br> <code>function</code> 用于声明函数的关键字，后面的是函数名也叫作变量，这个变量存的是函数体</p>
<p> 函数的基本形式：function 函数名(变量)() { // 函数体 }<br> 函数名的定义规则：小驼峰（第一个单词的首字母小写后面的首字母都大写）</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键字 函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体              </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<p> 函数的基本应用：<br> 1.将需要的功能进行封装，减少代码的偶合性<br> 2.需要执行的时候才执行<br> 3.并且可以执行多次                    </p>
<p> 函数在控制台打印出来的结果是它的函数体。</p>
<blockquote>
<p>解释性语言(弱数据类语言)不能打印出指针地址，像C语言、C++、Java输入指针时，可以直接打印出指针的地址</p>
</blockquote>
<p> <img src="/images/20062601/js3/Image%5B22%5D.png" alt><br> 输出结果：函数体<br> <img src="/images/20062601/js3/Image%5B23%5D.png" alt></p>
</li>
<li><p>函数表达式：<br> 命名函数表达式：<br> <img src="/images/20062601/js3/Image%5B24%5D.png" alt><br> 上面函数打印”test”时可以打印出函数体，但是打印表达式的名字abc会报错not defined</p>
<p> 声明一个变量来接收一个函数，接收的这个函数的格式叫做表达式，表达式就会使函数变成一个匿名函数，所以会忽略函数名</p>
<p> 因为上面的原因，所以衍生出另一种表达式：<strong>匿名函数表达式</strong><br> <img src="/images/20062601/js3/Image%5B25%5D.png" alt></p>
<p> <strong>匿名函数表达式被简称为函数表达式</strong>，更加常用</p>
<p> 函数声明、函数表达式、匿名表达式之间只有一个区别就是获取函数名字的不同，函数表达式获取的函数名(test.name)是表达式的名字(abc)，而函数声明和匿名表达式 获取的都是函数唯一的名字(test)</p>
<blockquote>
<p>浏览器的控制台Console相当于JS最后执行的代码块。Console执行的内容，一定是文件内的代码都执行完成后再执行的</p>
</blockquote>
</li>
</ol>
<h4 id="组成形式"><a href="#组成形式" class="headerlink" title="组成形式"></a>组成形式</h4><ol>
<li><p>函数名称</p>
</li>
<li><p>参数：在函数的括号内接受的值就是参数，相当于隐式的在函数体内声明了变量，在调用函数的时候传参，就会给参数赋值</p>
<blockquote>
<p>在C语言、C++、Java内写参数时，需要带上变量的数据类型，但是js内不需要</p>
</blockquote>
<p> 函数带有参数后，就不光有聚合代码的作用，还具有了抽象规则，将函数应用到实际的功能上</p>
<p> 参数共分为两种：<br> &emsp;a. 形参：形式参数，函数体定义的参数，起到占位的作用<br> &emsp;b. 实参：实际参数，在调用函数时，传的参数<br> <img src="/images/20062601/js3/Image%5B26%5D.png" alt></p>
<p> JavaScript函数的参数不限制位数，形参和实参的个数不需要一一对应，像Java等语言想要传多个参数时，需要用…来代替<br> <img src="/images/20062601/js3/Image%5B27%5D.png" alt></p>
<p> 一个函数只写一个形参，传递多个实参是可以的，不会报错。原因是：在每个函数内都有一个隐式的值，它是类数组arguments，里边放的是一个装着所有实参的数组，arguments叫做实参列表<br> <img src="/images/20062601/js3/Image%5B28%5D.png" alt><br> arguments.length 获取所有实参的长度<br> 函数名test3.length 获取所有形参的长度<br> 通过遍历arguments数组即可拿出所有传递到函数的实参。</p>
<p> <strong>形参与实参关系：</strong><br> 当形参与实参数量相同时，函数内的形参和arguments对应位数上的值，一个变了另一个也跟着变，有这样的绑定规则，但他俩不是同一个变量。系统内部有一条绳叫映射规则，意思就是一个变了另一个也得变，但是就是不同的变量。<br> 当形参的数量多于实参时，首先实参列表在初始化时有几个变量就是几个，即使再给实参argument[1]对应的形参 b 赋值，也不会再增加，这个时候是不存在映射关系的<br> 总结：<strong>只有形参和实参数量相等时，才存在映射关系</strong><br> <img src="/images/20062601/js3/Image%5B29%5D.png" alt></p>
<p> 比较关键的点：结束条件<code>return</code> + <code>返回值;</code></p>
<ol>
<li>只有在函数最后加上return时，函数才会结束。当函数内部没有写return时，程序内部会隐式的加上return，<strong>在逻辑最后终止函数</strong></li>
<li>return 的本意是<strong>将一个值返回到函数外，并且终止函数</strong><br>例如：在调用Number(“123”)方法时，会返回一个数字类型的值;</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>递归</strong>：找规律，找出口(结束循环) 特别符合人的思维过程(找到最直观的规律)<br>递归就是return公式<br><em>递归是最慢的计算，但是最大的有点就是代码简洁</em><br>等待结果，需要等一层一层的结果返回后才能执行完，先执行的但是最后被执行完。只有最后一个的值算好了之后，才能一层一层的往回返。</p>
</blockquote>
<p><img src="/images/20062601/js3/Image%5B30%5D.png" alt><br><img src="/images/20062601/js3/Image%5B31%5D.png" alt></p>
<h3 id="作用域初探"><a href="#作用域初探" class="headerlink" title="作用域初探"></a>作用域初探</h3><ol>
<li><p>作用域定义：变量（变量作用于又称上下文）和函数生效（能被访问）的区域</p>
</li>
<li><p>全局、 局部变量<br> 在script标签内或js文件的函数外部定义的变量叫做全局变量<br> 在函数内定义的变量叫做局部变量</p>
</li>
<li><p>作用域的访问顺序<br> 函数内可以访问全局变量，也就是函数外的变量；函数外不能访问函数内的值。<br> <img src="/images/20062601/js3/Image%5B32%5D.png" alt></p>
<p> 总结：函数内可以访问函数外的变量，反之不可；函数之间也不可访问内部变量<br> <img src="/images/20062601/js3/Image%5B33%5D.png" alt></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑤</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A4/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="作用域精解"><a href="#作用域精解" class="headerlink" title="作用域精解"></a>作用域精解</h3><p>大致的概念就是将函数所产生的一种空间叫做作用域</p>
<p>作用域是因为函数的产生而产生的独特的空间，作用域属于函数，一个函数产生一样的作用域，是一种互相绑定的关系。</p>
<blockquote>
<p>对象有属性，一切为对象的东西就都可以有属性，那么这个东西是对象的话就一定有属性。(亚里士多德 – 三段论，属于古希腊哲学)</p>
</blockquote>
<p><img src="/images/20062601/js5/Image.png" alt></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>函数是一种特殊对象，它也有属性，叫做函数类对象。</p>
<p>函数包含两种属性：可访问属性、不可访问属性</p>
<ol>
<li>可访问属性；<br> a. 在函数自带的属性：例如函数a.name<br> b. prototype</li>
<li>不可访问属性：<br> 也叫作隐式属性，仅供javascript引擎存取，我们不可以访问。其中就包括属性[[scope]]</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>[[scope]]：叫做域，这个属性内存储的就是由于函数产生而产生的作用域。作用域中存储了<strong>执行期上下文的集合</strong>(就是作用域链)。</p>
<p>执行期上下文：当函数执行时(或者说执行前一刻)，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境(由于环境产生的变量/函数提升)，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文(AO)，当函数执行完毕，它所产生的执行上下文被销毁。</p>
<p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式连接，我们把这种链式连接叫做作用域链。</p>
<p>查找变量：在哪个函数内查找变量，就从哪个函数的作用域链的顶端依次向下查找。<br><img src="/images/20062601/js5/Image%5B1%5D.png" alt></p>
<h4 id="理解【查找变量】的过程"><a href="#理解【查找变量】的过程" class="headerlink" title="理解【查找变量】的过程"></a>理解【查找变量】的过程</h4><p>&emsp;&emsp;<span style="color: #797979;font-size: 14px">a函数在刚被创建时，就具有自己的属性和方法，例如a.name。同理，也有属性a.[[scope]]。a.[[scope]]内存了一个作用域链(scope chain)，作用域链内装的是执行期上下文集合。但现在还不是”链”的状态，因为目前只存了一个数据，那就是第0位的Global Object(GO)。</span></p>
<ol>
<li><p>第一步：a函数刚刚被定义的时候，[[scope]]内只存了一位叫做GO，GO内存了this、window、document、a函数、glob变量。这个时候只有一位，还没有形成”链结构”。<br><img src="/images/20062601/js5/Image%5B2%5D.png" alt></p>
</li>
<li><p>第二步：这时函数a被定义完，接下来是函数a执行，一个函数执行时要产生执行期上下文(属于当前函数自己的AO)，产生的AO存在作用域链的顶端。</p>
<blockquote>
<p>引申问题：为什么在一个函数内访问变量值的时候，要先找自己的AO再向上找?</p>
</blockquote>
<blockquote>
<p>猜想：先找自己的AO再找向上找，一定是因为他们之间是有联系的，这种联系就叫做作用域链。</p>
</blockquote>
<p> a在执行的时候，[[scope]]内存的是作用域链scope chain，一共有两位数据，第0位是a函数自己新建的AO，第1位就是GO。</p>
<p> 这时如果想在a函数内访问一个变量的话，系统要去上a的[[scope]]中找这个变量，因为a的[[scope]]中存的作用域链，有顶端有底端，先去顶端找找到后返回值，顶端没有再依次向下去找</p>
<blockquote>
<p>之前说的找一个变量去AO、GO里找，这只是一个笼统的说法，真正的是去作用域链里找，然后捋着作用域链从顶端(0位开始)找到底端</p>
</blockquote>
</li>
</ol>
<p><img src="/images/20062601/js5/Image%5B3%5D.png" alt></p>
<ol start="3">
<li><p>第三步：由于a函数的执行产生了一个过程，这个过程叫b函数的定义。所以b函数也会产生自己的[[scope]]属性，当函数b刚创建时，它处于的环境是a函数的AO。也就是说b函数的环境是a函数给予的，b函数在这个基础之上再增加自己的属性。<br><img src="/images/20062601/js5/Image%5B4%5D.png" alt></p>
</li>
<li><p>第四步：b函数在被定义后，就会被执行，生成自己的执行期上下文，放在作用域链的顶端。<br><img src="/images/20062601/js5/Image%5B5%5D.png" alt></p>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><p>函数b的作用域链中处于第1位的AO是函数b引用函数a的，还是就是只属于函数b的？<br>答：在函数b中给aa重新赋值，并在函数外打印aa的值，如果aa的值改变了，证明函数b中的处于第1位的AO就是函数a的。结果为0，证明是函数a的AO，指向的都是同一个地址。<br><img src="/images/20062601/js5/Image%5B6%5D.png" alt></p>
<blockquote>
<p>引申思考：AO是由于函数执行而产生的，如果不是引用外层函数的AO，那又是哪儿来的呢？再者，每个函数的末尾位都是全局的GO，由此可证是同一个。</p>
</blockquote>
</li>
<li><p>从函数a开始到函数b生成的这一些列过程，什么时候是终点呢？一个函数执行完了会销毁执行期上下文，那么会不会消失呢？怎么消失的呢？<br>答：a定义 –&gt; a执行 –&gt; b定义 –&gt; b执行，<br> ① 函数b在执行完成后会销毁自己的执行期上下文，并回归到被定义的状态，等待下次被执行。销毁的方式：去掉scope chain与函数b自己的AO之间的连接(图上的连接线)，这个连接也就是指向AO的地址。如果下一次被执行的话，会产生新的AO。<br> ② 函数b执行完并销毁AO后，函数a也完成了函数执行，并销毁了AO，被销毁的AO内包含着函数b，但是也会被一同销毁，在函数a再次被执行时，会创建一个新的AO。</p>
</li>
</ol>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">a函数被定义：a.[[scope]] --&gt; 0 : GO&#123;&#125;</span><br><span class="line">a函数被执行：a.[[scope]] --&gt; 0 : AO&#123;&#125; // 首位</span><br><span class="line">                            1 : GO&#123;&#125; // 末尾位</span><br><span class="line">b函数被执行：b.[[scope]] --&gt; 0 : AO&#123;&#125; // 首位</span><br><span class="line">                            1 : AO&#123;&#125; // a函数的AO</span><br><span class="line">                            2 : GO&#123;&#125; // 末尾位</span><br><span class="line">b函数执行完成被销毁：b.[[scope]] --&gt; 0 : 空</span><br><span class="line">                                   1 : AO&#123;&#125; // a函数的AO</span><br><span class="line">                                   2 : GO&#123;&#125; // 末尾位</span><br><span class="line">a函数执行完成被销毁：a.[[scope]] --&gt; 0 : 空</span><br><span class="line">                                   1 : GO&#123;&#125; // 末尾位</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>每一个函数都有自己的执行期上下文的集合，叫做作用域链。在函数内访问一个变量时，要遵循这个函数所产生的作用域链去访问。</strong></p>
<p><strong>外层函数的执行，才能导致内部函数的定义</strong></p>
<h3 id="闭包！！！"><a href="#闭包！！！" class="headerlink" title="闭包！！！"></a>闭包！！！</h3><p>定义：当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。<br><img src="/images/20062601/js5/Image%5B7%5D.png" alt></p>
<p>函数解析：在全局范围内定义了一个函数a、变量glob和变量demo。demo等于函数a执行，并将执行的结果赋值给demo。</p>
<h4 id="理解过程："><a href="#理解过程：" class="headerlink" title="理解过程："></a>理解过程：</h4><ol>
<li>第一步：在执行函数a的时候，函数b被定义并且声明了变量aaa，最后返回b。这时的函数b被定义，获取了函数a的作用域链，但是没有被执行，一直处于等待执行的状态。所以，b.[[scope]]==a.[[scope]]。</li>
</ol>
<p><img src="/images/20062601/js5/Image%5B8%5D.png" alt></p>
<ol start="2">
<li>第二步：当return b执行完成后，函数a即执行完成，需要销毁执行期上下文。a的AO内保存了b函数，正常情况下如果a的AO被销毁，那么b函数也会一同被销毁。但是，在销毁之前通过return b，将b函数保存出来并赋值给了变量demo。</li>
</ol>
<p><img src="/images/20062601/js5/Image%5B9%5D.png" alt></p>
<ol start="3">
<li>第三步：执行demo();，函数b在函数a的内部被创建在外部被执行，依然是先创建自己的AO，并将AO添加到作用域链上，这个作用域链是引用自函数a所创建的链。虽然之前函数a已经销毁了它的AO，但是并不影响函数b，b依然保存着a函数的作用域链的地址。当函数b执行的时候，顺着作用域链查找变量aaa，自己的AO内没有aaa，然后在函数a的AO里找到了变量aaa，所以变量的值打印出来是123。</li>
</ol>
<p>上述的这个过程就叫做闭包。</p>
<p><strong>但凡是内部的函数被保存到了外部，它一定生成闭包</strong>。例如上面的例子，函数b是内部函数，通过return的方式被保存到了外部，这种情况就一定会生成闭包。a函数内的b函数没有执行被保存到了外部，因为函数a和函数b都指向同一个AO。所以函数a不能完全的删除自己的AO，函数b依然保留了a的AO，依然可以访问。</p>
<p><strong>函数内的内容只有在函数执行时才能被读取到，只有当函数内的所有内容执行完成，才算执行完。</strong></p>
<p><strong>多层函数嵌套时，在外层函数内调用内层函数的话，等内层函数执行完成后外层函数才算执行完。</strong></p>
<h4 id="闭包的危害"><a href="#闭包的危害" class="headerlink" title="闭包的危害"></a>闭包的危害</h4><p>闭包会导致原有作用域链不释放，造成内存泄漏。</p>
<blockquote>
<p>内存泄漏实际上就是内存被占用。举例邓哥抓一捧沙子，握得越紧，沙子漏的越多，手里的沙子就越少。内存也是一样，占用的空间越多，能使用的空间就越少，就像内存泄漏了一样。orz(神理解)</p>
</blockquote>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ol>
<li><p>实现共有变量<br> 例如：函数累加器，不依赖于外部变量并且能反复执行的函数累加器<br> <img src="/images/20062601/js5/Image%5B10%5D.png" alt><br> 优点是：代码更加模块化</p>
</li>
<li><p>可以做缓存(存储结构)<br> 多个函数被保存在外部，每个函数所保存的test函数的AO是同一个。有一个修改了，另一个也跟着变。</p>
<p> 每个函数的作用域链都是父子关系，一个子级(eat)修改了父级(eater)的值，其他子级(push)再获取的就是修改后的结果</p>
<p> <img src="/images/20062601/js5/Image%5B11%5D.png" alt></p>
</li>
<li><p>可以实现封装，属性私有化</p>
</li>
<li><p>模块化开发，防止污染全局变量(三堂课之后会讲)</p>
</li>
</ol>
<p>只要将内部函数保存到外部并在外部执行，这样的过程就叫做闭包。或者理解为，”外部函数(test)”在执行完并销毁后，被保存到外部的”内部函数(a)”依然保留”外部函数(test)”的AO，并在”内部函数(a)”执行时获取到”外部函数(test)”的”变量abc”。</p>
<h4 id="闭包的其他形式"><a href="#闭包的其他形式" class="headerlink" title="闭包的其他形式"></a>闭包的其他形式</h4><p>定义一个全局变量demo，并用来接收函数a，就相当于将函数a保存在外部。<br><img src="/images/20062601/js5/Image%5B12%5D.png" alt></p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>此类函数没有声明，在一次执行过后即释放。适合做初始化工作。</p>
<h4 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h4><p>只被执行一次，处理完数据返回结果后，直接被销毁的函数，叫做初始化函数。</p>
<p>针对初始化功能的函数，在执行完成后就销毁，否则占用内存空间，这时候就用立即执行函数。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>执行完成后，就将这个函数立即释放。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol>
<li><p>( 匿名函数 + ( ) )     <strong>W3C建议使用</strong></p>
</li>
<li><p>( function () { } ) ( )</p>
</li>
<li><p>立即执行函数形式的引申：<br> <strong>只有表达式才能被 执行符号”()” 执行.</strong><br> <em>能被执行符号执行的表达式，这个函数的名字就会被忽略。</em></p>
<ul>
<li><p>不能执行的例子：<br><img src="/images/20062601/js5/Image%5B13%5D.png" alt><br><img src="/images/20062601/js5/Image%5B14%5D.png" alt><br>不能执行是因为上述例子是”函数声明”，不是”表达式”</p>
</li>
<li><p>函数表达式可以执行：<br>函数被执行之后就被释放了<br><img src="/images/20062601/js5/Image%5B15%5D.png" alt></p>
<blockquote>
<p>打印出来的结果是undefined的原因，等号后的叫做表达式，但是表达式也是立即执行函数，所以当函数被释放了之后，就剩下<code>var test3;</code>相当于声明变量但是未赋值</p>
</blockquote>
</li>
<li><p>写匿名函数的原因：<br>如下图给立即执行函数加上了函数名，在控制台打印函数名时，报了找不到的错，所以起不起名字都一样.<br><img src="/images/20062601/js5/Image%5B16%5D.png" alt><br><img src="/images/20062601/js5/Image%5B17%5D.png" alt></p>
</li>
<li><p>与普通函数的区别：<br>除了执行完立即被释放，别的都一样。可以传参，有返回值，有预编译.<br>返回的值通过定义一个变量来接收：<br><img src="/images/20062601/js5/Image%5B18%5D.png" alt></p>
</li>
</ul>
</li>
</ol>
<p>立即执行函数的机制不是语法定义的，是后来有人设计出来的。就像css中的属性float一样，一开始是用来做文字环绕的，浮动的效果是后来研究出来的。</p>
<h3 id="闭包的深入理解"><a href="#闭包的深入理解" class="headerlink" title="闭包的深入理解"></a>闭包的深入理解</h3><p>例题：<br><img src="/images/20062601/js5/Image%5B19%5D.png" alt></p>
<p>理解过程：<br>&emsp;&emsp;定义一个空数组arr，通过for循环向数组内添加数据，每条数据都是一个函数，并且将arr返回到外部。在外部分别执行数组内的函数体，执行时会打印出”i”的语句。最后得到的结果是10个数字10;</p>
<p>&emsp;&emsp;在执行for循环时，arr[i]被赋值的是一个函数，在这时候函数内的内容是不执行的，系统只将其识别为一个函数引用。在外部执行的时候，才会去找test的AO内 i 的值，此时 i 已经完成了循环变成了10。</p>
<p>&emsp;&emsp;数组arr内的值是十个不同、相互独立、但是内容一样的函数。</p>
<p>&emsp;&emsp;函数在定义时，不会去看内容，只有在执行的时候才会关注内容。</p>
<p>自我分析：<br>&emsp;&emsp;这个问题的迷惑点是在结果，按照猜想认为应该是1-9的数字，但是得到了10个数字10。首先不明白为什么是数字10而不是数字9，i 的值从0到9执行十次，按理说最后一个值应该是9。为什么是10呢？又为什么打印出来的值不是从0-9的值，反而都是10呢？<br>&emsp;&emsp;答：这道题主要的考点就是形成闭包的数组内每个函数的 i 值。<br>&emsp;&emsp;① for循环执行至 i 为9时，先判断是否 i&lt;10，结果为true，执行循环体，然后 i ++，这时的 i 为10。再次判断是否 i&lt;10，结果为false，结束循环，返回数组arr。在test的AO内保存的 i 的值就是10。<br>&emsp;&emsp;② 在执行for循环时，数组的每 i 位被赋值一个函数，这个时候的函数是不被执行的，系统认为这是一个函数引用，不会关注匿名函数内部的变量，所以这时候的 i 的值是未知的。在外部执行数组内的函数时，遵循作用域链，在test的AO内找到 i 的值，因为所有执行函数都共享同一个test函数的AO，所以打印出的所有值都是一样的10。</p>
<p>上面问题的解决办法：将内部函数写成”立即执行函数”的函数<br><img src="/images/20062601/js5/Image%5B20%5D.png" alt><br>解决思路：在for循环内每循环一次都生成一个立即执行函数，立即执行函数在执行完成后就立即销毁，但立即执行函数的AO依然保存在arr[i]的作用域链中。每次循环内的立即执行函数都是不同的个体，所以在每个立即执行函数的AO内保存的 i 值都不同。arr[i]的函数执行时，会到立即执行函数的AO中获取 i 的值。<br>&emsp;&emsp;多对一的闭包就要用多对多的方式解决，让for循环内的变量直接变现，就是将当前循环的 i 值直接保存起来。</p>
<h3 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h3><p><img src="/images/20062601/js5/Image%5B21%5D.png" alt><br>考点：addEventListener的使用，for循环内绑定事件会形成闭包</p>
<p><img src="/images/20062601/js5/Image%5B22%5D.png" alt><br>考点：GO、AO</p>
<p><img src="/images/20062601/js5/Image%5B23%5D.png" alt><br>考点：str.charCodeAt( index )返回字符编码</p>
<p><img src="/images/20062601/js5/Image%5B24%5D.png" alt></p>
<blockquote>
<p>逗号操作符”,”：含义是先看逗号前面的表达式是否需要计算，计算完成后再看后面的表达式，都计算完成后，将后面计算表达式的结果返回。</p>
</blockquote>
<p><img src="/images/20062601/js5/Image%5B25%5D.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑦</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A6/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承发展史"><a href="#继承发展史" class="headerlink" title="继承发展史"></a>继承发展史</h4><p>原型是prototype，是Function函数的一个属性，并不是只有构造函数才有原型，只要是函数就具有这个属性</p>
<p>原型是构造函数构造出对象的公有祖先</p>
<h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><ol>
<li><p>传统形式 –&gt; 原型链<br> 实现途径：一个对象继承一个原型，通过原型链。<br> 问题：<em>过多的继承了没用的属性</em></p>
<p> 通过原型也可以产生继承关系，但原型只是实现继承关系的一种方法，但它提升不到工业化的程度，这个也会产生很多问题。<br> <img src="/images/20062601/js7/Image.png" alt><br> son最后会继承father和grand的原型链，即使这里有着不需要的值。</p>
</li>
<li><p>借用构造函数<br> 实现途径：call、apply</p>
<blockquote>
<p>问题：<br> &emsp;不能继承借用构造函数的原型<br> &emsp;每次构造函数都要多走一个函数</p>
</blockquote>
<p> 这个过程只是借用他人的函数来实现自己的功能，并不能算是真正的继承。<br> <img src="/images/20062601/js7/Image%5B1%5D.png" alt><br> 即使student调用Person生成了自己的对象，但是原型依然指向student.prototype。并且每调用一次构造函数，就会执行两个或多个方法(Student、Person)。视觉上是缩减了代码(减少了重复代码)，但事实上使代码变得复杂了，增加了函数的调用。减少了代码，但是浪费效率了</p>
</li>
<li><p>共享原型<br> 问题：不能随便改动自己的原型</p>
<blockquote>
<p>&emsp;inderit表示继承，是css的属性中的一个值， 也就是继承值的意思 。css属性中，但凡是文字类的属性font-size、font-weight、color、line-height，都有一个传递的特性，如果子元素没有设置文字类属性的话，它就默认继承父元素的文字类属性。给父级设置font-size: 20px;子元素的font-size也是20px，除非给子元素单独设置属性。<br>&emsp;子元素默认的值：font-size: inherit；</p>
</blockquote>
<p> 两个构造函数， 其中一个是原始的构造函数，这个函数的原型想被用到另一个构造函数上，实现两个构造函数共有一个原型的特点</p>
<p> 注意：必须先继承再生成对象，否则不生效<br> <img src="/images/20062601/js7/Image%5B2%5D.png" alt></p>
<p> 当其中一个构造函数修改了原型上的值的时候，另一个也会受到影响<br> <img src="/images/20062601/js7/Image%5B3%5D.png" alt></p>
</li>
<li><p>圣杯模式<br> Father.prototype是构造函数Father和F两方的共有原型，F充当了中间层，F.prototype = Father.prototype。Son和F通过原型链的方式形成关系，Son.prototype = new F();这样new F()的原型是F.prototype，也就能找到Father.prototype，这样就通过原型链形成了继承的关系。</p>
<p> 由此得到的继承关系的优点是：即使修改Son.prototype，也不会影响到Father.prototype。Son的原型是new F，而构造函数F的原型才是Father.prototype。这是两层关系，没有相互连通。</p>
<p> 通过图来表示：<br> <img src="/images/20062601/js7/Image%5B4%5D.png" alt></p>
<p> 代码简化：<br> <img src="/images/20062601/js7/Image%5B5%5D.png" alt></p>
<p> 这样写会有一个小小的问题：<br> <img src="/images/20062601/js7/Image%5B6%5D.png" alt></p>
</li>
<li><p>最终的”圣杯模式”<br> <img src="/images/20062601/js7/Image%5B7%5D.png" alt><br> 在继承inherit函数内的代码不可以改变顺序</p>
</li>
</ol>
<h3 id="属性私有化"><a href="#属性私有化" class="headerlink" title="属性私有化"></a>属性私有化</h3><p><img src="/images/20062601/js7/Image%5B8%5D.png" alt></p>
<p>多个函数和最外层构造函数分别形成了闭包，这些函数都共用同一个AO(外层函数的)。构造函数生成的对象可以随意更改共同变量，但是不能在外部获取这个变量的值。这个变量就是函数的<strong>私有属性</strong>。</p>
<p><img src="/images/20062601/js7/Image%5B9%5D.png" alt><br>上述pWife就是私有变量，在函数外不可以访问，但是形成的闭包函数可以操作这个变量。</p>
<blockquote>
<p>人类的学习的本质方法不是在知道一个规律后，再明确对这个事物的认知。而是通过不断的学习、不断的经历，最后自己才总结出一个规律和方法。<br>人工智能，都是通过大数据识别的方法来实现人工智能，通过大数据来自动生成规律和算法，这也是一个深度学习的过程。</p>
</blockquote>
<h3 id="模块化开发，防止污染全局变量，解决命名冲突问题"><a href="#模块化开发，防止污染全局变量，解决命名冲突问题" class="headerlink" title="模块化开发，防止污染全局变量，解决命名冲突问题"></a>模块化开发，防止污染全局变量，解决命名冲突问题</h3><ol>
<li><p><strong>命名空间</strong>：管理变量，防止污染全局，适用于模块化开发<br> 命名冲突是企业开发的一个困扰性的问题，开发一个项目时，特别是多人协作开发时，会有多个文件，最后要将所有的文件合一起，如果有多个文件内有重名的变量时，就会造成相互覆盖的问题。</p>
<p> 在多人一起写代码时，通过写一个命名空间，存储所有的变量。但是现在已经废弃了这个方法。<br> <img src="/images/20062601/js7/Image%5B10%5D.png" alt><br> <img src="/images/20062601/js7/Image%5B11%5D.png" alt></p>
</li>
<li><p><strong>闭包</strong>：可以通过闭包来解决在同一个文件内，命名相互冲突的问题：<br> <img src="/images/20062601/js7/Image%5B12%5D.png" alt><br> 现在用工具webpack来解决这问题。</p>
</li>
</ol>
<h3 id="实现链式调用方法-模仿jQuery"><a href="#实现链式调用方法-模仿jQuery" class="headerlink" title="实现链式调用方法(模仿jQuery)"></a>实现链式调用方法(模仿jQuery)</h3><p>在每个方法的函数内<code>return this;</code>，将当前这个对象返回后，就可以像链式操作一样继续执行<br><img src="/images/20062601/js7/Image%5B13%5D.png" alt></p>
<h3 id="属性表示方法"><a href="#属性表示方法" class="headerlink" title="属性表示方法"></a>属性表示方法</h3><ol>
<li>obj.prop</li>
<li>obj[‘prop’]</li>
</ol>
<p>每当通过字符”.”来访问对象的属性时，系统内部会隐式的将”.”符号转化为中括号”[]”，在实现对象的增删改查时可以使用”[]”方法，这样不需要内部转化了运行会更快一些，但是第一种”.”来获取更加快捷一些。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">"xiaohua"</span></span><br><span class="line">&#125;</span><br><span class="line">obj.name;--&gt;obj[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<p>中括号”[]”内的值可以是字符串、字符串拼接变量、或者是字符串类型的变量，这种方式更加灵活</p>
<h3 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h3><p>枚举：enumeration，遍历<br>一组数据内有多个值，一个一个获取每个值的内容的过程就叫做遍历，也就是枚举。</p>
<ol>
<li><p>for in循环，其实就是简化版的for循环<br> <strong>可以实现对象的遍历，通过对象循环属性的个数来控制循环圈数，在循环每一圈时，将对象的属性名赋值给var关键字声明的变量 prop ，每圈内 prop 的名字都不同。</strong></p>
<p> <strong>不仅可以遍历对象，还可以遍历数组。</strong></p>
<p> <img src="/images/20062601/js7/Image%5B14%5D.png" alt><br> 只会打印出对象自身以及原型上的属性，对象的原型的<strong>proto</strong>指向Object.prototype时，不会打印出Object.prototype上的属性值。不会遍历到系统最顶端自带的值</p>
</li>
<li><p>hasOwnProperty() 过滤性方法，判断是否是对象自己的属性<br> 在遍历一个对象的属性时，hasOwnProperty()会将对象的原型上的属性返回false，并且不会遍历到系统最顶端的属性。<br> <img src="/images/20062601/js7/Image%5B15%5D.png" alt></p>
</li>
<li><p>in 判断一个属性是不是一个对象的<br> 跟hasOwnProperty的区别：会获取对象所有的属性，包括原型上的属性<br> <img src="/images/20062601/js7/Image%5B16%5D.png" alt></p>
</li>
<li><p>instanceof<br> 官方定义：判断一个对象是否是instanceof后的构造函数构造出来的</p>
<p> <em>A instanceof B</em><br> 实际定义：看对象 A 的原型链上有没有 B 的原型，有的话就返回true<br> <img src="/images/20062601/js7/Image%5B17%5D.png" alt></p>
</li>
<li><p>区分数组和对象的方法</p>
<ul>
<li>constructor</li>
<li>instanceof</li>
<li>Object.prototype.toString.call()<br><img src="/images/20062601/js7/Image%5B18%5D.png" alt></li>
</ul>
</li>
</ol>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="不同情况下，this的指向："><a href="#不同情况下，this的指向：" class="headerlink" title="不同情况下，this的指向："></a>不同情况下，this的指向：</h4><ol>
<li><p>函数预编译过程(AO) this –&gt; window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行new操作后，实际上内部隐式执行：</span></span><br><span class="line">    <span class="comment">// var this = Object.create(test3.prototype);</span></span><br><span class="line">    <span class="comment">// 之前表意的写法：</span></span><br><span class="line">    <span class="comment">// var this = &#123;</span></span><br><span class="line">    <span class="comment">//      __proto__: tese3.prototype</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 原本代码</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AO &#123;</span><br><span class="line">    <span class="comment">// 实际预编译还包括arguments和this</span></span><br><span class="line">    <span class="built_in">arguments</span> : [<span class="number">1</span>],</span><br><span class="line">    <span class="keyword">this</span> : <span class="built_in">window</span>,</span><br><span class="line">    <span class="comment">// 之前了解的预编译</span></span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    c: <span class="literal">undefined</span> --&gt; <span class="number">1</span>,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test3(<span class="number">1</span>);<span class="comment">// 默认调用方式 this指向window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行new操作</span></span><br><span class="line"><span class="keyword">new</span> test3(<span class="number">2</span>);<span class="comment">// 通过new关键字调用，this指向构造函数test3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局作用域里(GO) this –&gt; window<br><img src="/images/20062601/js7/Image%5B19%5D.png" alt></p>
</li>
<li><p>call / apply 可以改变函数运行时this指向</p>
</li>
<li><p>obj.func(); func()里面的this指向obj<br> this指向调用函数的对象</p>
</li>
</ol>
<h4 id="this指向题"><a href="#this指向题" class="headerlink" title="this指向题"></a>this指向题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **** 重点题</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"222"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"111"</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = a.say;</span><br><span class="line">fun();<span class="comment">// 222 在全局执行</span></span><br><span class="line">a.say();<span class="comment">// 111</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    name : <span class="string">"333"</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this.fun() --&gt; b</span></span><br><span class="line">        <span class="comment">// fun() --&gt; window</span></span><br><span class="line">        <span class="built_in">console</span>.log(fun);<span class="comment">// 传递进来的参数，不是全局的fun</span></span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**b.say(a.say);**<span class="comment">// 222 在b的say函数内 谁都没调用fun，指向的是window</span></span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();<span class="comment">// 333</span></span><br></pre></td></tr></table></figure>

<p>难点解析：<strong>b.say(a.say);</strong><br>这句话执行时，是将a.say这个匿名函数传了进来，在b.say函数内的this指向的是b，这里与b无关，只是在b.say的函数内执行fun()这个函数，所以fun内的this指向的是window<br>就像下图展示的一样，test()虽然在b.say内执行，但是test内的this指向与b无关<br><img src="/images/20062601/js7/Image%5B20%5D.png" alt></p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><ol>
<li><p>arguments.callee 指向函数自身的引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明时可以调用函数本身</span></span><br><span class="line"><span class="comment">// 匿名函数的话只能通过arguments.callee</span></span><br><span class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br><span class="line"><span class="comment">// 求n的阶乘</span></span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">// 628800</span></span><br></pre></td></tr></table></figure>

<p> 即使是嵌套函数，答应内部函数的arguments.callee时，返回的也是当前函数<br> arguments只有callee和length两个属性</p>
</li>
<li><p>function.caller 函数当前被调用的环境<br>是函数自己的属性，就像prototype一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); <span class="comment">// test4</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); <span class="comment">// demo</span></span><br><span class="line">        <span class="built_in">console</span>.log(demo.caller); <span class="comment">// test4</span></span><br><span class="line">    &#125;</span><br><span class="line">    demo();</span><br><span class="line">&#125;</span><br><span class="line">test4();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>克隆：B是一个空对象，将A的属性克隆到A身上，并且修改B的值不会影响A</p>
<ol>
<li><p>浅层克隆<br>将A拷贝给B</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'abc'</span>,</span><br><span class="line">    age : <span class="number">123</span>,</span><br><span class="line">    sex : <span class="string">'female'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = target || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        target[prop] = origin[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> clone1 = clone(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(clone1);<span class="comment">// &#123;name: "&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>深层克隆<br> 无论原始值还是引用值都是各自独立的，一个修改不会影响另一个</p>
<p> 方法原理分析：<br> &emsp;&emsp;拷贝一个对象实际上就是拷贝对象内的属性，首先先将对象所有的属性遍历一遍，查看每个属性是引用值还是原始值，原始值需要特殊的拷贝方式，引用值需要再次执行下列过程。<br> &emsp;&emsp;引用值在判断是数组时， 先创建一个空数组，再将原来的数组和空数组当做一对要被拷贝的新对象，将数组循环遍历一遍，再按照下列拷贝过程，判断数组内的每一个值后再进行拷贝。<br> &emsp;&emsp;引用值判断是对象时，先创建空对象，再遍历看看每一位都是什么。</p>
<p> 拷贝过程：<br> &emsp;&emsp;首先遍历对象，通过for…in循环<br> &emsp;&emsp;① 判断是不是原始值 typeof() 判断是否为object<br> &emsp;&emsp;② 判断是数组还是对象 instanceof、constructor、Object.prototype.toString.call()<br> &emsp;&emsp;③ 建立相应的数组或对象<br> &emsp;&emsp;④ 递归：循环建立的过程</p>
<p> 因为对象和数组内的值也要通过循环遍历出来再赋值给被克隆对象，所以就要通过递归的形式来实现<br> <img src="/images/20062601/js7/Image%5B21%5D.png" alt></p>
<p> 深度克隆应用：<br> <img src="/images/20062601/js7/Image%5B22%5D.png" alt></p>
</li>
</ol>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>条件判断 ? true : false，并且会返回结果的值<br>作用：节约操作，相当于简化版的if，除了判断条件外，还可以将结果的值返回</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑧</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A7/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>其实就是特殊的对象</p>
<ol>
<li><p>定义</p>
<ul>
<li><p><strong>数组字面量(推荐!)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ ];</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法定义数组，这个构造方法是系统提供的<br><span style="color: #b3b0b0;font-size: 14px">js内所有的数组方法都来源于Array.prototype</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>( );</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别：1.如果只传一个值的话，会当做稀松数组，值都是undefined，相当于创建了一个空数组<br>&emsp;&emsp;&emsp;2.传的值只能是整数，不能是小数，会报错。</p>
</li>
</ul>
</li>
<li><p>读取和数写<br> 在javascript内，数组的方法基本不会报错，因为数组基于对象的，是特殊的对象</p>
<p> 在打印不存在的数组位数时，会返回undefined，相当于在对象中访问一个不存在的属性，返回undefined一样</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[num]; <span class="comment">// 不可以溢出读 结果是undefinde 但是不会报错</span></span><br><span class="line">arr[num] = xxx; <span class="comment">// 可以溢出写 可以给不存在的位数赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组常用的方法<br> 实际上是 <code>es3.0</code> 的方法，不传参数不报错</p>
<ul>
<li><p>改变原数组(只有这7个)<br>  <strong>push</strong>：向数组的<strong>最后一位</strong><span style="color: #f90d85">添加</span>数据，可同时添加多个参数，添加成功后返回数组长度<br>  <strong>pop</strong>：把数组的<strong>最后一位</strong><span style="color: #0fd494">剪切</span>出去，不需要传参，返回剪切位的值<br>  <strong>unshift</strong>：向数组的<strong>第一位</strong><span style="color: #f90d85">添加</span>数据，可同时添加多个参数，并且在添加成功后返回数组长度<br>  <strong>shift</strong>：把数组的<strong>第一位</strong><span style="color: #0fd494">剪切</span>出去，不需要传参，返回剪切位的值<br>  <strong>sort</strong>：按照ASCII码给数组<strong>排序</strong>，返回排序后的数组，参数可以写一个回调函数</p>
<pre><code>匿名函数：
    1. 必须有两个形参
    2. 规则：看函数的返回值，当返回值为负数时，那么前面的数放在前面；
        当返回值为正数时，那么后面的数在前；
        返回值为0时，位置不动
    比较规则就是：冒泡排序，传入两个数值，通过自定义的规则来判断返回值。</code></pre><p>  <img src="/images/20062601/js8/Image.png" alt><br>  <strong>reverse</strong>：<strong>逆转</strong>数组内的顺序，返回逆转后的数组<br>  <strong>splice</strong>：参数表示(开始位数，截取的长度，在切口处添加新的数据(可以添加无穷个))。返回截取到的数组</p>
</li>
<li><p>不改变原数组<br>  <strong>concat</strong>：连接两个数组，参数可以是数组和数字，返回拼接后的数组<br>  <strong>join</strong>：按照参数将数组连接为字符串，参数必须是字符串，不建议写数字，参数不写默认为”,”<br>  <strong>split</strong>：将字符串按照参数拆分为数组，参数必填，且为字符串，与join用法互逆<br>  <strong>toString</strong>：将数组变成字符串，返回逗号连接的字符串形式，Array重写的方法<br>  <strong>slice</strong>：类似splice，</p>
<pre><code>参数：（开始位数下标，截取结束位数下标）
只有一个参数时，是从参数位开始至结尾。
没有参数时，就截取整个数组。主要用于将一个类数组转化为数组</code></pre><p>一般的数组方法都可以传负数的参，负数的参数实现的方法：<br>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">splice = <span class="function"><span class="keyword">function</span> (<span class="params">position, length, newStr</span>) </span>&#123;</span><br><span class="line">    positon += position &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="keyword">this</span>.length;</span><br><span class="line">    <span class="comment">// -1 + 4 = 3; 从数组下标是3的位置开始</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= <span class="number">0</span> || position &lt; <span class="keyword">this</span>.length) &#123;<span class="comment">//继续执行&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
</ol>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>看起来像数组，也可以当做数组来用，但是就不是数组，所以数组的方法都不能用</p>
<h4 id="类数组的组成"><a href="#类数组的组成" class="headerlink" title="类数组的组成"></a>类数组的组成</h4><p>属性要为索引属性，也就是数字，必须有length属性，最好加上push方法</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以利用属性名模拟数组的特性</li>
<li>可以动态的增长length属性</li>
<li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充</li>
</ol>
<p><strong>没有length属性，不能叫做类数组。</strong><br><img src="/images/20062601/js8/Image%5B1%5D.png" alt></p>
<p>类数组是对象，但是可以当做数组来用。数组的方法需要主动添加才能用，</p>
<p>高级编程：DOM里可以生成数组的方法都是类数组</p>
<h4 id="练习代码"><a href="#练习代码" class="headerlink" title="练习代码"></a>练习代码</h4><p><img src="/images/20062601/js8/Image%5B2%5D.png" alt><br><img src="/images/20062601/js8/Image%5B3%5D.png" alt><br><img src="/images/20062601/js8/Image%5B4%5D.png" alt></p>
<h3 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h3><p>作用： 在企业开发中，用来防止报错的。<br>当页面中的一行代码出错时，就会阻止继续执行后面的代码。为了解决这个问题，就用到try catch方法</p>
<p>在try内发生错误，不会执行try里面错误后面的代码，而是直接忽略后跳转到catch方法内，catch会捕捉错误并且将错误信息封装到一个对象内返回，再继续执行try catch外面的代码。<br>try内没有错误时，代码就正常执行。不会进到catch内，所以也不会执行catch的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);<span class="comment">// a</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">":"</span> + e.message);</span><br><span class="line">    <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'d'</span>);<span class="comment">// d</span></span><br></pre></td></tr></table></figure>

<p>Error.name的六种值对应的信息(报错信息)：</p>
<ul>
<li>EvalError：eval()的使用与定义不一致</li>
<li>RangeError：数值越界</li>
<li>ReferenceError：非法或不能识别的引用数值（未定义就使用）</li>
<li>SyntaxError：发生语法解析错误</li>
<li>TyperError：操作数类型错误</li>
<li>URIError：URI处理函数使用不当（地址处理错误）</li>
</ul>
<h3 id="es5严格模式"><a href="#es5严格模式" class="headerlink" title="es5严格模式"></a>es5严格模式</h3><p>es3.0和es5.0是现在的通用模式，一个版本升级时，会摒弃一些老的语法，增加一些新的语法。这样就会产生一样的语法得到不一样执行结果的问题，这个被称为冲突。</p>
<p>浏览器目前是基于es3.0原有的和es5.0的新增方法执行的，遇到两个版本都冲突的地方时，规则是执行3.0的方法。</p>
<p>es3.0和es5.0产生冲突的部分，想要通过es5.0来解决的办法：<strong>es5.0严格模式</strong></p>
<p>启动es5.0：<span style="color: #f90d85">“use strict”</span> 写在页面逻辑的最顶端，也可以写在局部(函数内)</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><span style="color: #f90d85">不再兼容es3.0的一些不规则语法，使用全新的es5.0规则</span></p>
<h4 id="两种用法"><a href="#两种用法" class="headerlink" title="两种用法"></a>两种用法</h4><ol>
<li><span style="color: #f90d85">全局严格模式</span></li>
<li><span style="color: #f90d85">局部函数内严格模式：推荐！</span></li>
</ol>
<p>启动方式是字符串的原因：浏览器不同、浏览器的版本不同，如果直接调用函数来执行的话，低版本的浏览器不支持es5.0，没有这个调用方法，那么就会报错。字符串可以看做一个表达式，无法识别时，不会报错。主要就是为了向后兼容，老版本浏览器不会报错，新浏览器可以识别。</p>
<p><span style="color: #f90d85">就是一行字符串，不会对不兼容严格模式的浏览器产生影响。</span></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>严格模式虽然限制了代码的灵活性，但同时也减少了代码出错的概率，有利于编程</p>
<h4 id="es5-0严格模式不支持的语句"><a href="#es5-0严格模式不支持的语句" class="headerlink" title="es5.0严格模式不支持的语句"></a>es5.0严格模式不支持的语句</h4><ol>
<li><p><span style="color: #f90d85">不允许用with</span><br> with内的代码可以被执行，当with内传的参是一个对象时，就会改变当前with内的代码的作用域链的最顶端(最近的AO)变成这个对象参数。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"obj"</span>,</span><br><span class="line">    age: <span class="number">321</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"scope"</span>;</span><br><span class="line">    <span class="comment">// 先找obj1里的值</span></span><br><span class="line">    <span class="keyword">with</span>(obj1) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);<span class="comment">// obj</span></span><br><span class="line">        <span class="built_in">console</span>.log(age);<span class="comment">// 321</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p> 作用：简化代码<br> 缺点：修改作用域链的话，系统内核会消耗大量的效率来更改，会把程序变得非常的慢。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名空间的使用 with</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="comment">// document.write</span></span><br><span class="line">    <span class="comment">// 会去对应的执行期上下文找到write的方法</span></span><br><span class="line">    write(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: #f90d85">不可以使用 arguments.callee、function.caller</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// es5.0函数内严格模式的启动</span></span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    <span class="comment">// console.log(arguments.callee);// error 不能使用</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// es3.0规则</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);<span class="comment">// test1</span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: #f90d85">变量赋值前必须声明</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strictFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    <span class="comment">// 变量未定义会报错</span></span><br><span class="line">    <span class="comment">// a = 1;// error: a is not defined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">strictFun();</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: #f90d85">局部的this必须被赋值(Person.call(null/undefined))，赋值什么就是什么</span><br> es3.0，在预编译过程中 this 指向 window<br> es5.0，在预编译过程中 this 如果不被赋值的话，为undefined</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strictFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="string">"use strict"</span>;</span><br><span class="line">    <span class="comment">// this必须被赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// undefined</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aboutThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> aboutThis();<span class="comment">// aboutThis&#123;&#125; --&gt; 该对象的constructor</span></span><br><span class="line">    aboutThis.call(&#123;&#125;);<span class="comment">// &#123;&#125;</span></span><br><span class="line">    aboutThis.call(<span class="number">123</span>);<span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line">strictFun();</span><br></pre></td></tr></table></figure>

<p> <span style="color: #b3b0b0">通过new执行构造函数后，打印当前this得到的结果是该对象的构造函数。在控制台打印出来的格式是：构造函数的名字 + 对象的标准形式{ }</span><br> <img src="/images/20062601/js8/Image%5B5%5D.png" alt></p>
<p> 在全局打印this时，指向是window，这个值不能发生改变</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// window</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拒绝重复属性和参数，但是不会报错<br> 在es3.0中，重复的参数是不报错的，取值时是取最后的值<br> 在es5.0中，函数传递重复的形参时，会报错</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">name, name</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 只传一个实参时，值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js8/Image%5B6%5D.png" alt><br> 在es3.0中，重复的属性不报错，取值会取最后那个属性的值<br> 在es5.0中，对象内有重复的属性时，不会报错，取值取最后一个</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'123'</span>,</span><br><span class="line">    name : <span class="string">'234'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// 234</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><ol>
<li>将字符串当做代码来执行</li>
<li>通用的语法规定中，es3.0都不能使用eval()，不能用的原因的是可以改变作用域（eval()是魔鬼）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(a)'</span>);<span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>ECMAScript 6</title>
    <url>/2019/06/18/ECMAScript%206/</url>
    <content><![CDATA[<p>HTML(超文本标记语言 hyperText markup language)</p>
<p>成哥名言：如果想在外行人面前展示自己的专业性，外行人更关注专业素养，只有专业素养好了，别人才能更加认可你。</p>
<p>\</p>
<p>html由一对对的标签组成，每对标签都有自己的含义和意义，用于修饰标签内的内容，这个叫做双标签；而本身就代表着功能，不需要包裹任何内容就能实现其功能的标签叫做单标签。html的标签大概二百五十个网上，每年都在持续增加。</p>
<p>\</p>
<p>标签：一个标签代表一个功能，标签内的内容具有标签的功能</p>
<pre><code>html：根标签，一个html文件只能有一个html标签</code></pre><p>lang属性：告诉搜索引擎爬虫，当前网站展示的语言内容，更方便抓取网站</p>
<pre><code>\&lt;html lang=&quot;en, zh&quot;\&gt;\&lt;/html\&gt;

en：英文

zh：中文

de：德语

其他语言都是汉语拼音前两位



知识拓展：</code></pre><p>  网站域名：每一个网站都有一个域名地址，通过域名找到服务器的地址，获取相关的网页内容和资源并在当前访问的电脑上展示，这是网页访问的过程。如：<a href="http://www.duyitec.com/" target="_blank" rel="noopener">www.duyiTec.com</a></p>
<pre><code>物理地址：也叫IP地址，如 192.168.1.1

域名会通过DNS解析为物理地址。

![](渡一%20学习%20HTML_files/Image.png)</code></pre><p>搜索引擎爬虫：例如百度搜索会根据关键字将相关信息抓取到，但是要先签订关键字协议：不允许有黄赌毒，否则封杀。通过”竞价排名”的方式，按顺序排列搜索结果，竞价排名价格：按照点击次数(转化率)收费。价格范围：1-999，一般高价格就是高转化率行业(医院)。但是会通过”IP段锁定”技术(同一个时间段内，一个ip地址访问同一个网站多次时只算一次)并且会检测生物行为(点开页面立刻关闭时不算次数)来避免恶意点击。</p>
<p>\</p>
<pre><code>SEO：叫做搜索引擎优化技术，</code></pre><p>\</p>
<pre><code>html标签包含两个结构化标签：

    head标签：为浏览器做配置，例如：历史记录、编码器字符集等</code></pre><p> 当浏览器出现乱码时，在head标签内新增标签并设置属性charset(编码字符集)：</p>
<pre><code>\&lt;meta charset=&quot;utf-8&quot;\&gt;

知识拓展：</code></pre><p>编码字符集：gb2312(中国国家标准第2312条，包括亚裔字符集，但缺少繁体字符集)</p>
<p>gbk(中国国家标准扩展版本，包含亚裔字符集和繁体字符集)</p>
<p>unicode(万国码，包括所有国家的语言)</p>
<pre><code>utf-8(unicode transformation</code></pre><p>format 8 bit 目前通用版本，还有16bit版本) 万国码</p>
<p>\</p>
<pre><code>为浏览器也设置页面标题：页脚标

\&lt;title\&gt;我是标签页的标题\&lt;/title\&gt;</code></pre><p>\</p>
<pre><code>    搜索引擎爬虫的关键字及描述设置：

    \&lt;meta content=&quot;关键字&quot; name=&quot;keywords&quot;\&gt;

    \&lt;metacontent=&quot;描述&quot; name=&quot;description&quot;\&gt;

body标签：展示给用户看的内容</code></pre><ul>
<li><p>p标签：paragraph，段落标签，用处：使标签内的内容成段展示</p>
</li>
<li><p>h1~h6标签：header，标题标签，从一级标题至六级标题的字体大小依次缩小</p>
<pre><code>作用：独成一段、更改字体的大小、加粗字体

快捷生成方式(h\${内容}\*6)：

![](渡一%20学习%20HTML_files/Image%20[1].png)</code></pre></li>
<li><p>strong标签：内容加粗展示</p>
</li>
<li><p>em标签：内容呈斜体展示 </p>
<pre><code>标签可以嵌套使用：字体加粗且斜体展示

![](渡一%20学习%20HTML_files/Image%20[2].png)</code></pre></li>
<li><p>del标签：delete，中划线，删除标签</p>
</li>
<li><p>address标签（不常用）：地址标签，独占一行</p>
<pre><code>![](渡一%20学习%20HTML_files/Image%20[3].png)</code></pre></li>
</ul>
<p>\</p>
<ul>
<li><p>div标签：充当容器，无功能和意义，独占一行</p>
</li>
<li><p>span标签：充当容器，无功能和意义，相同标签在同一行展示</p>
<pre><code>容器的作用：</code></pre></li>
</ul>
<ol>
<li>结构化：分块明确，可以划分区间，使页面结构化</li>
</ol>
<ol start="2">
<li>捆绑操作：只需要操作容器就可以改变容器内的内容</li>
</ol>
<p>\</p>
<pre><code>知识点补充：</code></pre><p> 空格、回车：在浏览器内表示文本分割符，特别是针对英文单词换行展示</p>
<pre><code>空格文本的展示形式：

    html编码：&amp;+特殊字符+;

        例如：&amp;nbsp;  空格文本 = 空格

                  &amp;lt;  小于符

                  &amp;gt;  

         注意：

            小于号＜：less than

            大于号\&gt;：great</code></pre><p>than(great代表程度上的比较，more代表数量的比较)</p>
<ul>
<li>br标签：回车，代表一个换行符，单标签。</li>
<li>hr标签：代表水平线</li>
</ul>
<p>\</p>
<ul>
<li><p>ol li：order list<br>有序列表，成组出现且li的内容都是独占一行，按照1.2.3.的顺序展示。不常用</p>
<pre><code>ol是架子，li是内容

ol的属性：

    type：表示排序规则

        type的值为&quot;1&quot;时，按照数字的顺序排序；

        type的值为&quot;a&quot;时，按照英文字母顺序排列；</code></pre></li>
</ul>
<p>type的值为”A”时，按照大写的英文祖母排序；当li数量超过26时，按照AA、AB…(27进制)排序</p>
<p>type的值为”i”时，按照小写罗马数字排序(罗马数字诞生最早，阿拉伯数字是阿拉伯人从印度引入的)</p>
<pre><code>type的值为&quot;Ⅰ&quot;时，按照大写罗马数字排序



       reversed：reversed 反向排序</code></pre><p>start：开始排序的数值，例如<img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B4%5D.png" alt></p>
<p>\</p>
<p>成哥名言：从孩子到长大的每个阶段喜欢的东西都是不同的，最喜欢的电影《了不起的盖茨比》、《返老还童》。不同年龄看都有不同的体会。</p>
<ul>
<li><p>ul li：unorder list 无序列表，展现形式与无序列表相同</p>
<pre><code>仅有一个属性：</code></pre></li>
</ul>
<p> type：值为disc，discircle实心圆<img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B5%5D.png" alt></p>
<pre><code>square，方块

circle，圈、空心圆</code></pre><p> 父子结构适用于：一个大的功能由很多功能子项组成，每个功能子项的功能和样式基本都是相同的，只是内容有些差别。现实生活中举例的话，就是柜子的抽屉，每个抽屉里的东西都不同。代码示例的话就是菜单栏。</p>
<ul>
<li><p>img标签：image，用于展示图片，单标签</p>
<pre><code>图片的相关属性：

   src：source，图片的资源地址

           值为：1.</code></pre><p>网上的url(超级链接，也就是图片的服务器地址)</p>
<pre><code>          2. 本地的绝对路径

          3. 本地的相对路径

知识点补充：</code></pre></li>
</ul>
<p>绝对路径：当两个文件不在同一个文件夹内时，它们的路径呈绝对关系，在一个文件内引入另一个文件时，路径需要写出引入文件的绝对路径(也就是，在本地的完整路径：D:/a/b/c/123.jpg)</p>
<p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B6%5D.png" alt></p>
<p> 相对路径：当两个文件在同一个文件夹内时，它们的路径呈相对关系，在一个文件内引入另一个文件时，路径只需写出其文件名即可.</p>
<p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B7%5D.png" alt></p>
<p>alt：图片占位符，当图片展示出错时，会展示文字信息</p>
<p>title：图片提示符，鼠标移动至图片上时，会展示相关信息</p>
<ul>
<li><p>a标签：</p>
<pre><code>作用：

    1. anchor</code></pre><p>锚：用于记录某个点的位置，是a标签最开始的作用</p>
<pre><code>![](渡一%20学习%20HTML_files/Image%20[8].png)</code></pre></li>
</ul>
<ol start="2">
<li>超链接标签，双标签；a标签可以包裹任何内容，例如：图片、文字</li>
</ol>
<ol start="3">
<li>拨打电话功能<img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B9%5D.png" alt></li>
</ol>
<ol start="4">
<li>发邮件<img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B10%5D.png" alt></li>
</ol>
<ol start="5">
<li><p>协议限定符：<img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B11%5D.png" alt></p>
<pre><code>相关属性：

    href：hyperText</code></pre><p>reference超文本参考、超文本引用，内容是指向的链接地址(必须是带有协议的完整链接：http://或https://)；作为锚点使用时，与元素的id配合使用</p>
</li>
</ol>
<p>target(目标)：值为_blank时，表示打开一个新标签</p>
<p>成哥名言：即“为天地立心，为生民立命，为往圣继绝学，为万世开太平”，为北宋大家张载的名言。<br>当代哲学家冯友兰将其称作“横渠四句”。</p>
<ul>
<li>form标签：表单标签，可以发送数据给后端。必须与其他组件配合使用</li>
</ul>
<p> 数据发送必须包含两点：数据名name和数据值value(用户输入的内容)</p>
<pre><code>相关属性：

    method：发送数据的方式，有两个值分别为get、post

    action：数据发送的地址

相关组件(元素)：</code></pre><p>input：带有属性type，type值不同是代表input的不同功能；也带有属性name，name的值就是发送数据时key的值</p>
<pre><code>type值为：text 输入框</code></pre><p> password 密码框（在储存密码时，通过mds加密方式加密，是不可逆解的）</p>
<p> submit 提交（默认展示文本为”提交”，可以通过修改value属性进行修改</p>
<pre><code>知识点补充：</code></pre><p>网站分几类：有一类受国家安全性协议监管的公司，会对用户提交的密码进行md5(美国二战发明，最厉害的是不可逆，也就是不可破解)加密后储存到数据库，在用户登录时，会对密码进行md5加密，得到的加密密码与数据库的进行比对，由于每次md5加密后得到相同的加密密码，所以当用户密码与数据库密码一致时，即可登录成功。</p>
<p> 3G、4G网络相比2G网络来说不仅快了，而且安全性协议高了，会对用户所发送的信息加密，所有更加安全。比如在使用支付宝时，手机发送信号是通过无线信号发送给最近的基站，基站连着网线，通过几次路由，跳到杭州总部的支付宝大厦的服务器。数据正常都是通过有线来传输的，但是移动设备是无线信号发送的，发送无线信号时只要在同一个wifi或同一个基站下方圆五百米之内的无线信号就可以被<a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener"></a><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">Fiddler</a>抓包拦截数据。当通过抓包软件来抓包时，若当前为3G\4G网络，抓取的都是加密信息，获取不到有用数据，而2G网可以直接获取其中的信息。当信号不好时或者有人通过扩大器将信号从五百米扩大至2公里发送信号来抓取用户信息，(通过改变信号频次)网络会从4G变成2G。 </p>
<p> radio 单选框（有排他性，当存在多个时，通过添加相同的name值来实现单选）</p>
<p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B12%5D.png" alt></p>
<p>成哥名言：每一个人都会编程，真正的编程需要两部分：一是编程思想、二是编程工具。把编程思想和编程工具结合在一起，编程就是将脑中的思想量化出来的过程，用工具一步步写出来的过程</p>
<p> 课堂练习题：输入框内有”请输入用户名”的文字，点击输入框时，文字消失；点击页面空白处，文字又出现；在输入框内输入其他文字后，输入字体的颜色不同，且点击页面空白处，文字不消失</p>
<p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B13%5D.png" alt></p>
<p> checkbox 多选框，其他属性同radio</p>
<p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B14%5D.png" alt></p>
<pre><code>产品需要符合三个特点：刚需、用户体验、用户粘性

                     默认选中的功能：checked</code></pre><p> <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B15%5D.png" alt></p>
<p>  <img src="%E6%B8%A1%E4%B8%80%20%E5%AD%A6%E4%B9%A0%20HTML_files/Image%20%5B16%5D.png" alt></p>
<pre><code>select option</code></pre><p>下拉框（成组出现）</p>
<pre><code>编程模式：结构、行为、样式，相分离</code></pre><p>\</p>
<p>归类：</p>
<p> 标签：不同类别的标签，本质上是由css属性display的不同的值来控制的。例如：行级元素可以设置display=”block”来变成块级元素。</p>
<pre><code>1. 行级元素(内联元素 inline)：span、a、em、strong、del

      feature：内容决定元素所占位置

                     不可以通过css改变宽高</code></pre><p>\</p>
<pre><code>2. 块级元素(block)：div、p、ul、li、ol、form、address

      feature：独占一行

                     可以通过css改变宽高</code></pre><p>\</p>
<pre><code>3. 行级块元素(内联块元素</code></pre><p>inline-block)：img（只需要设置宽或高，高度会按比例缩放）</p>
<pre><code>      feature：内容决定大小

                     可以通过css改变宽高

知识点补充：</code></pre><p> 凡是带有inline特性(包括inline-block)的元素，都有文字特性，所以元素之间会被分割。这个就可以用来解释类似<br>span 或 image<br>这样的多个元素同行展示时会在彼此之间出现空白处(大小为4px，亲测可证)</p>
<p>代码在上传之前需要压缩文件，具体就是将文件中的多字母单词用一个字母来代替、去空格回车等多余字符  </p>
<p>\</p>
<pre><code>4. 弹性盒子元素：flex box</code></pre><p>\</p>
<p>——————————— 以上为html 4.0.1版本 —————————————</p>
<pre><code>html5：打倒android、ios， 哈哈哈哈</code></pre><p>\</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑥</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A5/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对属性的操作：增、删、改、查"><a href="#对属性的操作：增、删、改、查" class="headerlink" title="对属性的操作：增、删、改、查"></a>对属性的操作：增、删、改、查</h4><ol>
<li><p>增：直接对对象增加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">'light'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删：删除对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.name;<span class="comment">// 结果为true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改：修改对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.shape = <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查：查看对象的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.name;<span class="comment">// undefined 被删掉了</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>查看一个对象不存在的属性时，返回undefined</p>
<h4 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h4><ol>
<li><p>对象字面量/对象直接量：plainObjedt</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数：<br> ① 系统自带的构造函数：Object()、Array()、Number()<br> 构造方法：Object()这个函数可以批量的生产对象，生产出来的对象长得一样但彼此之间相互独立。执行new Object()方法返回一个真正的对象，就需要接收对象：var obj = new Object();与var obj = {};是一样的，只是形式不同。</p>
<blockquote>
<p>js的对象与java、c++类语言不同，另两个需要类作为模板来批量生成对象，相当于js中的构造函数，但是js与之不同的是在对象生成之后还可以随意的修改属性和方法、而其他两种语言是不可以修改的。所以，js更加灵活。</p>
</blockquote>
<p> ② 自定义<br> 结构上与函数没有任何分别，唯一区别是通过new 来生成对象。<br> 规则：构造函数在命名时，按照大驼峰式命名规则</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数内部原理： (三段式)<br> 在函数的执行语句前加上new关键字，就会产生下面的变化：<br> ① 在函数体最前面隐式的加上语句：var this = {};<br> ② 执行 this.xxx = xxx; 将函数内的实参赋值给this的属性<br> ③ 隐式的返回this<br> <img src="/images/20062601/js6/Image.png" alt></p>
<blockquote>
<p>当显式的在函数最后通过return返回值时，return后的值只能是原始值(字符串等)，这种情况下会忽略return后面的值，从而返回原本对象的值。如果是返回{}对象这样的值时，就会返回return后对象的内容；</p>
</blockquote>
<p> <img src="/images/20062601/js6/Image%5B1%5D.png" alt></p>
</li>
</ol>
<p>对象创建方法总结：</p>
<ol>
<li>字面量</li>
<li>构造函数</li>
<li>函数自定义</li>
<li>Object.create</li>
</ol>
<h4 id="包装类："><a href="#包装类：" class="headerlink" title="包装类："></a>包装类：</h4><p>在给原始值添加属性时，实际上原始值是不可以添加的，但是执行添加属性的语句不会报错。是因为系统隐式的通过调用原始值的对象来执行，得到结果后又将其删除，在打印添加的属性时，系统重新执行之前的隐式操作，打印值为undefined.</p>
<ol>
<li><p>问题一：给数字类型的变量num设置一个属性len为3，打印时是undefined的原因？<br> <img src="/images/20062601/js6/Image%5B2%5D.png" alt><br> 问题分析：<br> 当原始值调用属性时，无论赋值还是查找，首先自己没有这个属性，所以会隐式的发生以下过程。</p>
<p> 由于num不能增加len属性，系统就会隐式的执行代码：new Number(num).len = 3;来弥补操作的不足。这步完成之后，直接通过delete方法销毁得到的结果。</p>
<p> 在打印num.len时，因为上次执行得到的结果已经被删除了，系统会再次执行new Number(num)并访问len属性。这次的new Number(num)和上面的是不同的对象，第一次生成的对象new Number(num)已经被销毁，再次生成的就更加没有len属性，所以返回的值是undefined。</p>
<p> <em>原始值可以操作属性，这实际上是系统隐式的执行”原始值的对象类”来完成操作的，本来没有的属性，系统隐式生成的这个过程就叫做包装类。</em></p>
</li>
<li><p>问题二：数组可以通过设置长度来截取数据，那么字符串是不是也可以？<br> <img src="/images/20062601/js6/Image%5B3%5D.png" alt><br> 问题解析：<br> str本身没有.length方法，所以系统会隐形的执行：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(str).length = <span class="number">2</span>; <span class="comment">// 截取字符</span></span><br><span class="line"><span class="keyword">delete</span> <span class="comment">// 截取完成后，结果被销毁了</span></span><br></pre></td></tr></table></figure>

<p> 虽然系统执行了截取操作，但是执行完没有赋值给其他变量，而是销毁了。所以在打印str时，取的值还是最开始定义的str的值，而不是系统截取的值。</p>
<p> 最后打印str.length得到4，是因为”字符串对象”本身就有一个.length属性，相当于：访问new String(str).length后，把值返回<br> <img src="/images/20062601/js6/Image%5B4%5D.png" alt></p>
<blockquote>
<p>Unicode编码包含ASCII编码的255位。<br> Unicode编码最开始是4位(16进制)的，后来又加了4层</p>
</blockquote>
</li>
</ol>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>原型是function对象的一个属性，它定义了构造函数构造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数符合特点：大驼峰式，函数名首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 构造函数可以生成多个相似且各个独立的对象</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p><code>Person</code>代表函数体(函数引用)，函数也是一个对象，也有属性和方法。<br>Person.<strong>prototype</strong>：这是系统自带的属性，这个<code>prototype</code>就是<strong>原型</strong>。这个值在函数定义完成后就被定义好了，它是一个空对象<code>Person.prototype = {}</code>，相当于是<code>Person</code>这个构造函数构造出的对象的父级。</p>
<p>prototype可以赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"laodeng"</span>;</span><br><span class="line">person; <span class="comment">// 空对象 Person &#123;&#125;</span></span><br><span class="line">person.name; <span class="comment">// laodeng</span></span><br></pre></td></tr></table></figure>

<p><em>person原本没有name的属性，但是因为在prototype上定义了，所以person就继承了父级的属性。</em><br><em>person和person1都继承自同一个构造函数的prototype，并且共享prototype的属性。</em><br>疑问：两个对象可以都修改prototype吗?一个改了另一个有影响吗？</p>
<p><strong>原型是一个公有祖先，是该构造函数所构造出的对象的公有祖先</strong></p>
<p>对象获取的值有自己本身的属性也有原型提供的。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用原型特点和概念，可以提取共有属性(放在原型里执行赋值，减少函数内的赋值操作)<br><img src="/images/20062601/js6/Image%5B5%5D.png" alt></p>
<h4 id="对象查看原型"><a href="#对象查看原型" class="headerlink" title="对象查看原型"></a>对象查看原型</h4><p>原型的增删改查：</p>
<ol>
<li>对象可以通过prototype查看、新增原型的属性</li>
<li>不可以删除、修改，只有构造函数可以</li>
</ol>
<p>隐式属性 <code>__proto__</code>：用于存储对象的原型</p>
<blockquote>
<p>在开发工作中，可以通过定义<code>_private</code>这样格式的变量来告诉同事，这是属于我的私有变量，不要改动</p>
</blockquote>
<p><code>__proto__</code>属性的作用：把原型和构造函数联系到一起</p>
<p><img src="/images/20062601/js6/Image%5B6%5D.png" alt><br>在控制台打印<code>otherPerson</code>这个对象的结果是一个空对象，但其包含系统自定义属性<code>__proto__</code>，这个属性实际上是由下图的隐式定义(被注释部分)而来的：<br><img src="/images/20062601/js6/Image%5B7%5D.png" alt><br>在使用new关键字来构造对象时，内部隐式的发生了“三段式”，第一步是定义一个空对象<code>this</code>。但实际上<code>this</code>并不是空值，里边的值就是<code>__proto__</code>，指向构造函数的原型(Person.prototype)。所以在对象被构造完成时，就会生成<code>__proto__</code>属性</p>
<p>根据上述原因，构造函数构造的对象的原型是可以修改的，只需修改对象<code>__proto__</code>的指向。<br><img src="/images/20062601/js6/Image%5B8%5D.png" alt></p>
<p><code>__proto__</code>的作用：当访问一个对象的属性时，若该对象本身没有这个值时，会根据<code>__proto__</code>指向的索引去找到这个属性。</p>
<blockquote>
<p>总结：<br>&emsp;<code>prototype</code> 是构造函数的属性<br>&emsp;<code>__proto__</code>  是构造函数所构造的对象的隐藏属性</p>
</blockquote>
<h4 id="对象查看对象的构造函数"><a href="#对象查看对象的构造函数" class="headerlink" title="对象查看对象的构造函数"></a>对象查看对象的构造函数</h4><p>constructor：构造器，会返回构造对象的构造函数<br><img src="/images/20062601/js6/Image%5B9%5D.png" alt></p>
<p><strong>重难点</strong>：<br>Fruits.prototype.name放置的位置不同，在函数最后所打印出来的值也不同<br><img src="/images/20062601/js6/Image%5B10%5D.png" alt><br>上述代码，最后给Fruits.prototype 直接赋值一个新的对象。但此时已经执行完构造对象的方法。name的值已经定义好就是”apple”，再改变已经不生效。</p>
<p>如果改到执行构造对象之前，结果也不同：<br><img src="/images/20062601/js6/Image%5B11%5D.png" alt></p>
<p>上述代码，在执行构造对象的方法之前，给Fruits.prototype 直接赋值一个新的对象。name的值就是后来改的对象的值”cherry”。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>在原型上加上原型再加上原型，这样的一个把原型连成链的方法，访问顺序也是依照链的顺序来访问(像作用域链一样的访问顺序，由近及远)，就叫做原型链。</p>
<p>原型链的<strong>连接点</strong>就是每个对象的<strong><code>__proto__</code></strong>属性<br><img src="/images/20062601/js6/Image%5B12%5D.png" alt></p>
<p>理解分析：<br>    ② 打印son.name的属性时，因为son对象本身没有name这个属性，接下来会找<code>__proto__</code>指向的原型。原型是father，因为father有name的属性，所以直接打印。<br>    ③ 打印son.lastName时，按照顺序：son自己 –&gt; 通过<code>__proto__</code>找到prototype –&gt; father –&gt; 通过<code>__proto__</code>找到prototype –&gt; grand –&gt;  通过<code>__proto__</code>找到prototype，最后在grand的prototype中找到lastName属性<br>    ④ 打印son.toString时，通过原型链最后找到grand的原型上依然没有，但这不是终点，因为grand对象还有Grand.prototype.<code>__proto__</code>，访问到Object.prototype，找到toString的方法<br>    <img src="/images/20062601/js6/Image%5B13%5D.png" alt></p>
<p>如果打印Grand.prototype.<code>__proto__</code> 值为：Object.prototype;</p>
<p><em>Object.prototype是所有对象的最终原型</em></p>
<p>Object.prototype.<code>__proto__</code> = null;</p>
<h4 id="原型链的增删改查：和原型基本一致"><a href="#原型链的增删改查：和原型基本一致" class="headerlink" title="原型链的增删改查：和原型基本一致"></a>原型链的增删改查：和原型基本一致</h4><p>查看：由近及远，按照原型链来查找<br>删除：只能原型本身可以删除自己的属性<br>修改：只能原型本身可以修改<br>增加：只能原型本身可以增加属性</p>
<p>子级对象修改父级的prototype的值：<br><img src="/images/20062601/js6/Image%5B14%5D.png" alt></p>
<p>这种修改方式可以成功，但是本质上是引用值fortune的修改，给自己增加了新的属性card2。</p>
<p>如果直接携程：son.fortune.card1 = ‘123’这样的形式，父级father原型也会跟着变</p>
<h4 id="对象声明的分析"><a href="#对象声明的分析" class="headerlink" title="对象声明的分析"></a>对象声明的分析</h4><p>声明一个对象，一般按照对象字面量的方式生成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>上面这种方式，其实相当于系统内部执行 –&gt;new Object()</p>
<p>所以还可以用另一种方式声明，但是不要用 0.0：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>这两种方式其实是一样的，在控制台打印出来的<code>__proto__</code>指向相同，都是Object.prototype。</p>
<p>obj是通过字面量的形式生成的，访问构造器时一样返回Object构造函数：<br><img src="/images/20062601/js6/Image%5B15%5D.png" alt></p>
<p>根据上述知识点，得出结论：<br>构造函数Person.prototype有一个默认值 {}，这个默认值就是对象字面量，对象字面量的原型就是Object.prototype</p>
<p>原型链的对象终端：Person.prototype = {} –&gt; Object.prototype</p>
<h4 id="绝大多数对象的最终都会继承自Object-prototype"><a href="#绝大多数对象的最终都会继承自Object-prototype" class="headerlink" title="绝大多数对象的最终都会继承自Object.prototype"></a>绝大多数对象的最终都会继承自Object.prototype</h4><p>因为下面用null来创建对象的方法没有<code>__proto__</code>属性，所以不是继承自Object.prototype</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>并且不能自己给这个对象添加属性，即使硬性添加了，也无法打印<br><img src="/images/20062601/js6/Image%5B16%5D.png" alt></p>
<h4 id="Object-creat-prototype-：用于创建对象"><a href="#Object-creat-prototype-：用于创建对象" class="headerlink" title="Object.creat(prototype)：用于创建对象"></a>Object.creat(prototype)：用于创建对象</h4><p>参数：prototype必填项，并且只能是对象的原型(数据类型可以是：object、arr)和null<br>另一个参数：definedProperty，控制对象是否有可配置性</p>
<blockquote>
<p>一旦经过 var  操作的属性，目前针对window对象，这种属性就是不可配置的属性。不可配置的属性，无法用delete方法删除。</p>
</blockquote>
<p><img src="/images/20062601/js6/Image%5B17%5D.png" alt><br>obj1里的原型就是obj，Obj1.<code>__proto__</code>: demo.prototype</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);<span class="comment">// 空对象，没有`__proto__`，也就是没原型。</span></span><br><span class="line">obj.toString();<span class="comment">// 打印error，obj.toString is not a function</span></span><br></pre></td></tr></table></figure>

<p>obj对象没有toString方法，所以打印时报错。但是它依然是对象，可以添加属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">"sunny"</span>;<span class="comment">// 打印obj，Object &#123;name: sunny&#125;，展开依然没有`__proto__`.如下图：</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/20062601/js6/Image%5B18%5D.png" alt></p>
<p>手动给obj添加<code>__proto__</code>属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj2.<span class="string">`__proto__`</span> = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">// 结果见下图</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/20062601/js6/Image%5B19%5D.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj2.age);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>打印结果是undefined，说明手动给一个空对象添加<code>__proto__</code>属性和值是没有用的，系统不会读取。原型是系统内部隐式的存在，不能人为操作。可以修改，但是不能自己去创建。</p>
<h4 id="细说toString-方法"><a href="#细说toString-方法" class="headerlink" title="细说toString()方法"></a>细说toString()方法</h4><p>数字等可以调用toString()方法，因为它们能经过包装类去一层层的向上访问，包装类能包装起来是个对象，对象最终链的原型的终端就是Object.prototype，调用就是Object.prototype上的toString方法。</p>
<p>undefined、null 是原始值，没有原型。不是对象，也不能经过包装类，所以不能调用toString()方法。<br>只有undefined、null还有通过Object.create(null)创建的对象没有原型，也就不能调用toString()方法。</p>
<p>问题：那么toString是什么呢？使用时有哪些注意问题？<br>toString就是将变量都变为字符串类型的方法。</p>
<ol>
<li><p>数字必须存为一个变量，不能直接写成 123.toString() 的形式。因为数字后的点被当成了小数点，而数学符号优先级高于对象调用。所以系统认为这是一个浮点数，小数点后应该跟数字，所以跟了字母会认为是语法错误。</p>
<p> 例如：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">123.</span>toString();</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>; num.toString();</span><br></pre></td></tr></table></figure>
</li>
<li><p>数字调用的toString()方法，需要先经过包装类包装newNumber(数字).toString()。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">num.toString(); --&gt; <span class="keyword">new</span> <span class="built_in">Number</span>(num).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(num)的toString()方法，来自于<span class="built_in">Number</span>对象的原型上重写的方法。</span><br><span class="line"><span class="built_in">Number</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.prototype.`__proto__` = Object.prototype;</span></span><br></pre></td></tr></table></figure>

<p> 根据上面的代码，看出来这是个原型链，所以就会按照由近及远的规则来找。Number在找toString方法时在自己的原型上找到了，所以不会再去向上找了。</p>
<blockquote>
<p>重写：原型上是有该方法的，但是对象自身又重新写了同一个名字但不同功能的方法。叫做同一个名字的函数的不同重写方式。主要应用于后端的静态语言(java、c++)的重写，一个类里面有很多的方法，这些方法的名字、返回值、类型、形参列表都不一样，这个叫做真正的重写。</p>
</blockquote>
<blockquote>
<p>像下面的方式就是js内方法的重写：<br> Number的toString()方法定义于它自身的原型链：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Number本身也有原型，那么它也有Object.prototype上的toString方法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.<span class="string">`__proto__`</span> = <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p> <strong>重写，总得来说就是写出一个同样的名但是不同功能的方法。</strong></p>
<p> 在系统内将Number、Array、Boolean、String的方法都重写了，所以原始值在调用toString()时，调用的都是重写的方法，而不是Object.prototype上的方法<br> <img src="/images/20062601/js6/Image%5B20%5D.png" alt></p>
</li>
<li><p>对象调用的toString()方法，会返回[object Object]，这是因为对象的原型终端就是Object.prototype</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj4 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj4.toString());<span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.write在页面输出时，会先执行toString方法<br><img src="/images/20062601/js6/Image%5B21%5D.png" alt></p>
</li>
<li><p>JavaScript的小bug<br> 无法解决的bug，是JavaScript精度不准的问题。<br> 由于一点点偏差造成的，而这个偏差甚至可以忽略不计，但是结果影响却很大。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.14</span> * <span class="number">100</span>);<span class="comment">// 14.000000000000002</span></span><br></pre></td></tr></table></figure>

<p> JavaScript应该避免小数操作，即使要操作小数的话，也应该通过Math的方法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(); 向下取整</span><br><span class="line"><span class="built_in">Math</span>.ceil();   向上取整</span><br><span class="line"><span class="built_in">Math</span>.ceil();   随机数：<span class="number">0</span><span class="number">-1</span>开区间</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js6/Image%5B22%5D.png" alt></p>
<p> 计算浮点数时按照一个规则：先计算再取整。</p>
</li>
<li><p>JavaScript只能操作小数点后15位，小数点前16-17位？<br> 这是遗留下的bug，现在已经被修复了。<br> <strong>JavaScript可以操作小数点后的无数位，因为现在用科学技术法来表示。</strong><br> <img src="/images/20062601/js6/Image%5B23%5D.png" alt></p>
<p> 科学计数法：2.2e-17，意思是2.2*10的-17次方<br> <img src="/images/20062601/js6/Image%5B24%5D.png" alt></p>
<p> 上面的情况就不可以正常计算</p>
<p> 小数点前17位相加时，最后一位被砍掉了，所以JavaScript可以操作小数点前的16位。<br> <img src="/images/20062601/js6/Image%5B25%5D.png" alt></p>
<p> <strong>JavaScript可以正常计算的小数的取值范围：[16, 16]</strong></p>
</li>
</ol>
<h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call / apply"></a>call / apply</h3><h3 id="作用：改变this指向"><a href="#作用：改变this指向" class="headerlink" title="作用：改变this指向"></a>作用：改变this指向</h3><ol>
<li><p><strong>任何一个方法都可以执行.call方法</strong>，例如：<br> PersonFive();  –&gt;  PersonFive.call();</p>
<p> 执行构造函数PersonFive时，内部转化成了PersonFive.call()执行，这才是一个方法(函数)真实的执行方式。这两种写法是上一样的</p>
<p> 函数也是同理：<br> <img src="/images/20062601/js6/Image%5B26%5D.png" alt></p>
<p> 在执行PersonFive.call()时，将对象obj作为参数传进去。call就会引导着PersonFive发生变化。会<strong>将构造函数PersonFive内所有预设的this全部变成obj。</strong></p>
<p> <strong>在执行构造函数时，如果不通过new关键字来执行，那么this指向的是window(默认)</strong>。通过new来生成对象时，指向的是构造函数的原型。</p>
<p> 在执行构造函数时，如果通过call方法来执行，并向函数传一个空对象obj。那么构造函数PersonFive在执行时内部的this就不再是默认值window了，而是指定好的那个值(传进去的对象)</p>
<p> PersonFive内的this此时指向obj：<br> <img src="/images/20062601/js6/Image%5B27%5D.png" alt></p>
<p> 执行时传参， 第一位是指定的对象(改变this的指向)，第二位开始是与形参对应的实参：<br> <img src="/images/20062601/js6/Image%5B28%5D.png" alt></p>
<p> call的根本作用就是借用其他函数的方法来改变this指向，再通过所传参数生成自己的对象。借用他人方法实现自己的功能。</p>
</li>
<li><p><strong>避免重复编写相同代码：</strong><br> 企业开发时，调用其他人写好的模块生成自己的功能<br> <img src="/images/20062601/js6/Image%5B29%5D.png" alt></p>
</li>
</ol>
<h4 id="区别：后面传的参数形式不同"><a href="#区别：后面传的参数形式不同" class="headerlink" title="区别：后面传的参数形式不同"></a>区别：后面传的参数形式不同</h4><ol>
<li>call 除了第一位的对象，剩下的参数需要把实参按照形参的个数传进去</li>
<li>apply 第一位也是对象，只能传一个实参，并且只能是数组形式(传一个arguments)<br><img src="/images/20062601/js6/Image%5B30%5D.png" alt></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑨</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A8/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><span style="color: #f90d85">DOM</span>叫做 (<span style="color: #f90d85">Document Object Model</span>)文档对象模型</p>
<p><span style="color: #f90d85">DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。</span></p>
<p>DOM提供了一系列的方法，这些方法可以操作html和xml，但是不可以操作CSS。<br><span style="color: #b3b0b0;font-size: 14px">注：任何方法都无法操作CSS</span></p>
<blockquote>
<p>XML是什么？<br>XML和HTML本质上是同一个东西，XML是HTML最早的一个版本，先有的XML(也是脚本类的)，后来有了XHTML，最后有了HTML。XML最近这几年已经不用了，与HTML最大的区别是XML内的标签可以自定义。这个标签只能用作一种数据格式，</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// XML写成下面的格式就可以用来表示对象</span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>老邓<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>100<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #b3b0b0;font-size: 14px">student表示一个对象，标签内表示它的属性。这种具有属性的标签在HTML内是没有意义的，只表示一个行级元素，但是在数据的意义上，这种格式可以表示一个数据的集合，具有两个属性，在数据角度是有意义的。<br>在最开始的时候，所使用的的数据库，它的基本格式就是基于XML。<br>但是现在XML已经不再使用了，因为它被json所替代了，现在传输的格式都是JSON，以前传输的都是XML。</span></p>
<p>HTML和XML基本一致，只是HTML不能够自定义标签。</p>
<blockquote>
<p>什么是编程接口？<br>已知的方法与需要操作对象的连接点，就叫做接口。通过接口就可以来操作这些对象，编程接口就是一个实现途径。</p>
</blockquote>
<p>DOM不能改变CSS样式表的内容，但是可以通过间接的方式改变HTML的行间样式来改变它。 实际是操作了HTML的元素，直接给元素添加了一些信息，而这些信息就是CSS的样式，通过这样间接的 添加/修改 行间样式的方式来改变的，没有改变CSS样式表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM不能操作CSS样式表</span></span><br><span class="line"><span class="comment">// 但是可以操作HTML的元素的行间样式</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">    div.style.width = <span class="string">"100px"</span>;</span><br><span class="line">    div.style.height = <span class="string">"100px"</span>;</span><br><span class="line">    div.style.backgroundColor = <span class="string">"red"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h3><h4 id="节点的查看方法"><a href="#节点的查看方法" class="headerlink" title="节点的查看方法"></a>节点的查看方法</h4><ol>
<li>查看元素节点</li>
</ol>
<ul>
<li><p>document 是一个对象具有很多的方法，代表整个文档的js显示形式<br>  html标签只能代表文档的核心部分</p>
</li>
<li><p>document.getElementById()–&gt;元素id在IE8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"only"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div name="only"&gt;123&lt;/</span>div&gt;<span class="comment">// 针对IE8一下浏览器</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'only'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);<span class="comment">// &lt;div id="only"&gt;123&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.getElementsByTagName() –&gt; 通过标签名获取元素</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div);<span class="comment">// HTMLCollection [div#only, only: div#only]</span></span><br></pre></td></tr></table></figure>

<p>  1.得到的是一个类数组，无法调用数组的方法，但可以通过数组下标来获取元素<br>  2.最通用的方法，所有浏览器都支持并且没有兼容问题，IE4都可以正常使用<br>  3.参数是*时，可以选择所有的标签</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(all);<span class="comment">// &lt;html&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.getElementsByName() –&gt; 需注意只有部分标签name可生效（表单、表单元素、img、iframe）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementsByName(<span class="string">'fruit'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div2);<span class="comment">// NodeList [input]</span></span><br><span class="line"><span class="keyword">var</span> div3 = <span class="built_in">document</span>.getElementsByName(<span class="string">'abc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div3);<span class="comment">// NodeList [div]</span></span><br><span class="line"><span class="keyword">var</span> div4 = <span class="built_in">document</span>.getElementsByName(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div4);<span class="comment">// NodeList [p]</span></span><br></pre></td></tr></table></figure>

<p>  1.原本是只又表单内的标签具有name属性，用来传输数据<br>  2.<strong>现代浏览器所有的标签都支持通过name属性查找，但是之前版本的浏览器不支持</strong></p>
</li>
<li><p>document.getElementsByClassName() –&gt; 通过类名来获取元素<br>  缺点：IE8及IE8以下的IE版本中没有这个方法；可以多个class一起</p>
</li>
<li><p>document.querySelector() –&gt; css选择器，在IE7及以下版本中没有</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div4 = <span class="built_in">document</span>.querySelector(<span class="string">'div p span strong.demo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div4);<span class="comment">// &lt;strong class="demo"&gt;213&lt;/strong&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>document.querySelectorAll() –&gt; css选择器，在IE7及以下版本中没有</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div4 = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div p span strong.demo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div4);<span class="comment">// NodeList [strong.demo]</span></span><br></pre></td></tr></table></figure>

<p>  致命缺点：querySelector和querySelectorAll方法不是实时更新的，这两种方法选择的其实是元素的副本。如果想要讲元素的副本保存的话可以用这个方法，否则不建议。</p>
</li>
</ul>
<p>可以一次获取多个元素的方法，在获取元素后会封装到一个类数组内，所有的元素按照类数组的索引位进行排序。</p>
<p>想要选择出类数组内的一个元素时，可以通过下标的方式来获取。这样获取到的元素就被选到javascript中，就可以操作它了。这个元素其实就是一个对象，叫做DOM对象，跟对象的操作都是一样的，可以增删改查。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(div);<span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>给选择到的元素添加属性：<br>style：行间样式，跟css中的属性名用法基本一致，只是原本连接单词的符号”-“不能再使用，需要将属性写成小驼峰的格式。不能用”-“的原因是：在js中，不能用该符号当做属性名。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">div.style.width = <span class="string">"100px"</span>;</span><br><span class="line">div.style.height = <span class="string">"100px"</span>;</span><br><span class="line">div.style.backgroundColor = <span class="string">"red"</span>;</span><br></pre></td></tr></table></figure>

<p>有了DOM后，就可以动态的操作了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交互</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择方法除了ById是选择一个以外，其他方法选择出的是一个类数组。</p>
<p>实现选项卡切换功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">.wrapper div &#123;</span><br><span class="line">    display: none;</span><br><span class="line">    width: <span class="number">200</span>px;</span><br><span class="line">    height: <span class="number">200</span>px;</span><br><span class="line">    border: <span class="number">1</span>px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.active &#123;</span><br><span class="line">    background: darksalmon;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="wrapper"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button class="active"&gt;111&lt;/</span>button&gt;</span><br><span class="line">    &lt;button&gt;<span class="number">222</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button&gt;333&lt;/</span>button&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span> style=<span class="string">"display: block;"</span>&gt;成哥帅&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="content"&gt;邓哥...&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;成哥很帅&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// 选项卡</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'content'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btn.length; i ++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在绑定函数后，函数不被执行，所以i也不会被传到函数内</span></span><br><span class="line">        <span class="comment">// 执行事件时，在GO里得到i是3</span></span><br><span class="line">        btn[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; btn.length; j ++) &#123;</span><br><span class="line">                btn[j].className = <span class="string">""</span>;</span><br><span class="line">                wrapper[j].style.display = <span class="string">"none"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// btn[i].className = "active";// error</span></span><br><span class="line">            <span class="keyword">this</span>.className = <span class="string">"active"</span>;</span><br><span class="line">            wrapper[i].style.display = <span class="string">"block"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>遍历节点树<br> 任何一个浏览器都支持这个方法</p>
<ul>
<li><p>parentNode 父节点（最顶端的parentNode为#document）<br>  一个元素只有一个父级</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'demo'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(parent.parentNode);<span class="comment">// &lt;span&gt;...&lt;/span&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(parent.parentNode.parentNode.parentNode.</span><br><span class="line">parentNode.parentNode.parentNode);<span class="comment">// #document</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>childNodes</strong><br>  一个元素会有多个子级，其中包含文本节点、元素节点、注释节点等</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="number">123</span>weopriuqwoepriu</span><br><span class="line">    &lt;!-- <span class="keyword">this</span> is comment --&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;span&gt;</span><br><span class="line">            &lt;strong <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;<span class="number">213</span>&lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// 子节点</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(child.childNodes);<span class="comment">// 5个节点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>firstChild 第一个子节点</p>
</li>
<li><p>lastChild 最后一个子节点</p>
</li>
<li><p>nextSibling 后一个兄弟节点</p>
</li>
<li><p>previousSibling 前一个兄弟节点</p>
</li>
</ul>
</li>
<li><p>基于元素节点树的遍历<br> 除了children方法外，其他方法IE9及IE9以下都不兼容</p>
<ul>
<li>parentElement 返回当前元素的父元素节点（IE9及IE9以下不兼容）<br>  最顶端的parentElement为html元素节点，document不是元素节点</li>
<li>children 只返回当前元素的元素子节点</li>
<li>node.childElementCount === node.children.length 当前元素节点的子元素节点个数（IE9及IE9以下不兼容）</li>
<li>firstElementChild 返回的是第一个元素节点（IE9及IE9以下不兼容）</li>
<li>lastElementChild 返回的是最后一个元素节点（IE9及IE9以下不兼容）</li>
<li>nextElementSibling / previousElementSibling 返回后一个 / 前一个兄弟元素节点（IE9及IE9以下不兼容）</li>
</ul>
</li>
<li><p>节点的类型：</p>
<ul>
<li>元素节点：1</li>
<li>属性节点：2</li>
<li>文本节点：3</li>
<li>注释节点：8</li>
<li>documen：9</li>
<li>DocumentFragment：11</li>
</ul>
</li>
<li><p>节点的四个属性</p>
<ul>
<li>nodeName 元素的标签名，以大写形式表示，只读，字符串格式</li>
<li>nodeValue Text节点或comment节点的文本内容，可读写<br>  元素没有节点值，返回值为null</li>
<li>nodeType 该节点的类型，只读（参考4.节点的类型）通过这个属性可以知道元素节点的类型</li>
<li>attributes Element节点的属性集合</li>
</ul>
</li>
<li><p>判断一个元素是否有子节点Node.hasChildNodes(); 返回布尔值</p>
</li>
</ol>
<p>凡是提及IE不兼容，都是指代的IE9及IE9以下的浏览器，当时的浏览器只兼容一小部分。因为在IE10以后，它已经不是市场上占有率最大的浏览器了，从这个版本开始，IE开始全方位的支持W3C的标准，直到现在谷歌是市场占有率最大的浏览器。</p>
<p>IE6是历史上最特殊的浏览器，现在已经几乎被淘汰了。但是现在最难搞的是IE8浏览器，问题很多，它的bug一般都是流程化的bug。</p>
<h3 id="DOM结构树"><a href="#DOM结构树" class="headerlink" title="DOM结构树"></a>DOM结构树</h3><p>表示是一系列的继承关系<br><img src="/images/20062601/js9/Image.png" alt></p>
<ol>
<li><p>Document</p>
<ul>
<li><p>HTMLDocument</p>
<blockquote>
<p>上图中的Document与document之间的联系是什么？<br>答：document代表整个文档，Document是一个特殊的构造函数(首字母大写)，特殊点在于不可以通过new关键字来调用这个函数，这个方法是系统的预留方法。</p>
</blockquote>
<blockquote>
<p>既然不可以主动去调用这个方法，那么Document的用途是什么呢？<br>答：在构造函数上有一个属性叫做原型，可以被构造函数生产出来的对象所继承。在Document的原型上修改或添加属性，document也可以获取到最新的值，但是Document不是document的直接构造函数，而是HTMLDocument所构造的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.__proto__ = HTMLDocument.prototype;</span><br><span class="line">HTMLDocument.__proto__ = Document.prototype;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可得出：这是一个逐级继承的关系，最后形成了一条原型链。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span> --&gt; HTMLDocument.prototype --&gt; Document.prototype</span><br></pre></td></tr></table></figure>

<p>并且他们之间遵循就近原则。</p>
</li>
<li><p>XMLDocument<br>实际上Document的分支上应该包括HTMLDocument和XMLDocument.但是由于XMLDocument现在不再使用，所以可以忽略。</p>
<p>所以Document内的方法是HTMLDocument和XMLDocument都可以使用的。</p>
</li>
</ul>
</li>
<li><p>CharacterData</p>
<ul>
<li>Text 文本节点的方法是直接继承自Text.prototype</li>
<li>Comment 注释节点的方法是直接继承自Comment.prototype<br>一层一层向上找，一层一层的向上继承，最后形成了一条原型链</li>
</ul>
</li>
<li><p>Element</p>
<ul>
<li><p>HTMLElement</p>
<ul>
<li>HTMLHeadElement</li>
<li>HTMLBodyElement</li>
<li>HTMLTitleElement</li>
<li>HTMLParagraphElement</li>
<li>HTMLInputElement</li>
<li>HTMLTableElement</li>
<li>…etc.<br>上述对象代表的都是HTML文件内的标签对象，所使用的标签也都是首先继承自上述的标签对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTMLBodyElement.prototype.acb = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(body.acb);<span class="comment">// abc</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(head.acb);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>XMLElement</p>
</li>
</ul>
</li>
<li><p>Node，也是构造函数，是DOM结构树最顶端的对象。但<strong>Object.prototype是DOM元素原型的终端</strong>。<br> 可以使用toString()方法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.toString();<span class="comment">// [object HTMLBodyElement]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="DOM基本操作-1"><a href="#DOM基本操作-1" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h3><ol>
<li><p>getElementById方法定义在Document.prototype上，即Element节点上不能使用<br> 所有的HTMLDocument的元素都可以用，即document</p>
</li>
<li><p>getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document不能使用(如xml document, Element)</p>
</li>
<li><p>getElementsByTagName方法定义在Document.protype和Element.prototype上</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div7 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> span = div7.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(span);<span class="comment">// &lt;span&gt;&lt;/span&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTMLDocument.prototype定义了一些常用的属性，body,head分别指代HTML文档中的<body><head><meta name="generator" content="Hexo 3.9.0">标签<br> <span style="color: #b3b0b0;font-size: 14px">这样就可以直接使用，而不用再通过获取元素的方法了：</span></head></body></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">document</span>.body --&gt; <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line">    document.head --&gt; &lt;head&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Document.prototype上定义了documentElement属性，指点文档的根元素，在HTML文档中，它总是指代<html>元素</html></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">document</span>.documentElement --&gt; <span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getElementsByClassName、querySelector、querySelectorAll在Document.prototype, Element.prototype类中均有定义</p>
</li>
</ol>
<h3 id="DOM基本操作-–-增删改替"><a href="#DOM基本操作-–-增删改替" class="headerlink" title="DOM基本操作 – 增删改替"></a>DOM基本操作 – 增删改替</h3><ol>
<li><p>增加节点</p>
<ul>
<li><p><strong>document.createElement();</strong> 创建元素节点<br>  创建完成后需要加入到body标签内</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div8 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div8.innerHTML = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div8);<span class="comment">// &lt;div&gt;123&lt;/div&gt;</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div8);</span><br></pre></td></tr></table></figure>
</li>
<li><p>document.createTextNode(); 创建文本节点</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">'邓宝宝'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>document.createComment(); 创建注释节点</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createComment(<span class="string">'This is a comment!'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>document.createDocumentFragment(); 创建文档碎片节点</p>
</li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li>PARENTNODE.appendChild(); 任何一个元素节点都有这个方法<br>  ① 这个方法可以理解为push，将创建的元素插入到元素的最后<br>  ② 插入已存在元素时，是剪切操作，将已存在的元素剪切并粘贴至所选择元素内的末尾</li>
<li>PARENTNODE.insertBefore(a, b);<br>  ① 需要两个参数，在 b 之前插入元素 a，返回插入值 a<br>  ② 即使是执行了两次，也只会插入一次，因为是剪切操作。</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>paren.removeChild(); 是剪切操作</li>
<li>child.remove(); 是销毁操作</li>
</ul>
</li>
<li><p>替换</p>
<ul>
<li>parent.replaceChild(new, origin) 原本的origin是被剪切掉了<br>  用 new 替换 origin 的内容</li>
</ul>
</li>
</ol>
<h3 id="Element-节点的一些属性"><a href="#Element-节点的一些属性" class="headerlink" title="Element 节点的一些属性"></a>Element 节点的一些属性</h3><ol>
<li><p><strong>innerHTML</strong><br> ① 改变元素的 html 内容，可以进行读写</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">span.innerHTML = <span class="string">'123'</span>;</span><br><span class="line">span.innerHTML += <span class="string">"456"</span>;<span class="comment">// 追加赋值</span></span><br></pre></td></tr></table></figure>

<p> ② 可以写入html结构的字符串</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    span.innerHTML = <span class="string">"&lt;span style='background: red;</span></span><br><span class="line"><span class="string">font-size: 20px'&gt;123&lt;/span&gt;"</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js9/Image%5B1%5D.png" alt><br> 代码结果：<br> <img src="/images/20062601/js9/Image%5B2%5D.png" alt></p>
</li>
<li><p>innerText（旧版本火狐不兼容）/ textContent（火狐支持，但是老版本IE不好使）<br> 读取 / 修改元素的文本内容，在赋值时如果元素内有标签元素会被覆盖，仅建议修改文本赋值。<br> 原本代码：<br> <img src="/images/20062601/js9/Image%5B3%5D.png" alt><br> 修改innerText后：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">span.innerText = <span class="string">"789"</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js9/Image%5B4%5D.png" alt></p>
</li>
</ol>
<h3 id="Element-节点的一些方法"><a href="#Element-节点的一些方法" class="headerlink" title="Element 节点的一些方法"></a>Element 节点的一些方法</h3><ol>
<li>setAttribute(prop, value);<br> 给html设置一些行间样式</li>
<li>getAttribute(prop); <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">span.setAttribute(<span class="string">'class'</span>, <span class="string">'demo2'</span>);</span><br><span class="line">span.getAttribute(<span class="string">'class'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果修改元素的class名，直接通过className来读写。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><img src="/images/20062601/js9/Image%5B5%5D.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一题：在b之后插入a</span></span><br><span class="line">Element.prototype.**insertAfter **= <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sib = <span class="keyword">this</span>.nextElementSibling;</span><br><span class="line">    <span class="keyword">if</span>(sib) &#123;</span><br><span class="line">        <span class="comment">// 在b的下一个节点前插入a</span></span><br><span class="line">        sib.insertBefore(a, b);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当b是最后一个元素节点</span></span><br><span class="line">        <span class="keyword">this</span>.appendChild(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">newDiv.insertAfter(span2, span1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二题：子节点 逆序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseChildren</span>(<span class="params">parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = parent.childNodes,</span><br><span class="line">        len = nodes.length;</span><br><span class="line">    <span class="comment">// for(var i = len - 1; i &gt; 0; i --) &#123;</span></span><br><span class="line">    <span class="comment">//     parent.appendChild(nodes[i - 1]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        parent.appendChild(nodes[len - <span class="number">1</span>]);</span><br><span class="line">        len --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reverseChildren(newDiv);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript⑩</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E2%91%A9/</url>
    <content><![CDATA[<h2 id="Js基本语法"><a href="#Js基本语法" class="headerlink" title="Js基本语法"></a>Js基本语法</h2><h3 id="日期对象-Date"><a href="#日期对象-Date" class="headerlink" title="日期对象 Date()"></a>日期对象 Date()</h3><p>日期对象是系统提供的，只需要调用即可<br><span style="color: #b3b0b0;font-size: 14px">JS包括CSS、HTML都有自己的API文档，记录一些基础的功能和属性，作为一个字典来查阅。</span></p>
<p>Date() 返回日期的字符串</p>
<h4 id="Date-对象属性"><a href="#Date-对象属性" class="headerlink" title="Date 对象属性"></a>Date 对象属性</h4><ol>
<li>constructor<br><span style="color: #b3b0b0;font-size: 14px">constructor是对象的属性，prototype是构造函数的属性。</span></li>
</ol>
<h4 id="Date-对象方法-–-查看时间"><a href="#Date-对象方法-–-查看时间" class="headerlink" title="Date 对象方法 – 查看时间"></a>Date 对象方法 – 查看时间</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 记录date被赋值时当时的那一秒的值</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>date.getDate() 返回当前月的某一天（1-31）</p>
</li>
<li><p>date.getDay() 返回当前周的第几天，从周日开始算（0-6）</p>
</li>
<li><p>date.getMonth() 返回当前是第几个月（0-11）</p>
</li>
<li><p>date.getFullYear() 返回以四位数字返回当前年份<br> getYear() 不再使用，原始获取年的方法</p>
<p> <span style="color: #b3b0b0;font-size: 14px">后来才出现的getFullYear方法，JS是1996年随着navigator诞生的，最开始电脑出现后，日期是按照六位制设计的：前两位表示年，中间代表月，后两位是日。后期发展到金融系统、政府都使用计算机后，涉及到了很多金融问题和数据问题。至2000年时后无法正常进位，计算出现了错误。这个错误计算机2000年问题，又叫做“千年虫” ，后来年的就变为了四位表示方法。”万年虫”，哈哈哈哈哈</span></p>
</li>
<li><p>date.getHours() 返回对象的小时</p>
</li>
<li><p>date.getMinutes() 返回对象的分钟</p>
</li>
<li><p>date.getSeconds() 返回对象的秒钟</p>
</li>
<li><p>date.getMilliseconds() 返回对象的毫秒（0-999）</p>
</li>
<li><p>date.getTime() 返回自1970.01.01 00:00:00 至今的毫秒数，叫做获取<strong>时间戳</strong><br> 时间戳：就相当于一个时间轨道，在其中的某个点打了一个印记，记录下了这个时刻。时间戳往往作为唯一标识来使用，在通过Ajax传递数据时，想要多次调用同一个接口不引发浏览器的缓存机制，就利用时间戳来实现的。每次请求时的时间节点都不一样，那么请求得到的结果也不同。</p>
<p> <span style="color: #b3b0b0;font-size: 14px">年份的定义：是因为认为的定义了一个公元年，将这个年份叫作纪元，表示纪元初始的意思。将某一年设置为纪元年，在这一年之前的叫做公元前XX年，这一年之后的叫做公元后XX年，这样是为了便于统计年份。</span></p>
<p> <span style="color: #b3b0b0;font-size: 14px">由于计算机诞生的时间比较晚，计算机的时间没有办法按照人类的来定，所以人类就给计算机设置了一个纪元年，也叫作零点年，是计算机开始的时间。这个时间被叫做纪元时间。</span></p>
<p> <span style="color: #b3b0b0;font-size: 14px">现在互联网时间的计数方式：本地的时间会向一个服务器基站发起请求，上服务器基站里获取统一的最后一个电脑的时间。这台电脑是如何计算时间的呢，电脑无法知道当前时间，但是可以感知时间的变化，它始终都可以知道，它距离纪元时间大概有多少毫秒，再根据这个毫秒数进行计算现在距离纪元时间有多少年月日时分秒，再将格式转换为现在的时间格式，这个计算机始终都在通过这个毫秒数来计算的，通过这种动态的计算来返回时间，所有的分机向主机发送信号来获取它的时间。由此，所有的计算机、手机等设备的时间都是统一的。</span></p>
<p> 时间戳的作用：可以用来求时间差，从而确定时间间隔</p>
<p> <img src="/images/20062601/js10/Image.png" alt></p>
<p> 在进行开发时，通过时间差来判断这段代码的运行时间，从而来评定程序的效率，这种方法就是进行时间的优化。通过优化代码的方式来让程序的效率更高，运行时间最短。</p>
</li>
</ol>
<h4 id="Date-对象方法-–-设置时间"><a href="#Date-对象方法-–-设置时间" class="headerlink" title="Date 对象方法 – 设置时间"></a>Date 对象方法 – 设置时间</h4><p>一般用于给应用设置倒计时。</p>
<h4 id="Date-对象方法-–-字符串方法"><a href="#Date-对象方法-–-字符串方法" class="headerlink" title="Date 对象方法 – 字符串方法"></a>Date 对象方法 – 字符串方法</h4><ol>
<li><p>date.toString()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">date.toString();<span class="comment">// 相当于直接打印date的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>date.toTimeString()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">date.toTimeString();<span class="comment">// 打印出当前的时分秒和时区</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="js定时器"><a href="#js定时器" class="headerlink" title="js定时器"></a>js定时器</h3><h4 id="setInterval-匿名函数，间隔时间毫秒-定时循环器，每隔间隔时间执行函数"><a href="#setInterval-匿名函数，间隔时间毫秒-定时循环器，每隔间隔时间执行函数" class="headerlink" title="setInterval(匿名函数，间隔时间毫秒); 定时循环器，每隔间隔时间执行函数"></a>setInterval(匿名函数，间隔时间毫秒); 定时循环器，每隔间隔时间执行函数</h4><p>参数不一定非要是匿名函数，也可以写一些js语句，也可以执行，但是不推荐使用.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setInterval(<span class="string">"console.log('b')"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>setInterval被定义在window上，返回一个数字类型的值作为唯一标识。有了这个唯一标识，就可以将定时器清除了。</p>
<p>结论：定时器都是不准的<br><span style="color: #b3b0b0;font-size: 14px">不准的一部分原因： js有个js引擎，js引擎后面有个任务队列，它会把任务按照时间片去分解，把很多任务的片段排列好再放在队列里，队列依次向执行js引擎内输送。引擎是单线程的，同一时间只能执行一个片段，这样依次向里输送才能够执行任务。</span><br><span style="color: #b3b0b0;font-size: 14px">setInterval这个方法只能是每隔特定的时间，把待执行代码放在队列后面，具体什么时间执行是没办法保证的。这是它不准的其中一点，但是它不只是慢的问题，打印出的值有时多有时少，如果对数据结构有些了解的话，setInterval的排列机制是基于<a href="http://www.baidu.com/link?url=WIzkuHAotbcMsykZU84pKsjShCkYQNsl6C7Bry0O1AQ4TqLRUB14fVBAkUAiHJFt" target="_blank" rel="noopener">红黑树</a></span></p>
<h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout();"></a>setTimeout();</h4><p>延迟定时器，隔了间隔时间后执行且只执行一次，返回定时器的唯一标识<br>注意：当setInterval和setTimeout同时执行时，标识会依次增加，不会相同的</p>
<h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval();"></a>clearInterval();</h4><p>清除setInterval的定时器，参数是定时器返回的标识数</p>
<h4 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout();"></a>clearTimeout();</h4><p>间隔时间不能被后来改变。<br>上面的方法都是window上的方法，所以内部的this指向的是window.</p>
<p>—————————–重难点分割线——————————</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h3><p>滚动距离：在第一屏的基础上又增加了一定像素的屏幕</p>
<ol>
<li><p>window.pageXOffset/pageYOffset 求滚动条滚动距离<br> IE8及IE8以下不兼容(IE9是过度版本，部分兼容)</p>
</li>
<li><p>document.body.scrollLeft / scrollTop</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft / scrollTop</span><br></pre></td></tr></table></figure>

<p> 这两种方法用来解决IE不兼容问题，但是这里存在一个兼容性混乱的问题，导致IE的各个版本所支持的方法不相同。</p>
<p> 有一个规则：在任何一个浏览器上document.body.scrollXXX方法有值的话，另一个方法一定是0。这两个值是互相冲突的，不可能存在同时有值的情况。<br> 所以计算这个值的方法就是将两个值相加即可。</p>
<p> 上面的这几种方法chrome都兼容。</p>
</li>
<li><p>封装兼容性方法，可以求出当前滚动条滚动的距离</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 滚动距离</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 x,y</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.pageXOffset) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: <span class="built_in">window</span>.pageXOffset,</span><br><span class="line">            y: <span class="built_in">window</span>.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: <span class="built_in">document</span>.body.scrollLeft + <span class="built_in">document</span>.documentElement.scrollLeft,</span><br><span class="line">            y: <span class="built_in">document</span>.body.scrollTop + <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>在函数内，需要return一个对象类型的值时，对象的括号必须跟着return，否则系统会直接在return后加上分号，无法将对象返回。</strong></p>
<h3 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a>查看视口的尺寸</h3><p>可视区窗口：就是HTML文档部分可以看到的部分</p>
<ol>
<li><p>window.innerWidth / innerHeight<br> IE8及IE8以下不兼容<br> <span style="color: #b3b0b0;font-size: 14px">像素是相对单位，在不同的屏幕上大小不一，但是占用的像素是一样的。</span><br> <span style="color: #b3b0b0;font-size: 14px">一般情况下，浏览器的 window.innerWidth 这个值都是1440，原来的浏览器是960</span></p>
</li>
<li><p>document.documentElement.clientWidth / clientHeight<br> IE8及其以下兼容，但在标准模式下，任意浏览器都兼容</p>
</li>
<li><p>document.body.clientWidth / clientHeight<br> IE8及其以下兼容，但适用于怪异模式(非标准模式)下的浏览器</p>
<p> <span style="color: #b3b0b0;font-size: 14px">怪异模式：老版本的IE浏览器，它的每个版本之间都是有些差异的，会摒弃之前的一些东西，增加一些新的内容。所以浏览器不同版本之间的语法规则和所容纳的规范都不可能一样。在旧版本浏览器存在时，开发了一个项目，遵循的规则都是就旧浏览器的规则，之后出现了新版本，很多人都用新版本来浏览之前写的网站项目，这样的话就会产生冲突，网站没办法兼容新版本的一部分语法。那么想要解决这些问题，唯一的解决办法就是重写，这样会非常浪费效率。</span></p>
<p> <span style="color: #b3b0b0;font-size: 14px">后来大家就研究出了一个模式，即使是新版本浏览器(例如IE7)也可以访问给老版本浏览器(例如IE6)写的代码，它依然是可以按照IE6的规则去渲染这个页面。就是忽略了IE7版本的功能，将版本退回了IE6来正常识别这个页面。后来就是研究出了一个规则，让浏览器除了标准的渲染模式以外，还要有一种渲染模式叫做怪异模式。这个怪异模式的唯一一点用途就是”向后兼容”，这样就兼容了之前的语法规则。</span></p>
<p> <span style="color: #b3b0b0;font-size: 14px">渲染：浏览器识别这个语法，并且将它绘制成页面</span></p>
<p> 浏览器的渲染模式：<br> ① 标准模式<br> ② 怪异/混杂模式开启：去掉头部的<!DOCTYPE html></p>
<pre><code>DOCUTYPE: Document Type  Declaration文档类型，也叫DTD。目前是HTML5，写作：&lt;!DOCTYPE html&gt;</code></pre><p> 一旦启用了怪异模式，它所启用的语法就不是最新的语法，而是试图去兼容之前的语法。每个浏览器兼容的内容都不同，比如最新的谷歌浏览器可以向前兼容五个版本。</p>
<p> document.compatMode：用来判断是标准模式还是怪异模式</p>
<blockquote>
<p>返回 CSS1Compat 表示”标准模式”<br>返回 BackCompat 表示”怪异模式”，向后兼容</p>
</blockquote>
</li>
<li><p>封装兼容方法，返回浏览器视口尺寸</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 可视窗口尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.innerWidth) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            w : <span class="built_in">window</span>.innerWidth,</span><br><span class="line">            h : <span class="built_in">window</span>.innerHeight,</span><br><span class="line">            type : <span class="string">'normal'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容IE等不支持的浏览器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) &#123;</span><br><span class="line">            <span class="comment">// 怪异模式</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                w : <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">                h : <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">                type : <span class="string">'BackCompat'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标准模式</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                w : <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">                h : <span class="built_in">document</span>.documentElement.clientHeight,</span><br><span class="line">                type : <span class="string">'CSS1Compat'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getViewportOffset());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h3><ol>
<li><p>domEle.getBoundingClientRect();<br> 优点：兼容性很好<br> 缺点：返回的结果并不是”实时的”。获取到了值后即使元素发生改变，返回值也不变</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">demo.getBoundingClientRect();</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js10/Image%5B1%5D.png" alt></p>
<p> 该方法返回一个对象ClientRect，对象里面有width、height、left、top、right、bottom等属性。left、top代表该元素左上角的X和Y坐标，right、bottom代表元素右下角的X和Y坐标。</p>
<p> height和width属性，老版本IE并未实现，可以通过获取right-left，bottom-top的值来获取这两个值。</p>
</li>
<li><p>dom.offsetWidth、dom.offsetHeight<br> <strong>返回的是盒模型(content +padding + border)的大小，不包括margin</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素的宽高  正常元素 加了border   加了padding</span></span><br><span class="line">demo.offsetWidth;<span class="comment">// 100    102          302</span></span><br><span class="line">demo.offsetHeight;<span class="comment">//100    102          302</span></span><br></pre></td></tr></table></figure>

<p> 如果想要元素实际的大小(content)，可以通过间接访问css的方法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">demo.style.width;<span class="comment">// 仅能获取元素上style内的属性</span></span><br></pre></td></tr></table></figure>

<p> 因为得到的宽高跟domEle.getBoundingClientRect()这个方法是一样的，所以可以将其替换，这个方法更加方便。</p>
</li>
<li><p>dom.offsetLeft、dom.offsetTop<br> 忽略自身是否是定位元素，返回的值是与有定位的父级之间的距离<br> 总结：对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标</p>
<p> 多边形、多角形的距离是根据原来的元素的位置来确定的。</p>
</li>
<li><p>dom.offsetParent<br> 返回最近的有定位的父级，如果没有，返回body节点<br> body是父级的顶点，document.body.offsetParent;// body是顶点，返回null</p>
</li>
</ol>
<h3 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h3><p>window上存在下面的几种方法：</p>
<ol>
<li><p>scroll(x, y)  scrollTo() 滚动值某个点<br> x，y代表横向和纵向滚动到的位置，所以同一个语句多次执行也只执行一次</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p> 这两种方法用法都是一样，推荐使用第一个。</p>
</li>
<li><p>scrollBy() 累加滚动距离<br> x，y代表每次执行的距离，多次执行就会累加距离</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p> 值为负数时，向反方向移动。</p>
</li>
</ol>
<p>—————————–重难点分割线 end——————————</p>
<h2 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h2><p>脚本化：控制</p>
<h3 id="读写元素css属性：dom间接控制css属性"><a href="#读写元素css属性：dom间接控制css属性" class="headerlink" title="读写元素css属性：dom间接控制css属性"></a><strong>读写元素css属性</strong>：dom间接控制css属性</h3><ol>
<li><p>dom.style.prop<br> style属性普遍存在于任何dom元素上，仅该方法可以写入属性的值</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(div.style);<span class="comment">// 打印的值是下图</span></span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js10/Image%5B2%5D.png" alt><br> ① CSSStyleDeclaration 叫做样式表，返回的是一个dom元素的所有css属性，这个值是一个类数组，有索引类的属性和正常类的属性，并且还有length属性。在dom元素上设置了值的属性才会有值并且按照数组的形式展示<br> ② 特点：</p>
<ul>
<li><p>可读写<strong>行间样式</strong>，间接改变CSS，修改后页面样式立刻生效 类数组本身其实是个对象，对象是可读写、可修改的。</p>
</li>
<li><p>没有兼容性问题，碰到float这样的保留字属性，前面应加css 直接写float也是可以的，但是W3C标准里建议写成eg: float –&gt; cssFloat的格式 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style.cssFloat = <span class="string">"right"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合属性必须拆解，组合单词变成小驼峰式写法<br><span style="color: #b3b0b0;font-size: 14px">复合属性以前是不可以的，但是现在可以。例如border可以拆解为 border-width border-style border-color<br>js内的变量的命名规则：只能是数字、下划线、字母、$符号</span></p>
</li>
<li><p>写入的值必须是字符串格式</p>
</li>
</ul>
</li>
</ol>
<h3 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h3><ol>
<li><p>window.getComputedStyle( ele, null );</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(div[<span class="number">0</span>], <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p> <img src="/images/20062601/js10/Image%5B3%5D.png" alt><br> ① 也是类数组，上一个方法中没有设置值的属性的值为””，而该方法中未设置值的属性也有默认值。<br> ② 获取的是当前元素所展示的一切CSS属性的显示值 <span style="color: #b3b0b0;font-size: 14px">同一个元素的属性设置了多个值时，根据权重，仅展示最后生效的那个值</span></p>
</li>
<li><p>特点：<br> 计算样式只读，无法修改<br> <img src="/images/20062601/js10/Image%5B4%5D.png" alt></p>
<p> 返回的计算样式的值都是绝对值，没有相对单位 例如：颜色会转化为rgb的形式</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(div[<span class="number">1</span>], <span class="literal">null</span>).backgroundColor;</span><br><span class="line">打印：rgb(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p> IE8及IE8以下不兼容</p>
</li>
<li><p>99.999%都不会的知识点</p>
<blockquote>
<p>这个方法的第二个参数为什么是null?<br>答：第二个参数可以用来获取伪元素的样式表，但仅限于获取，没有赋值方法</p>
</blockquote>
<blockquote>
<p>获取一个伪元素的width属性，再赋值给其他元素。js没有方法是用来获取伪元素的，而且伪元素本身就是可以设置但是不可以获取的存在。后来通过侯老师的帮助，知道了 getComputedStyle 方法的第二个参数可以获取伪元素的样式表，才成功解决这个问题。非常厉害！</p>
</blockquote>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div::after &#123;</span><br><span class="line">    content: <span class="string">""</span>;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: <span class="number">50</span>px;</span><br><span class="line">    height: <span class="number">50</span>px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(div[<span class="number">0</span>], <span class="string">"after"</span>).width;<span class="comment">// 50px;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="查询样式-主要针对IE不兼容个问题"><a href="#查询样式-主要针对IE不兼容个问题" class="headerlink" title="查询样式 (主要针对IE不兼容个问题)"></a>查询样式 (主要针对IE不兼容个问题)</h3><ol>
<li><p>ele.currentStyle.prop<br> 跟 window.getComputedStyle( ele, null ); 方法是一样的用法和意义</p>
<p> 计算样式只读<br> 返回的计算样式的值不是经过转换的绝对值  例如单位em、百分数等就是原来的值，根据权重，不经转化的最终展示出来的值<br> IE独有的属性，其他浏览器使用会报错</p>
</li>
</ol>
<h3 id="封装兼容性方法-getStyle"><a href="#封装兼容性方法-getStyle" class="headerlink" title="封装兼容性方法 getStyle"></a>封装兼容性方法 getStyle</h3><p>意义：通过dom.style.prop方法获取的属性，仅限于行间样式，并不好用，可以用于赋值操作。通过获取元素的最终样式的值，才有意义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 元素最终样式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">elem, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.getComputedStyle(elem, <span class="literal">null</span>)[prop];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elem.currentStyle[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h3><ol>
<li><p>伪元素的操作需求<br> 需要修改伪元素的样式时，可以先设置不同的class名的伪元素，通过修改元素的className来实现修改伪元素的样式。</p>
<p> 同理，在更改元素的样式时，不使用dom.style.prop的方法来修改，而是通过修改className来修改元素的样式。</p>
<p> 这样做的<strong>优势</strong>：</p>
<ul>
<li><p>提升效率<br>如果操作DOM是JS要和HTML搭建一个桥梁，每一次操作就是一个来回，消耗效率。从代码上来看，这样减少了操作次数，也就是相应的提升了效率<br><img src="/images/20062601/js10/Image%5B5%5D.png" alt></p>
</li>
<li><p>好维护<br>如果想要增加样式，直接在JS内修改的话就需要依次操作每个属性，不好维护还麻烦。如果通过CSS来设置好元素的状态，直接通过切换className来切换元素的当前状态即可，叫做修改状态位。</p>
</li>
</ul>
<p> <strong>短板</strong>：只能修改静态的效果，如果是动态的元素，就需要通过dom.style.prop的方法来修改了。</p>
</li>
<li><p>父级是定位元素，子级的属性left、top不设置值时，它的默认值是auto，不是0。<br> 不是0的原因：如果是0的话，它应该处于文档的最开始(0, 0)的位置，但是定位元素会跟随它的定位父级共同移动。</p>
<p> 所以一般都需要设置一个值，为0；</p>
</li>
</ol>
<!-- 相信成哥~ -->]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JavaScript事件</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JavaScript%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>交互：触动页面的元素后会有相应的反馈<br>事件：实现交互核心的技术点，由两部分构成，需要绑定元素 和 触发事件时执行的函数</p>
<h3 id="绑定事件处理函数"><a href="#绑定事件处理函数" class="headerlink" title="绑定事件处理函数"></a>绑定事件处理函数</h3><p>绑定事件的三种方法：</p>
<ol>
<li><p>ele.onxxx = function  (event) { }</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在div元素的onclick事件上，绑定一个处理函数</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// this指向div元素</span></span><br><span class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 优点：兼容性很好 是最早用来处理事件、绑定函数的方法，实际上就是给一个对象新增方法(或者说给对象的属性赋值) </p>
<p> 缺点：一个元素的同一个事件上只能绑定一个 如果给一个元素绑定多个click事件，只会执行最后一个，原因是给对象的属性赋值时只能生效一次，多次赋值会覆盖之前的值</p>
<p> 基本等同于写在HTML行间上 通过”on+类型”绑定事件的方式叫做：句柄的绑定方法（绑定到元素上执行）</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background-color: red;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">onclick</span>=<span class="string">"console.log(this)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>obj.addEventListener(type, fn, false);<br> 缺点：IE9以下不兼容 W3C标准<br> 优点：可以为一个事件绑定多个处理程序</p>
<p> 事件实际上是有着监听属性的，一直处于等待执行的状态。执行这个事件不是JS引擎来直接执行的， 而是像 setInterval 一样被放到队列中等待执行</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function匿名函数是函数引用，跟写一个外部函数名是一样的</span></span><br><span class="line">div[<span class="number">1</span>].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 指向div;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定多个函数时，按照绑定顺序来执行</span></span><br><span class="line"><span class="comment">// 能给同一个对象的同一个事件绑定多个处理函数</span></span><br><span class="line"><span class="comment">// 虽然写成匿名函数的写法，但是和上面的事件被看做两个不同的函数</span></span><br><span class="line">div[<span class="number">1</span>].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 指向div</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法是默认了test函数为同一个函数，所以只会执行一次</span></span><br><span class="line"><span class="comment">// 所以，不建议重复绑定同一个函数多次</span></span><br><span class="line">div[<span class="number">2</span>].addEventListener(<span class="string">'click'</span>, test, <span class="literal">false</span>);</span><br><span class="line">div[<span class="number">2</span>].addEventListener(<span class="string">'click'</span>, test, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>obj.attachEvent(“on” + type, fn);<br> IE独有，一个事件同样可以绑定多个处理程序</p>
<p> 与addEventListener方法基本是一致的，唯一的不同是只有两个参数。在运行上，也可以给一个元素绑定多个事件，并且同一个元素绑定同一事件的同一个函数多次也可执行多次。</p>
<p> 第三个参数即使写了也不会报错，这是函数传参的特点，可以接受多个实参</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div[<span class="number">2</span>].attachEvent(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指向window</span></span><br><span class="line">    handle.call(div[<span class="number">2</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指向div[2]</span></span><br><span class="line">    <span class="keyword">this</span>.style.width = <span class="string">"200px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>绑定事件如果在循环内，在匿名函数内查看是否用到了循环参数 i ，如果用到了一定要注意是否形成了闭包，如果是闭包，就要用立即执行函数来处理。</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; li.length; i ++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        li[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"我是第"</span> + (i + <span class="number">1</span>) + <span class="string">"位"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 绑定事件的机制：添加属性</p>
<blockquote>
<p>机制的意思是原理、本质，绑定事件的机制也就是指绑定事件实现的原理。</p>
</blockquote>
</li>
</ol>
<h3 id="事件处理程序的运行环境"><a href="#事件处理程序的运行环境" class="headerlink" title="事件处理程序的运行环境"></a>事件处理程序的运行环境</h3><p>运行环境实际上就是函数内的this指向问题。</p>
<ol>
<li><p>ele.onxxx = function  (event) { }<br> 程序this指向的是<strong>dom元素本身</strong></p>
</li>
<li><p>obj.addEventListener(type, fn, false);<br> 程序this指向的是<strong>dom元素本身</strong></p>
</li>
<li><p>obj.attachEvent(“on” + type, fn);<br> 程序this指向的是<strong>window</strong></p>
<p> 改变 attachEvent 方法的 this 指向，不指向 window 而是指向操作 dom 自己</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指向dom自己</span></span><br><span class="line">div[<span class="number">2</span>].attachEvent(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指向window</span></span><br><span class="line">    handle.call(div[<span class="number">2</span>]);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指向div[2]</span></span><br><span class="line">    <span class="keyword">this</span>.style.width = <span class="string">"200px"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="封装兼容函数-重点"><a href="#封装兼容函数-重点" class="headerlink" title="封装兼容函数(重点)"></a>封装兼容函数(重点)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 绑定事件</span></span><br><span class="line"><span class="comment">// 给一个dom对象添加该事件类型的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elem, type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(type, handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.attachEvent) &#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        elem[<span class="string">'on'</span> + type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解除事件处理程序"><a href="#解除事件处理程序" class="headerlink" title="解除事件处理程序"></a>解除事件处理程序</h3><ol>
<li>ele.onclick = false/ ‘’/ null;</li>
<li>ele.removeEventListener(type, fn, false);</li>
<li>ele.detachEvent(‘on’ + type, fn);<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 解绑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">elem, type, handle, isBubble</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(type, handle, isBubble);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ele.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(<span class="string">'on'</span>+ type, handle);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        elem[<span class="string">'on'</span>+ type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>解除绑定的机制： 添加属性</p>
<p>若绑定匿名函数，则无法解除</p>
<p>绑定事件是绑定一个对象的 特定的事件类型 的 特定的处理函数，解除也要解除相对应的。<br>解除绑定：事件类型要对应、处理函数是同一个(相同引用)、是否捕获的参数的值要一致，所以在解除事件的绑定函数时，函数必须写成函数声明的形式，匿名函数是没办法解除的，因为系统默认这是不同的匿名函数。</p>
<p>应用：下载页面的下载按钮，只允许点击下载一次，之后就不允许再次点击</p>
<h2 id="事件处理模型"><a href="#事件处理模型" class="headerlink" title="事件处理模型"></a>事件处理模型</h2><p>事件处理模型：一个元素针对这个事件的处理方式</p>
<p>分为两类：冒泡(常规模型)、捕获(非常规模型)</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）</p>
<p>通俗理解<span style="color: #b3b0b0;font-size: 14px">（说人话）</span>：结构上存在父子关系的元素， 它们事件触发的顺序：如果事件是在子元素上触发的，它会一级一级的向上传递这个事件。所以从代码的视觉上来讲是自底向上的。</p>
<p>比喻说法：执行当前事件时，会像水泡一样一层一层的向上冒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'wrapper'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'content'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wrapper'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">content.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'box'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>点击最里层子元素(黄色部分)：从子元素向外执行的顺序<br><img src="/images/20062601/event/Image.png" alt><br><img src="/images/20062601/event/Image%5B1%5D.png" alt></p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下）</p>
<p>在W3C制定标准时，仅在Chrome上可以生效，因为当时只有Chrome做了这个功能。</p>
<p>IE上没有事件捕获</p>
<p>最新版本的FireFox、Opera上都有”事件捕获”，但是老版本的没有，因为最新版本的内核都有渗透一些webkit内核(成哥说了，webkit确实好，嘻嘻嘻)。</p>
<p>实现方式：修改addEventListener的第三个参数为true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wrapper'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">content.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'box'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>点击最里层子元素(黄色部分)：从父级向子元素执行的顺序<br><img src="/images/20062601/event/Image%5B2%5D.png" alt></p>
<p>注意：事件冒泡是从子级向父级执行的顺序，事件捕获是父级向子级执行的顺序，子级本身执行时就叫做事件执行，而它的父级在执行时才叫做冒泡或者捕获。</p>
<p>一个对象的一个事件类型，上面绑定的一个处理函数只能遵循一种事件处理模型，要么是冒泡，要么是捕获。</p>
<p>如果给同一个对象的同一个事件类型，同时绑定两个事件处理函数，一个是事件捕获模型，另一个是事件冒泡模型。那么它们的执行顺序是：<strong>先捕获后冒泡</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wrapperBubble'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">content.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'contentBubble'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'boxBubble'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 捕获</span></span><br><span class="line">wrapper.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wrapper'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line">content.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'box'</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：先从父级开始执行事件捕获，在执行到子元素box时是事件执行，遵循先绑定先执行的顺序，执行box的绑定方法时就打印出’boxBubble’、’box’的结果。执行完后，父级执行事件冒泡。<br><img src="/images/20062601/event/Image%5B3%5D.png" alt></p>
<p>focus，blur，change，submit，reset，select等事件不冒泡(也不应该存在冒泡事件)</p>
<p>事件冒泡的应用：事件委托</p>
<h3 id="取消冒泡和阻止默认事件"><a href="#取消冒泡和阻止默认事件" class="headerlink" title="取消冒泡和阻止默认事件"></a>取消冒泡和阻止默认事件</h3><p>取消原因：不绑定事件处理函数依然冒泡</p>
<p>事件对象：在每一个事件处理函数内都有一个形参event，这是一个系统默认传递的值，这个值就是事件对象。事件对象有很多的属性，每一个属性都记载了这个事件发生时的一系列关键性数据，例如 事件类型、事件时刻、鼠标的坐标点等。</p>
<h4 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.stopPropagation(); <span class="comment">// W3C标准 不支持IE9以下版本</span></span><br><span class="line">event.cancelBubble = <span class="literal">true</span>; <span class="comment">// 曾经IE独有的，现在Chrome也有了</span></span><br></pre></td></tr></table></figure>

<p>封装取消冒泡的函数 stopBubble(event)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 阻止事件冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.stopPropagation) &#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><p>默认事件 – 表单提交，a标签跳转，右键菜单等</p>
<ol>
<li><p>return false;<br> 兼容性非常好，用于最原始的绑定方法(句柄式绑定方法)<br> 以对象属性的方式注册的时间才生效，例如:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> addEventListener、attachEvent都不生效</p>
</li>
<li><p>event.preventDefault();<br> W3C标注，IE9一下不兼容<br> onclick、addEventListener、attachEvent都生效</p>
</li>
<li><p>event.returnValue = false;<br> 兼容IE、Chrome也可以用</p>
</li>
</ol>
<p>封装阻止默认事件的函数 cancelHandler(event); 封装函数内没有return false;是因为一个函数执行返回false的话就没有意义了，无法阻止默认事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容 阻止默认事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.preventDefault) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTPS 安全超文本传输协议(Hypertext Transfer Protocol Secure)网站协议平台<br>应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// href内是#时，点击a标签回到页面顶部</span></span><br><span class="line">&lt;a href=<span class="string">"#"</span>&gt;linka&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ href内的javascript叫做协议限定符，后面可以写JS代码</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ void相当于写return，void(0/</span><span class="literal">false</span>)就相当于<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">// 这样的方式也可以阻止a标签的默认事件</span></span><br><span class="line">&lt;a href=<span class="string">"javascript:void(false)"</span>&gt;linka1&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 通过阻止默认事件来阻止a标签跳转或者回到顶部</span></span><br><span class="line"><span class="regexp">var a = document.getElementsByTagName('a')[0];</span></span><br><span class="line"><span class="regexp">a.onclick = function(e) &#123;</span></span><br><span class="line"><span class="regexp">    cancelHandler(e);/</span><span class="regexp">/ 点击后不会跳转，网页地址后也不会加上"#"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在非IE浏览器下，系统会将事件对象作为形参传到事件绑定的函数内。在IE浏览器中，函数内的这个对象会失效，它是被记录在window.event上。</p>
<h3 id="event-window-event"><a href="#event-window-event" class="headerlink" title="event || window.event;"></a>event || window.event;</h3><p>事件触发后的事件对象的兼容写法</p>
<h3 id="事件源对象"><a href="#事件源对象" class="headerlink" title="事件源对象"></a>事件源对象</h3><ul>
<li><p>包含很多属性：<br>  cancelBubble 默认false，<br>  clientX、clientY 鼠标点击触发事件时的坐标点，<br>  returnValue 默认true，<br>  <strong>srcElement 指向当前执行操作的事件源对象</strong> IE仅有、Chrome也有，<br>  <strong>target 指向当前执行操作的事件源对象</strong> 火狐仅有、Chrome也有，</p>
</li>
<li><p>兼容写法：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wrapper.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><h3 id="事件委托-1"><a href="#事件委托-1" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡的机制和事件源对象进行处理</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能 不需要循环所有的元素一个个绑定事件</li>
<li>灵活 当有新的子元素时不需要重新绑定事件</li>
</ol>
<h3 id="委托实例"><a href="#委托实例" class="headerlink" title="委托实例"></a>委托实例</h3><p>ul 内有 n 多个 li，点击 li 输出内容（从此告别for循环的绑定噩梦~）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span><br><span class="line"><span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.innerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>扫雷每个点绑定事件</p>
<blockquote>
<p>捕获执行事件的元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dom.setCapture(); <span class="comment">// 仅限IE 即使超出了dom元素的范围，也会看做是dom执行的</span></span><br><span class="line">dom.releaseCapture(); <span class="comment">// 释放事件</span></span><br></pre></td></tr></table></figure>

<h2 id="事件分类-–-鼠标事件"><a href="#事件分类-–-鼠标事件" class="headerlink" title="事件分类 – 鼠标事件"></a>事件分类 – 鼠标事件</h2><ul>
<li><p>鼠标事件：click、mousedown、mousemove、mouseup、contextmenu(右键菜单)、mouseover、mouseout、mouseenter、mouseleave<br>  在浏览器页面点击鼠标右键会出现菜单，这个是一个单独的事件就叫做右键出菜单事件</p>
</li>
<li><p>mousedown、mouseup、click之间的关系<br>  执行顺序：mousedown –&gt; mouseup –&gt; click</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">click = mousedown + mouseup;</span><br></pre></td></tr></table></figure>

<p>  移动端没有这几个方法取代的是：touchstart、touchmove、touchend</p>
</li>
<li><p>mouseover、mouseout 旧版本方法<br>  mouseenter、mouseleave 新版本方法</p>
<p>  CSS中的hover方法就是利用这个方法实现的。</p>
<blockquote>
<p>HTML、CSS都有一定的JS代码。</p>
</blockquote>
</li>
<li><p>区分鼠标的左右键<br>  仅mouseup、mousedown这两种方法可以区分左右键</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区分鼠标左右键</span></span><br><span class="line">div[<span class="number">1</span>].onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性button返回左右键的值</span></span><br><span class="line">    <span class="comment">// 0：左键 2：右键 1：中间滚轮</span></span><br><span class="line">    <span class="keyword">if</span>(e.button == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'right'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.button == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'left'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  DOM3标准规定：click事件只能监听左键(无法触发右键的事件)，只能通过mousedown和mouseup来判断鼠标键</p>
</li>
</ul>
<h2 id="键盘类事件"><a href="#键盘类事件" class="headerlink" title="键盘类事件"></a>键盘类事件</h2><ul>
<li><p>keydown、keyup、keypress<br>  执行顺序：keydown –&gt; keypress –&gt; keyup</p>
</li>
<li><p>keydow和keypress的区别<br>  keydown 可以响应任意键盘按键，没有chrtCode的值，监测字符类的键盘事件是不准确的</p>
<p>  keypress只可以相应字符类键盘按键，返回ASCII码，可以转换成相应字符</p>
<p>  charCode转为字符：String.fromCharCode(e.charCode);</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.charCode);<span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.which);<span class="comment">// 键盘位置编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.charCode);<span class="comment">// ASCII码</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.which);<span class="comment">// 键盘位置编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> str = <span class="built_in">String</span>.fromCharCode(e.charCode);<span class="comment">// charCode转为字符</span></span><br><span class="line">    <span class="built_in">console</span>.log(str);<span class="comment">// 字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  应用：贪吃蛇</p>
</li>
</ul>
<h2 id="文本操作事件-input、focus、blur、change"><a href="#文本操作事件-input、focus、blur、change" class="headerlink" title="文本操作事件 - input、focus、blur、change"></a>文本操作事件 - input、focus、blur、change</h2><p>focus：聚焦<br>blur：失焦<br>input：只要输入框内的内容发生改变，就会执行该事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>];</span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>change：鼠标在聚焦和失焦时，内容发生改变时，就会触发该事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索框聚焦与失焦内容变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"请输入关键字"</span> style=<span class="string">"color: #999;"</span> </span><br><span class="line">onfocus=<span class="string">"if(this.value=='请输入关键字')&#123;this.value='';this.style.color='#424242'&#125;"</span> </span><br><span class="line">onblur=<span class="string">"if(this.value=='')&#123;this.value='请输入关键字';this.style.color='#999'&#125;"</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="窗体操作类（window上的事件）"><a href="#窗体操作类（window上的事件）" class="headerlink" title="窗体操作类（window上的事件）"></a>窗体操作类（window上的事件）</h2><h3 id="scroll：滚动条滚动时触发事件。window上的事件"><a href="#scroll：滚动条滚动时触发事件。window上的事件" class="headerlink" title="scroll：滚动条滚动时触发事件。window上的事件"></a>scroll：滚动条滚动时触发事件。window上的事件</h3><h3 id="load：页面元素加载完成后触发"><a href="#load：页面元素加载完成后触发" class="headerlink" title="load：页面元素加载完成后触发"></a>load：页面元素加载完成后触发</h3><p>页面在读取到js的代码时，会阻断页面，所以js的代码要写在页面最底端。<br>解决办法：window.onload</p>
<!-- IE6没有fixed定位方法
     使用absolute来实现fixed的方法： -->

<h3 id="浏览器有时间限制，在访问一个页面时先请求服务器，将文件下载到本地，然后一行一行的加载、解析、执行。"><a href="#浏览器有时间限制，在访问一个页面时先请求服务器，将文件下载到本地，然后一行一行的加载、解析、执行。" class="headerlink" title="浏览器有时间限制，在访问一个页面时先请求服务器，将文件下载到本地，然后一行一行的加载、解析、执行。"></a>浏览器有时间限制，在访问一个页面时先请求服务器，将文件下载到本地，然后一行一行的加载、解析、执行。</h3><p>在一行一行的解析代码时，html和css是并行一起被解析的，html在解析时会形成domTree(dom树)，css会形成cssTree</p>
<p>domTree：在解析html代码时，根据当前dom结构 document –&gt; html –&gt; head、body–&gt;element</p>
<p>domTree和cssTree合并后形成新的树，叫做渲染树renderTree。渲染树以dom树为结构，树上的每个元素有被定义好的css样式属性，renderTree形成后就开始按照renderTree进行页面渲染</p>
<p>dom节点解析就是识别当前元素的类型，例如img标签会先在dom树上挂起来，不会直接去它的地址获取这个图片。所以，先解析元素，再异步的下载数据。</p>
<h3 id="页面内的javascript代码写在html代码后的好处"><a href="#页面内的javascript代码写在html代码后的好处" class="headerlink" title="页面内的javascript代码写在html代码后的好处"></a>页面内的javascript代码写在html代码后的好处</h3><p>在页面dom元素解析完成后，就可以立即执行js代码，不需要等待下载完成。</p>
<p>如果写成window.onload的形式，这时候就需要等待一个状态，整个文档解析完成后，renderTree构建完成后，Dom内所有的文档、文字、内容、信息、图片下载完成后，才会执行这个事件。这样的写法缺点就是效率是最低的，但是优点是可以判断什么时候页面是完全加载完成的。</p>
<p><img src="/images/20062601/event/Image%5B4%5D.png" alt><br>扫雷容易出现闭包问题</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-JSON</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-JSON/</url>
    <content><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）</p>
<p>是一种前后端进行交互的一种手段，发送和接受的数据格式应该都是可互相识别和使用的。<br>最开始的时候是以xml这个格式的语言来传送数据的，xml和html相同点是都是脚本语言，区别在于xml可以自定义标签，利用这一特点，可以将标签写成数据的格式。</p>
<p><img src="/images/20062601/JSON/Image.png" alt><br>上图实际就是模拟对象的格式，后来就用对象来传递数据，叫做json。</p>
<p>json与对象人为规定的明显区别，属性名要加上双引号。</p>
<p>传输数据时，无法直接传递一个对象，这个是无法识别的。前后端传递的是二进制文本格式的值，其实就是JSON格式的字符串(字符串内是json)。<br><img src="/images/20062601/JSON/Image%5B1%5D.png" alt><br>后端获取到字符串的json后再通过特殊的语法将其解析为正常的json格式，拿到数据。</p>
<h3 id="JSON-parse-string-–-gt-json"><a href="#JSON-parse-string-–-gt-json" class="headerlink" title="JSON.parse(); string –&gt; json"></a>JSON.parse(); string –&gt; json</h3><p>JSON是一种静态类，类似Math可以直接调用它的方法</p>
<h3 id="JSON-stringify-json-–-gt-string"><a href="#JSON-stringify-json-–-gt-string" class="headerlink" title="JSON.stringify(); json –&gt; string"></a>JSON.stringify(); json –&gt; string</h3><h2 id="异步加载JS"><a href="#异步加载JS" class="headerlink" title="异步加载JS"></a>异步加载JS</h2><p>要知道一个方法为什么是这样的，以及为什么这样用</p>
<h3 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h3><p>html、css、js它们符合一些特定的格式，在一个html页面上并写了一些css代码，最后会将页面展示出来，此时页面已经绘制完成。</p>
<p>绘制：浏览器的渲染引擎，以一个像素(1px)为单位一行一行的绘制页面，就像3D打印一样，一层一层的执行</p>
<blockquote>
<p>那么页面的html和css是怎么联系在一起，怎么执行的呢？<br>答：浏览器的内核是不认识html元素和css样式的，内核会对页面进行检索，首先先一行一行的识别html代码，然后将这些元素挂在一个树上，形成树形结构。也就是识别html代码的每一个节点放在树形结构对应的位置上，根据节点的排列方式来绘制出一个dom节点的属性结构，就叫做<strong>domTree</strong></p>
</blockquote>
<h4 id="domTree"><a href="#domTree" class="headerlink" title="domTree"></a>domTree</h4><p>绘制出的dom树符合“深度优先”的原则。</p>
<p>深度优先：形成树的过程，不是按照平级的结构来识别的，而是识别到一个dom节点有子元素的话，就会看识别子元素，不会去管兄弟元素。一条枝干走到头后，再去看其他枝干。</p>
<p><img src="/images/20062601/JSON/Image%5B2%5D.png" alt></p>
<p>生成dom树的过程，叫做dom节点的解析，就是只要识别了当前的标签是什么即可，不需要等到它的内容加载完成。例如在解析到img标签时，浏览器将它挂载在dom树上可以同时让它下载内容。</p>
<p>因为上述原因，可得dom树的完成代表着所有节点的解析完毕，不代表所有节点加载完毕。这是一个异步(同时)发生的过程。</p>
<h4 id="cssTree"><a href="#cssTree" class="headerlink" title="cssTree"></a>cssTree</h4><p>根据css样式，生成跟dom节点对应的树，叫做css树。原则也是“深度优先”</p>
<h4 id="rendertTree"><a href="#rendertTree" class="headerlink" title="rendertTree"></a>rendertTree</h4><p>dom树在生成之后会一直处于等待状态，直到css树生成之后合并，生成rendertTree渲染树。当renderTree生成了之后，浏览器的渲染引擎才会按照renderTree的内容开始绘制页面。</p>
<p>在绘制页面的过程中，js可以动态的改变dom结构和间接的影响css的内容。由于renderTree是页面绘制的最后依据，如果改变了当前的dom结构(删除、增加节点)，renderTree就需要重新构建，此时整个页面就会重新绘制，从代码的第一行开始直到最后，这样会浪费效率。这里就涉及到了dom优化的问题，避免dom节点的添加和删除等操作。</p>
<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>renderTree的重建，叫做<strong>reflow重构</strong>(重排)，这个在dom操作里是效率最低的。</p>
<p>触发重构的方式：<br>    1. dom节点的增加和删除<br>    2. dom节点的宽高变化（一个元素改变了大小，会影响后面元素的位置，所以会造成重新渲染的问题）、位置变化(display属性的值：none变成block)<br>    3. offsetWidth和offsetHeight（调用这个方法时，计算节点的宽高会遵循一个原则：浏览器会将renderTree重新构建一遍，再重新渲染页面，这样才能实时的保证计算出的结果是实时的）<br>    (还有其他方法，暂且了解这些)</p>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>改变元素的css样式就会造成<strong>repaint重绘</strong>， 浪费的效率少</p>
<p>改变元素的一些除了宽高位置的属性时，会重绘，不会造成页面重构。</p>
<h2 id="异步加载JS-1"><a href="#异步加载JS-1" class="headerlink" title="异步加载JS"></a>异步加载JS</h2><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>js是同步加载的，可以阻断html和css的加载线，只有Js执行完了才会继续向下执行。</p>
<p>js无法和html、css同步执行的原因是，js可以修改html、css。如果同步的话，还没加载就已经被修改了。</p>
<p>js是单线程的原因也是因为可以修改html、css，如果是多线程的话，一个线程增加，一个线程删除，那么就无法确定执行的线程了。</p>
<h3 id="js加载的缺点"><a href="#js加载的缺点" class="headerlink" title="js加载的缺点"></a>js加载的缺点</h3><p>加载工具方法没必要阻塞文档，过多的加载js会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作</p>
<h3 id="有些工具方法需要按需加载，用到再加载，不用不加载。"><a href="#有些工具方法需要按需加载，用到再加载，不用不加载。" class="headerlink" title="有些工具方法需要按需加载，用到再加载，不用不加载。"></a>有些工具方法需要按需加载，用到再加载，不用不加载。</h3><p>有一些script文件是一个工具包，工具包内都是function方法，不调用的时候不执行，也不会影响页面，这样的工具包是希望被并行的加载进来的。如果页面的js都是同步的，会阻塞后续页面的，当有很多个这样的js工具包时，如果有一个js工具包出现了1k（一个数据量）的误差的话，也就说有一个数据量没有下载成功，网络阻塞了，后面的所有文件都下载不了了，那么整个页面就故障了。</p>
<p>网页在刚打开时会有一段时间的留白，这个时间加载都是js文件，当js文件没下载完成时，后续的页面文件都处于等待的状态，只有js文件都下载成功后，后续页面才会同时下载html和css，并且绘制页面。</p>
<h3 id="javascript-异步加载的三种方案"><a href="#javascript-异步加载的三种方案" class="headerlink" title="javascript 异步加载的三种方案"></a>javascript 异步加载的三种方案</h3><ol>
<li>defer 异步加载，可以和html和css一起下载，但要等到dom文档全部解析完才会被执行。只有IE9以下能用，也可以将代码写到内部。 <!-- 异步写法： -->
 内部写代码：<br> <img src="/images/20062601/JSON/Image%5B3%5D.png" alt></li>
<li>async 异步加载，加载完就执行(执行是异步执行)，async 只能加载外部脚本，不能把js写在script标签里。W3C标准方法，IE9以上等现代浏览器都可以用。<br> 异步写法：<br> <img src="/images/20062601/JSON/Image%5B4%5D.png" alt><br> ajax：读法(阿贾克斯)<br> <img src="/images/20062601/JSON/Image%5B5%5D.png" alt></li>
</ol>
<p>上面两种方法1、2在执行时也不阻塞页面<br>兼容性问题：不可以写两个并列的标签，因为执行顺序不同，不可控。</p>
<ol start="3">
<li><p>创建script，插入到DOM中，加载完毕后callBack。<br> 优点：可以异步执行、可以按需加载、兼容性好(W3C标准)<br> <img src="/images/20062601/JSON/Image%5B6%5D.png" alt></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">** demo.js **</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = <span class="string">"demo.js"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用时会报错，因为js文件还没加载完成</span></span><br><span class="line">    test();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> load方法，可以解决js文件还未下载完成就执行的问题：<br> 兼容问题：IE的script标签没有load事件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">** demo.js **</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = <span class="string">"demo.js"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用load方法，可以在加载完成时触发</span></span><br><span class="line">    <span class="comment">// 兼容Sarafi Chrome FireFox Opera，除了IE</span></span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">    <span class="comment">// 直接调用时会报错，因为js文件还没加载完成</span></span><br><span class="line">    <span class="comment">// test(); 报错not defined</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 解决IE不兼容问题：readyState 状态码，最开始的默认值是”loading”，跟着script标签加载进度动态改变这个值，如果加载完成的话会将值改成”complete”或着”loaded”。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    script.src = <span class="string">"demo.js"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(script.readyState == <span class="string">'complete'</span> || script.readyState == <span class="string">'loaded'</span>) &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> <span style="color: #b3b0b0;font-size: 14px">事件处理函数：也叫作 callback 回调函数，当满足一定条件才执行的函数。</span></p>
<p> 异步加载的兼容写法：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(script.readyState) &#123;</span><br><span class="line">        <span class="comment">// 兼容IE</span></span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(script.readyState == <span class="string">'complete'</span> || script.readyState == <span class="string">'loaded'</span>) &#123;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先绑定事件，再加载文件</span></span><br><span class="line">    <span class="comment">// 放在绑定事件之后再赋值，是为了防止当加载过快而不经过上面的判断的情况</span></span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在这里直接调用的话，先预编译函数再执行函数，这时传的test参数还未下载成功，</span></span><br><span class="line"><span class="comment">// 所以会报错 not defined</span></span><br><span class="line"><span class="comment">// loadScript('demo.js', test);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确调用写法：将要执行的函数放在匿名函数内，不会解析内部所以不会报错</span></span><br><span class="line">loadScript(<span class="string">'demo.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行时调用匿名函数时，才会调用test方法</span></span><br><span class="line">    test();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 上面调用函数的写法写的非常麻烦，最后的写法应该：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">** demo.js **</span><br><span class="line"><span class="keyword">var</span> tools = &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 函数 loadScript ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(script.readyState) &#123;</span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(script.readyState == <span class="string">'complete'</span> || script.readyState == <span class="string">'loaded'</span>) &#123;</span><br><span class="line">                <span class="comment">// callback();</span></span><br><span class="line">                tools[callback]();<span class="comment">// 按需加载按需调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// callback();</span></span><br><span class="line">            tools[callback]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法，最终正确写法</span></span><br><span class="line">loadScript(<span class="string">'demo.js'</span>, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="js加载时间线"><a href="#js加载时间线" class="headerlink" title="js加载时间线"></a>js加载时间线</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>是一个理论依据，根据浏览器出生的那一刻开始，记录的一系列浏览器按顺序执行的操作。</p>
<p><span style="color: #b3b0b0;font-size: 14px">浏览器在运行一个页面时会初始化js的功能，在完成初始化的那一刻，就开始记载这一系列浏览器接下来要发生的过程。js加载时间线就是用来形容这一过程的执行顺序。</span></p>
<ol>
<li><p>创建Document对象(document)，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = “loading”。</p>
</li>
<li><p>遇到link引入的外部css，创建新的线程加载，并继续解析文档。</p>
</li>
<li><p>遇到script标签加载外部js，并且没有设置async、defer(同步加载)，浏览器加载，并阻塞整个页面，等待js加载完成并执行该脚本，然后继续解析文档。</p>
</li>
<li><p>遇到script标签加载外部js，并且设置有async、defer(异步加载)，浏览器创建新的线程加载，并继续解析文档(不会阻塞文档解析)。对于async属性的脚本，脚本加载完成后立即执行(defer属性的脚本，要等到解析完成才执行)（异步加载的js，<strong>禁止使用document.write()</strong>方法）<br> <span style="color: #b3b0b0;font-size: 14px">document.write(); 将括号内的内容写入文档内。如果在文档解析完成前执行，会将之前文档流的内容清除，并代替写入括号内的值。</span><br> a. 直接执行：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">"width:100px;height:100px;background-color:red;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 直接执行，在标签后插入</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p> 结果：<br> <img src="/images/20062601/JSON/Image%5B7%5D.png" alt></p>
<p> 解析顺序：先解析HTML文档 –&gt; CSS文档 –&gt; renderTree构建完成但是还没开始完全的绘制文档，只是将元素的宽高和位置定好了。这时执行document.write()操作时，会将其内容当做文档流输出到页面里面去。</p>
<p> b. 文档渲染完成后执行：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解析顺序：此时的document.write()具有消除文档流的作用，所以将元素清除后，将它的内容插入页面</p>
</li>
<li><p>遇到img标签等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</p>
</li>
<li><p>当文档解析完成(此时domTree刚刚建立完)，document.readyState = “interactive”(interactive 活跃的)。</p>
</li>
<li><p>文档解析完成后(实际是与第6步同时发生的)，所有设置有defer(defer 推迟)的脚本会按照(出生)顺序执行。（注意与async的不同，但同样禁止使用document.write()方法）</p>
</li>
<li><p>document对象触发DOMContentLoaded事件，这也标志着程序执行从”同步脚本”执行阶段(脚本同步执行会堵塞程序)，转化为事件驱动阶段(浏览器可以监听事件)。<br> 只有文档解析完成后，浏览器可以识别事件，可以正常的执行</p>
</li>
<li><p>当所有async的脚本加载完成并执行后、img等加载完成后(此时页面内所有的内容下载并执行完毕)，document.readyState = “complete”，window对象触发load事件。</p>
</li>
<li><p>从此，以异步响应方式处理用户输入、网络事件等。</p>
</li>
</ol>
<p>总结来说：</p>
<ol>
<li>创建时间线(步骤1)</li>
<li>文档解析完(步骤2、3、4、5)</li>
<li>文档解析完并且加载完执行完了(9)</li>
</ol>
<p>script标签也是dom节点，只有当所有dom节点解析完成之后才算解析完成，readyState的值才会变，所以下面第一个值打印出的结果是 loading</p>
<p>window.onload事件是全部文档都加载完成后触发，所以下面第二个值打印出的结果是 complete</p>
<p>onreadystatechange事件是在document.readyState这个值发生改变时被触发。所以下面第三个值打印出的结果是 interactive 和 complete。loading是初始值不被打印</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);<span class="comment">// loading</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);<span class="comment">// complete</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);<span class="comment">// interactive complete</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #b3b0b0;font-size: 14px">事件的名字都是小写，这是跟属性之间的区别。</span></p>
<p>onreadystatechange：当dom解析完再执行，script标签的位置也不是必须写在页尾了(但是仍然建议写在页尾，这样效率最快)。在仅支持addEventListener这种方法调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>DOMContentLoaded与window.onload方法的区别：DOMContentLoaded更快，当文档解析完就会执行。不需要等到所有内容都下载完再执行，这样非常浪费效率，并且如果使用window.onload时，有一张图片未加载成功，都不会继续向下执行代码，会影响整个页面。</p>
<p>jQuery中的$(doucment).ready(function(){})方法依据的原理就是DOMContentLoaded和 onreadystatechange。</p>
]]></content>
  </entry>
  <entry>
    <title>前端之路的基石-正则表达式</title>
    <url>/2018/12/23/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><h3 id="转义字符串"><a href="#转义字符串" class="headerlink" title="转义字符串"></a>转义字符串</h3><ul>
<li>符号“\”后的那个字符会失去原来的意义，变成字符。</li>
<li>转义符号在字符串中不会被打印出来</li>
<li>转义符号可以转义自己本身<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"sld\"kfj"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// sld"kfj</span></span><br><span class="line">str = <span class="string">"sld\\kfj"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// sld\kfj</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ul>
<li>符号“\”与特定的字母相组合时，会变成特殊字符（注意：doucment.write()写入文档不生效，而是变成文字分隔符）</li>
<li>\n是换行符、\r是行结束  在底层的操作系统内，回车是由”\r\n”组成的。Linex系统内只有”\n”</li>
<li>\t是table的缩写，表示缩进符 键盘上的tab键也是table的缩写，表示缩进制表符。一般情况下，一个缩进表示四个空格<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"sld\r\nkfj"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// sld</span></span><br><span class="line">                  <span class="comment">// kfj</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(str);<span class="comment">// sld kfj</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">"sld\tkfj"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// "sld   kfj"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><ul>
<li><p>意义：在编程上让字符串换行，使代码变得可维护。\n 是针对结果进行换行，没有意义</p>
</li>
<li><p>系统规定，字符串不可以多行显示，否则会报语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">"</span></span><br><span class="line"><span class="string">    &lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">"</span>;</span><br></pre></td></tr></table></figure>

<p>  报错：<img src="/images/20062601/RegExp/Image.png" alt></p>
</li>
<li><p>在文本形式的换行字符的行末尾添加换行符“\”，可以使行尾的文本形式的回车转义掉，不再有回车的功能，这样就可以使字符串代码换行展示，并且不报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newStr = innerHTML = <span class="string">"\</span></span><br><span class="line"><span class="string">    &lt;div&gt;&lt;/div&gt;\</span></span><br><span class="line"><span class="string">    &lt;span&gt;&lt;/span&gt;\</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newStr);</span><br><span class="line"><span class="comment">// 结果："            &lt;div&gt;&lt;/div&gt;            &lt;span&gt;&lt;/span&gt;        "</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他办法：字符串拼接的形式，通过“+”来连接每行的字符，这样写比较low</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newStr = innerHTML =</span><br><span class="line">    <span class="string">"&lt;div&gt;&lt;/div&gt;"</span> +</span><br><span class="line">    <span class="string">"&lt;span&gt;&lt;/span&gt;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newStr);<span class="comment">// &lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式 RegExp"></a>正则表达式 RegExp</h2><h3 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h3><p>匹配特殊字符或有特殊搭配原则的字符的最佳选择</p>
<p>每门语言都有正则表达式，用法几乎都是相同的。但是js提供了一些独有的方法用于正则。</p>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><h4 id="字面量-（推荐！）"><a href="#字面量-（推荐！）" class="headerlink" title="字面量 （推荐！）"></a>字面量 （推荐！）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'abcd'</span>));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>正则表达式的属性：<br> ① i：ignoreCase 忽略大小写<br> ② g：global 全局匹配（将所有匹配的值都返回）<br> ③ m：多行匹配</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'ABCD'</span>));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认匹配方式：匹配第一个</span></span><br><span class="line"><span class="keyword">var</span> matchReg = <span class="regexp">/asdf/</span>;</span><br><span class="line"><span class="keyword">var</span> matchStr = <span class="string">'asdfasdfasdfasdfasdfasdfasdf'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(matchStr.match(matchReg));<span class="comment">// ["asdf", index: 0, input: "asdfasdfasdfasdfasdfasdfasdf", groups: undefined]</span></span><br><span class="line"><span class="comment">// 全部匹配</span></span><br><span class="line"><span class="keyword">var</span> matchReg1 = <span class="regexp">/asdf/g</span>;</span><br><span class="line"><span class="keyword">var</span> matchStr1 = <span class="string">'asdfasdfasdfasdfasdfasdfasdf'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(matchStr1.match(matchReg1));<span class="comment">// ["asdf", "asdf", "asdf", "asdf", "asdf", "asdf", "asdf"]</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m：可以匹配到换行的字符</span></span><br><span class="line"><span class="keyword">var</span> mReg = <span class="regexp">/^a/gm</span>;<span class="comment">// 匹配到所有开头的'a'</span></span><br><span class="line"><span class="keyword">var</span> mStr = <span class="string">'ababababab\nabab'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mStr.match(mReg));<span class="comment">// ["a", "a"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的方法：匹配字符<br> ① test：布尔值，返回是否有与正则表达式校验相匹配的字符串</p>
</li>
<li><p>字符串的方法；匹配字符<br> ① match：数组，默认只返回第一个符合的片段</p>
</li>
</ol>
<h4 id="new-RegExp-规则，属性"><a href="#new-RegExp-规则，属性" class="headerlink" title="new RegExp(规则，属性)"></a>new RegExp(规则，属性)</h4><p>规则：字符串类型、也可以是已有的规则(字面量类型的)<br>属性：”i”、”g”、”m”等字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/i</span>;</span><br><span class="line"><span class="keyword">var</span> newReg = <span class="built_in">RegExp</span>(reg);</span><br><span class="line"><span class="built_in">console</span>.log(reg);<span class="comment">// /abc/i</span></span><br><span class="line"><span class="built_in">console</span>.log(newReg);<span class="comment">// /abc/i</span></span><br><span class="line"><span class="comment">// 这里的newReg和reg打印出来是同样的值、但两个不同的对象</span></span><br></pre></td></tr></table></figure>

<h4 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别"></a>两种方法的区别</h4><ol>
<li><p>正常状态：通过 new 关键字生成的正则表达式，虽然是通过字面量生成的，但是字面量之间互不影响</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/i</span>;</span><br><span class="line"><span class="keyword">var</span> newReg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg);</span><br><span class="line">reg.abc = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newReg.abc);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非正常状态：不通过 new 关键字生成的正则表达式，实际上与字面量表达式指向相同的地址，他们之间会相互影响（一般不用，用了的话成哥说可以赞美他）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newReg1 = <span class="built_in">RegExp</span>(reg);</span><br><span class="line">reg.abc = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newReg1.abc);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="一个字符代表一位，内容就是取值范围"><a href="#一个字符代表一位，内容就是取值范围" class="headerlink" title="[ ] 一个字符代表一位，内容就是取值范围"></a>[ ] 一个字符代表一位，内容就是取值范围</h4><ol>
<li>0-9：表示数字从0到9</li>
<li>a-z：表示小写字母a到z</li>
<li>A-Z：表示大写字母A到Z</li>
<li>A-z：表示从大写字母A到小写字母z，根据ASCII码</li>
<li>[^]：符号^放在中括号[ ]内时，表示非。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/[ab][cd][d]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2.match(reg2));<span class="comment">// ["bcd"]</span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/[0-9A-Za-z][cd][d]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">"ab1cd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str3.match(reg3));<span class="comment">// ["1cd"]</span></span><br><span class="line"><span class="keyword">var</span> reg4 = <span class="regexp">/[^a][^b]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str4 = <span class="string">"ab1cd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str4.match(reg4));<span class="comment">// ["b1", "cd"]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="：括号-内的值表示特定的字符区间"><a href="#：括号-内的值表示特定的字符区间" class="headerlink" title="( )：括号( )内的值表示特定的字符区间"></a>( )：括号( )内的值表示特定的字符区间</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg5 = <span class="regexp">/(abc|bcd)[0-9]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str5 = <span class="string">"bcd2"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str5.match(reg5));<span class="comment">// ["bcd2"]</span></span><br></pre></td></tr></table></figure>

<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>实际上与表达式是一样的用途，但是使用时更加简洁<br><span style="color: #b3b0b0;font-size: 14px">特点：效率恐怖，代码风骚，哈哈哈哈哈</span></p>
<ul>
<li><p>\w word字母字符，代表一位字符，完全等于<strong>[0-9A-z_]</strong></p>
</li>
<li><p>\W 是\w的补集，<strong>[^\w]</strong></p>
</li>
<li><p>\d [0-9]</p>
</li>
<li><p>\D [^0-9]</p>
</li>
<li><p>在表达式内也可以写元字符</p>
</li>
<li><p>\s 包含空格在内的所有空白字符，共六个（\n 换行符、\f 换页符、\r 回车符、\t 制表符、\v 垂直制表符）</p>
</li>
<li><p>空格在正则表达式内就写” “空格来表示</p>
</li>
<li><p>\S [^\s]</p>
</li>
<li><p>\b 单词边界</p>
</li>
<li><p>\B 非单词边界</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reg6 = /\bcde\B/g;</span><br><span class="line">var str6 = &quot;abc cdefgh&quot;;</span><br><span class="line">console.log(str6.match(reg6));// [&quot;cde&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>\t 只能匹配\t这样写法的字符，直接给字符串缩进的写法会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg7 = <span class="regexp">/\tcde/g</span>;</span><br><span class="line"><span class="keyword">var</span> str7 = <span class="string">"abc    cdefgh"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str7.match(reg7));<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg7 = <span class="regexp">/\tcde/g</span>;</span><br><span class="line"><span class="keyword">var</span> str7 = <span class="string">"abc\tcdefgh"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str7.match(reg7));<span class="comment">// [" cde"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>\t 换行符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg8 = <span class="regexp">/\ncde/g</span>;</span><br><span class="line"><span class="keyword">var</span> str8 = <span class="string">"abc\ncdefgh"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str8.match(reg8));<span class="comment">// ["↵cde"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制</p>
<ol>
<li><p>\uxxxx 十六进制的四位数的Unicode编码，包含汉字在内的一切字符<br> 例如：<code>\u0000</code><br> 和ASCII码作用相同，一个unicode编码对应一个字符，只是ASCII码可以对应一些特殊字符</p>
</li>
<li><p>\uxxxxxx 十六进制的六位数<br> 区间：它的每一位进制都具有特定的区间，前两位代表层级数，后四位代表unicode编码的范围<br> 例如：<br> \u010000 - \u01ffff 第一层<br> \u100000 - \u10ffff 第十六层</p>
<p> 若取值区间取为：[\u0000 - \uffff] 可以取一切字符，代表all<br> 其他方法：[\s\S]、[\d\D] 原有和的补集再加上自己，也代表all</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicode转码</span></span><br><span class="line"><span class="keyword">var</span> reg9 = <span class="regexp">/\u8001\u9093\u8eab\u4f53\u597d/g</span>;</span><br><span class="line"><span class="keyword">var</span> str9 = <span class="string">"老邓身体好"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str9.match(reg9));<span class="comment">// ["老邓身体好"]</span></span><br><span class="line"><span class="comment">// 表示一个范围</span></span><br><span class="line"><span class="keyword">var</span> reg10 = <span class="regexp">/[\u3000-\ua000]/g</span>;</span><br><span class="line"><span class="keyword">var</span> str10 = <span class="string">"老邓身体好"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str10.match(reg10));<span class="comment">// ["老", "邓", "身", "体", "好"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>字符”.”：查找单个字符，除了换行和行结束符，全等于[^\r\n]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg11 = <span class="regexp">/./g</span>;</span><br><span class="line"><span class="keyword">var</span> str11 = <span class="string">"老邓身体好"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str11.match(reg11));<span class="comment">// ["老", "邓", "身", "体", "好"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>量词：代表数量的词，个数<br>表示匹配字符的个数：n * 个数</p>
<ul>
<li><p>n+ 从1到正无穷 {1，infinity}</p>
</li>
<li><p>n*  从0到正无穷 {0，infinity}<br>  匹配原则：</p>
<ol>
<li>贪婪匹配原则：尽可能的多匹配，最后考虑0的情况<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regExp = <span class="regexp">/\w+/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr.match(regExp));<span class="comment">// ["abc"]</span></span><br><span class="line"><span class="keyword">var</span> regExp1 = <span class="regexp">/\w*/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr1 = <span class="string">"abc;"</span>;</span><br><span class="line"><span class="comment">// 结果是三个值原因：取到第一个值后，由于是全局匹配，所以并没有结束匹配，而是在逻辑上还有一段距离。当*是0时，匹配到的就是空，所以会匹配出空字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(regExpStr1.match(regExp1));<span class="comment">// ["abc", "", ""]</span></span><br><span class="line"><span class="keyword">var</span> regExp2 = <span class="regexp">/\d*/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr2 = <span class="string">"abc;"</span>;</span><br><span class="line"><span class="comment">// 根据光标定位点来决定返回的数量</span></span><br><span class="line"><span class="built_in">console</span>.log(regExpStr2.match(regExp2));<span class="comment">// ["", "", "", "", ""]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>n?  从0到1 {0，1}</p>
</li>
<li><p>n{X} 表示匹配X个字符</p>
</li>
<li><p>n{x,y} 从x到y {x,y}，先判断是否有y个数的值再依次看向x个数的值（贪婪匹配原则）</p>
</li>
<li><p>n{x, } 从x到infinity正无穷 {x, }</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regExp3 = <span class="regexp">/\w?/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr3 = <span class="string">"abc;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr3.match(regExp3));<span class="comment">// ["a", "b", "c", "", ""]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regExp4 = <span class="regexp">/\w&#123;3&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr4 = <span class="string">"abc;"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr4.match(regExp4));<span class="comment">// ["abc"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regExp5 = <span class="regexp">/\w&#123;3,5&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr5 = <span class="string">"aaaaaaaaaaaaaaaaa"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr5.match(regExp5));<span class="comment">// ["aaaa    a", "aaaaa", "aaaaa"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="结尾符和开头符"><a href="#结尾符和开头符" class="headerlink" title="结尾符和开头符"></a>结尾符和开头符</h3><ul>
<li>$ 匹配以$前的字符为结尾的字符，受属性m的影响可以多行匹配</li>
<li>^ 匹配以^后的字符为开始的字符，与$一起使用时，有限制字符的作用  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regExp6 = <span class="regexp">/ef$/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr6 = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr6.match(regExp6));<span class="comment">// ["ef"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regExp7 = <span class="regexp">/^abc$/g</span>;</span><br><span class="line"><span class="keyword">var</span> regExpStr7 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regExpStr7.match(regExp7));<span class="comment">// ["abc"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>写一个正则表达式，检验字符串首尾是否含有数字(首部或者尾部有数字即可)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testReg = <span class="regexp">/^\d|\d$/g</span>;</span><br><span class="line"><span class="keyword">var</span> testReg = <span class="regexp">/^\d[\s\S]*\d$/g</span>; --&gt; 首尾都有数字，通过[\s\S]*来匹配所有字符</span><br><span class="line"><span class="keyword">var</span> testStr = <span class="string">"12lkj0984lk3423 j3"</span>;</span><br><span class="line"><span class="comment">// 返回第一个查到的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(testStr.match(testReg));<span class="comment">// ["1", index: 0, input: "12lkj0984lk3423 j3", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(testReg.test(testStr));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h3><ul>
<li>global 是否全局</li>
<li>ignoreCase 是否忽略大小写</li>
<li>lastIndex 获取到字符后的下标位置</li>
<li>multiline  是否多行匹配</li>
<li>source 表达式的内容<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(testReg.global);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(testReg.ignoreCase);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(testReg.lastIndex);<span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(testReg.multiline);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(testReg.source);<span class="comment">// 正则表达式的内容：^\d[\s\S]*\d$</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h3><ul>
<li><p>test</p>
</li>
<li><p><strong>exec</strong> 执行的意思</p>
<ol>
<li><p>在有全局g属性时，多次执行打印结果会依次将结果打印出来，且lastIndex随每次打印而移动光标位置</p>
</li>
<li><p>在没有全局属性时，只执行一次</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> execReg = <span class="regexp">/ab/g</span>;</span><br><span class="line"><span class="keyword">var</span> execStr = <span class="string">"abababab"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execReg.lastIndex);<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// ["ab", index: 0, input: "abababab", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.lastIndex);<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// ["ab", index: 2, input: "abababab", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// ["ab", index: 4, input: "abababab", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// ["ab", index: 6, input: "abababab", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg.exec(execStr));<span class="comment">// ["ab", index: 0, input: "abababab", groups: undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>符号”()+数字”表示反向引用数字位的子表达式( )内的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> execReg1 = <span class="regexp">/(\w)\1(\w)\2/g</span>;<span class="comment">// 第一位表达式和第二位</span></span><br><span class="line"><span class="keyword">var</span> execStr1 = <span class="string">"aabb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execStr1.match(execReg1));<span class="comment">// ["aabb"]</span></span><br><span class="line"><span class="built_in">console</span>.log(execReg1.exec(execStr1));<span class="comment">// ["aabb", "a", "b", index: 0, input: "aabb", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用exec方法时，得到的类数组中的"a", "b"这两个值分别是第一个表达式和第二个表达式匹配的值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>compile</p>
</li>
</ul>
<h3 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h3><ul>
<li><p>兼容所有浏览器，FireFox from v1，IE from v4</p>
</li>
<li><p>match</p>
<ol>
<li>进行全局搜索不带有属性g时，相当于exec方法，返回类数组</li>
<li>进行全局搜索带有属性g时，只返回匹配到的值按数组格式返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> execReg1 = <span class="regexp">/(\w)\1(\w)\2/</span>;</span><br><span class="line"><span class="keyword">var</span> execStr1 = <span class="string">"aabb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execStr1.match(execReg1));<span class="comment">// ["aabb", "a", "b", index: 0, input: "aabb", groups: undefined]</span></span><br><span class="line"><span class="keyword">var</span> execReg1 = <span class="regexp">/(\w)\1(\w)\2/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execStr1.match(execReg1));<span class="comment">// ["aabb"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>search 返回匹配到的位置</p>
<ol>
<li><p>匹配成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> execStr2 = <span class="string">"elkdaabba"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execStr2.search(execReg1));<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>未匹配到字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> execStr3 = <span class="string">"elkdacabba"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(execStr3.search(execReg1));<span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>split 按照正则表达式将字符串拆分为<strong>字符串数组</strong></p>
<ol>
<li><p>子表达式：按照子表达式所匹配到的字符分割字符串，并返回分割后的数组。数组内包含子表达式所匹配到的第一个字符，并且子表达式内的元字符无论是字符串还是数字都会匹配到第一个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> splitReg = <span class="regexp">/(\w)\1/g</span>;</span><br><span class="line"><span class="keyword">var</span> splitStr = <span class="string">"sldkffjalaskddjflkflaasjsajjfkd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(splitStr.split(splitReg));<span class="comment">// ["sldk", "f", "jalask", "d", "jflkfl", "a", "sjsa", "j", "fkd"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他表达式<br>表达式内不包含子表达式时，会以所匹配的字符将字符串分割为数组，并且是全局匹配，所以不需要写上<strong>属性g</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> splitReg1 = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="keyword">var</span> splitStr1 = <span class="string">"sldk0jalask0jflkfl0sjsa0fkd"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(splitStr1.split(splitReg1));<span class="comment">// ["sldk", "jalask", "jflkfl", "sjsa", "fkd"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>replace 替换与正则表达式匹配的字符串</p>
<ol>
<li><p>非正则表达式形式使用replace<br> 注意：只能匹配到第一个字符换并且替换，无法全局匹配(非正式表达式的缺陷)</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceStr = <span class="string">'aa'</span>;</span><br><span class="line"><span class="keyword">var</span> newR = replaceStr.replace(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newR);<span class="comment">// ba</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的形式<br> replace的第二个参数可以反向引用正则表达式内的子表达式的内容，通过符号”$+数字”的形式来表示引用的第几个子表达式，一个符号表示一个字符</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceStr = <span class="string">'aabb'</span>;</span><br><span class="line"><span class="keyword">var</span> replaceReg = <span class="regexp">/(\w)\1(\w)\2/g</span>;</span><br><span class="line"><span class="keyword">var</span> newR = replaceStr.replace(replaceReg, <span class="string">'$2$2$1$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newR);<span class="comment">// bbaa</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xyxy的格式改为yxyx的形式</span></span><br><span class="line"><span class="keyword">var</span> replaceStr1 = <span class="string">'abab'</span>;</span><br><span class="line"><span class="keyword">var</span> replaceReg1 = <span class="regexp">/(\w)(\w)\1\2/g</span>;</span><br><span class="line"><span class="keyword">var</span> newString1 = replaceStr1.replace(replaceReg1, <span class="string">'$1$2$1$2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newString1);<span class="comment">// baba</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的形式<br>replace的第二个参数可以是一个匿名函数，函数内将匹配到的结果返回。系统会自动向函数传递参数，传递的第一个参数是正则表达式匹配的全局(结果)$，第二个参数是第一个子表达的内容$1，$2…依次类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newString2 = replaceStr.replace(replaceReg, <span class="function"><span class="keyword">function</span>(<span class="params">$, $<span class="number">1</span>, $<span class="number">2</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> $<span class="number">2</span> + $<span class="number">2</span> + $<span class="number">1</span> + $<span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newString2);<span class="comment">// bbaa</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceStr2 = <span class="string">"the-first-name"</span>;</span><br><span class="line"><span class="keyword">var</span> replaceReg2 = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> newString3 = replaceStr2.replace(replaceReg2, <span class="function"><span class="keyword">function</span>(<span class="params">$, $<span class="number">1</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 每匹配到一个结果就执行一次函数</span></span><br><span class="line"><span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newString3);<span class="comment">// theFirstName</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符是”$”时，不能直接将字符”$”作为第二个参数写入，因为它代表”$1、$2”在此处是有语法意义的，代表正则表达式内的子表达式。如果想要强行替换为”$”，可以在符号”$”前再加上”$”，具有转义的作用。</p>
<p>疑惑：不转义也OK啊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string3 = <span class="string">"hao kun"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp5 = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string3.replace(regexp5, <span class="string">"$ $"</span>));<span class="comment">// $ $</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="正向预查-正向断言-：选择后边带有特定字符的表达式，其中后边跟随的字符不参与选择，只起到限定的作用。"><a href="#正向预查-正向断言-：选择后边带有特定字符的表达式，其中后边跟随的字符不参与选择，只起到限定的作用。" class="headerlink" title="正向预查(正向断言)：选择后边带有特定字符的表达式，其中后边跟随的字符不参与选择，只起到限定的作用。"></a>正向预查(正向断言)：选择后边带有特定字符的表达式，其中后边跟随的字符不参与选择，只起到限定的作用。</h3><ul>
<li>写法：?=n<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配后边仅是b的a</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"abaaaa"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp1 = <span class="regexp">/a(?=b)/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regexp1)); <span class="comment">// ["a"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="非正向预查"><a href="#非正向预查" class="headerlink" title="非正向预查"></a>非正向预查</h3><ul>
<li>写法：?!<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配后边不是b的所有a</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"abaaaa"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp2 = <span class="regexp">/a(?!b)/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string1.match(regexp2)); <span class="comment">// ["a", "a", "a", "a"]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><ul>
<li><p>默认正则表达式是贪婪匹配模式，尽可能多的匹配</p>
</li>
<li><p>非贪婪匹配：尽可能少的匹配(无论取值范围是多少，所取值都是最小值)<br>  格式：在量词后加上符号”?”</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string2 = <span class="string">"aaaa"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp3 = <span class="regexp">/a+?/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regexp3));<span class="comment">// ["a", "a", "a", "a"]</span></span><br></pre></td></tr></table></figure>

<p>  ??格式：第一个”?”表示量词{0, 1}，第二个”?”表示取消贪婪匹配。这样量词就只会取到数值0，不会取1</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string2 = <span class="string">"aaaa"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp4 = <span class="regexp">/a??/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2.match(regexp4));<span class="comment">//  ["", "", "", "", ""]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="特殊符号不能直接匹配，需要进行转义"><a href="#特殊符号不能直接匹配，需要进行转义" class="headerlink" title="特殊符号不能直接匹配，需要进行转义"></a>特殊符号不能直接匹配，需要进行转义</h3><h3 id="最难面试题"><a href="#最难面试题" class="headerlink" title="最难面试题"></a>最难面试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 科学技术法：从后向前查，每隔三位加一个符号</span></span><br><span class="line"><span class="keyword">var</span> string5 = <span class="string">"100000000000"</span>;</span><br><span class="line"><span class="keyword">var</span> regexp7 = <span class="regexp">/(?=(\B)(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line"><span class="keyword">var</span> newArr = string5.replace(regexp7, <span class="string">"."</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">// 100.000.000.000</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
